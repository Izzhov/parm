# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.11
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_sim3dlong', [dirname(__file__)])
        except ImportError:
            import _sim3dlong
            return _sim3dlong
        if fp is not None:
            try:
                _mod = imp.load_module('_sim3dlong', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _sim3dlong = swig_import_helper()
    del swig_import_helper
else:
    import _sim3dlong
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


import collections
class SwigPyIterator(_object):
    """Proxy of C++ swig::SwigPyIterator class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _sim3dlong.delete_SwigPyIterator
    __del__ = lambda self : None;
    def value(self) -> "PyObject *" :
        """value(SwigPyIterator self) -> PyObject *"""
        return _sim3dlong.SwigPyIterator_value(self)

    def incr(self, n : 'size_t'=1) -> "swig::SwigPyIterator *" :
        """
        incr(SwigPyIterator self, size_t n=1) -> SwigPyIterator
        incr(SwigPyIterator self) -> SwigPyIterator
        """
        return _sim3dlong.SwigPyIterator_incr(self, n)

    def decr(self, n : 'size_t'=1) -> "swig::SwigPyIterator *" :
        """
        decr(SwigPyIterator self, size_t n=1) -> SwigPyIterator
        decr(SwigPyIterator self) -> SwigPyIterator
        """
        return _sim3dlong.SwigPyIterator_decr(self, n)

    def distance(self, *args) -> "ptrdiff_t" :
        """distance(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t"""
        return _sim3dlong.SwigPyIterator_distance(self, *args)

    def equal(self, *args) -> "bool" :
        """equal(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _sim3dlong.SwigPyIterator_equal(self, *args)

    def copy(self) -> "swig::SwigPyIterator *" :
        """copy(SwigPyIterator self) -> SwigPyIterator"""
        return _sim3dlong.SwigPyIterator_copy(self)

    def next(self) -> "PyObject *" :
        """next(SwigPyIterator self) -> PyObject *"""
        return _sim3dlong.SwigPyIterator_next(self)

    def __next__(self) -> "PyObject *" :
        """__next__(SwigPyIterator self) -> PyObject *"""
        return _sim3dlong.SwigPyIterator___next__(self)

    def previous(self) -> "PyObject *" :
        """previous(SwigPyIterator self) -> PyObject *"""
        return _sim3dlong.SwigPyIterator_previous(self)

    def advance(self, *args) -> "swig::SwigPyIterator *" :
        """advance(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _sim3dlong.SwigPyIterator_advance(self, *args)

    def __eq__(self, *args) -> "bool" :
        """__eq__(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _sim3dlong.SwigPyIterator___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        """__ne__(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _sim3dlong.SwigPyIterator___ne__(self, *args)

    def __iadd__(self, *args) -> "swig::SwigPyIterator &" :
        """__iadd__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _sim3dlong.SwigPyIterator___iadd__(self, *args)

    def __isub__(self, *args) -> "swig::SwigPyIterator &" :
        """__isub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _sim3dlong.SwigPyIterator___isub__(self, *args)

    def __add__(self, *args) -> "swig::SwigPyIterator *" :
        """__add__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _sim3dlong.SwigPyIterator___add__(self, *args)

    def __sub__(self, *args) -> "ptrdiff_t" :
        """
        __sub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator
        __sub__(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t
        """
        return _sim3dlong.SwigPyIterator___sub__(self, *args)

    def __iter__(self): return self
SwigPyIterator_swigregister = _sim3dlong.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class _Nvector3(_object):
    """Proxy of C++ Nvector<(double,3)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _Nvector3, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _Nvector3, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(Nvector<(double,3)> self) -> _Nvector3
        __init__(Nvector<(double,3)> self, _Nvector3 rhs) -> _Nvector3
        __init__(Nvector<(double,3)> self, double const [3] locs) -> _Nvector3
        """
        this = _sim3dlong.new__Nvector3(*args)
        try: self.this.append(this)
        except: self.this = this
    def get(self, *args) -> "double const &" :
        """get(_Nvector3 self, unsigned int const n) -> double const &"""
        return _sim3dlong._Nvector3_get(self, *args)

    def set(self, *args) -> "void" :
        """set(_Nvector3 self, unsigned int const n, double const a)"""
        return _sim3dlong._Nvector3_set(self, *args)

    def len(self) -> "unsigned int" :
        """len(_Nvector3 self) -> unsigned int"""
        return _sim3dlong._Nvector3_len(self)

    def __iadd__(self, *args) -> "Nvector< double,3 > &" :
        """__iadd__(_Nvector3 self, _Nvector3 rhs) -> _Nvector3"""
        return _sim3dlong._Nvector3___iadd__(self, *args)

    def __isub__(self, *args) -> "Nvector< double,3 > &" :
        """__isub__(_Nvector3 self, _Nvector3 rhs) -> _Nvector3"""
        return _sim3dlong._Nvector3___isub__(self, *args)

    def __neg__(self) -> "Nvector< double,3 >" :
        """__neg__(_Nvector3 self) -> _Nvector3"""
        return _sim3dlong._Nvector3___neg__(self)

    def __add__(self, *args) -> "Nvector< double,3 >" :
        """__add__(_Nvector3 self, _Nvector3 rhs) -> _Nvector3"""
        return _sim3dlong._Nvector3___add__(self, *args)

    def __sub__(self, *args) -> "Nvector< double,3 >" :
        """__sub__(_Nvector3 self, _Nvector3 rhs) -> _Nvector3"""
        return _sim3dlong._Nvector3___sub__(self, *args)

    def begin(self) -> "double *" :
        """begin(_Nvector3 self) -> double *"""
        return _sim3dlong._Nvector3_begin(self)

    def end(self) -> "double *" :
        """end(_Nvector3 self) -> double *"""
        return _sim3dlong._Nvector3_end(self)

    __swig_destroy__ = _sim3dlong.delete__Nvector3
    __del__ = lambda self : None;
    def __mul__(self, *args) -> "Nvector< double,3 >" :
        """__mul__(_Nvector3 self, double const rhs) -> _Nvector3"""
        return _sim3dlong._Nvector3___mul__(self, *args)

    def __div__(self, *args) -> "Nvector< double,3 >" :
        """__div__(_Nvector3 self, double const rhs) -> _Nvector3"""
        return _sim3dlong._Nvector3___div__(self, *args)

    def __truediv__(self, *args) -> "Nvector< double,3 >" :
        """__truediv__(_Nvector3 self, double const n) -> _Nvector3"""
        return _sim3dlong._Nvector3___truediv__(self, *args)

    def __getitem__(self, *args) -> "double" :
        """__getitem__(_Nvector3 self, unsigned int const n) -> double"""
        return _sim3dlong._Nvector3___getitem__(self, *args)

    def __setitem__(self, *args) -> "void" :
        """__setitem__(_Nvector3 self, unsigned int const n, double const val)"""
        return _sim3dlong._Nvector3___setitem__(self, *args)

    def __len__(self) -> "unsigned int" :
        """__len__(_Nvector3 self) -> unsigned int"""
        return _sim3dlong._Nvector3___len__(self)

    #~ def __setitem__(self, n, val):
        #~ return self.set(n, val)

    def __iter__(self):
        for i in range(len(self)):
            yield self.get(i)

    #~ def __len__(self):
        #~ return self.len()

_Nvector3_swigregister = _sim3dlong._Nvector3_swigregister
_Nvector3_swigregister(_Nvector3)

class _Nvector2(_object):
    """Proxy of C++ Nvector<(double,2)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _Nvector2, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _Nvector2, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(Nvector<(double,2)> self) -> _Nvector2
        __init__(Nvector<(double,2)> self, _Nvector2 rhs) -> _Nvector2
        __init__(Nvector<(double,2)> self, double const [2] locs) -> _Nvector2
        """
        this = _sim3dlong.new__Nvector2(*args)
        try: self.this.append(this)
        except: self.this = this
    def get(self, *args) -> "double const &" :
        """get(_Nvector2 self, unsigned int const n) -> double const &"""
        return _sim3dlong._Nvector2_get(self, *args)

    def set(self, *args) -> "void" :
        """set(_Nvector2 self, unsigned int const n, double const a)"""
        return _sim3dlong._Nvector2_set(self, *args)

    def len(self) -> "unsigned int" :
        """len(_Nvector2 self) -> unsigned int"""
        return _sim3dlong._Nvector2_len(self)

    def __iadd__(self, *args) -> "Nvector< double,2 > &" :
        """__iadd__(_Nvector2 self, _Nvector2 rhs) -> _Nvector2"""
        return _sim3dlong._Nvector2___iadd__(self, *args)

    def __isub__(self, *args) -> "Nvector< double,2 > &" :
        """__isub__(_Nvector2 self, _Nvector2 rhs) -> _Nvector2"""
        return _sim3dlong._Nvector2___isub__(self, *args)

    def __neg__(self) -> "Nvector< double,2 >" :
        """__neg__(_Nvector2 self) -> _Nvector2"""
        return _sim3dlong._Nvector2___neg__(self)

    def __add__(self, *args) -> "Nvector< double,2 >" :
        """__add__(_Nvector2 self, _Nvector2 rhs) -> _Nvector2"""
        return _sim3dlong._Nvector2___add__(self, *args)

    def __sub__(self, *args) -> "Nvector< double,2 >" :
        """__sub__(_Nvector2 self, _Nvector2 rhs) -> _Nvector2"""
        return _sim3dlong._Nvector2___sub__(self, *args)

    def begin(self) -> "double *" :
        """begin(_Nvector2 self) -> double *"""
        return _sim3dlong._Nvector2_begin(self)

    def end(self) -> "double *" :
        """end(_Nvector2 self) -> double *"""
        return _sim3dlong._Nvector2_end(self)

    __swig_destroy__ = _sim3dlong.delete__Nvector2
    __del__ = lambda self : None;
    def __mul__(self, *args) -> "Nvector< double,2 >" :
        """__mul__(_Nvector2 self, double const rhs) -> _Nvector2"""
        return _sim3dlong._Nvector2___mul__(self, *args)

    def __div__(self, *args) -> "Nvector< double,2 >" :
        """__div__(_Nvector2 self, double const rhs) -> _Nvector2"""
        return _sim3dlong._Nvector2___div__(self, *args)

    def __truediv__(self, *args) -> "Nvector< double,2 >" :
        """__truediv__(_Nvector2 self, double const n) -> _Nvector2"""
        return _sim3dlong._Nvector2___truediv__(self, *args)

    def __getitem__(self, *args) -> "double" :
        """__getitem__(_Nvector2 self, unsigned int const n) -> double"""
        return _sim3dlong._Nvector2___getitem__(self, *args)

    def __setitem__(self, *args) -> "void" :
        """__setitem__(_Nvector2 self, unsigned int const n, double const val)"""
        return _sim3dlong._Nvector2___setitem__(self, *args)

    def __len__(self) -> "unsigned int" :
        """__len__(_Nvector2 self) -> unsigned int"""
        return _sim3dlong._Nvector2___len__(self)

    #~ def __setitem__(self, n, val):
        #~ return self.set(n, val)

    def __iter__(self):
        for i in range(len(self)):
            yield self.get(i)

    #~ def __len__(self):
        #~ return self.len()

_Nvector2_swigregister = _sim3dlong._Nvector2_swigregister
_Nvector2_swigregister(_Nvector2)

class _Numvector3(_Nvector3):
    """Proxy of C++ Numvector<(double,3)> class"""
    __swig_setmethods__ = {}
    for _s in [_Nvector3]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, _Numvector3, name, value)
    __swig_getmethods__ = {}
    for _s in [_Nvector3]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, _Numvector3, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(Numvector<(double,3)> self) -> _Numvector3
        __init__(Numvector<(double,3)> self, _Nvector3 rhs) -> _Numvector3
        __init__(Numvector<(double,3)> self, double const [3] rhs) -> _Numvector3
        """
        this = _sim3dlong.new__Numvector3(*args)
        try: self.this.append(this)
        except: self.this = this
    def dot(self, *args) -> "double" :
        """dot(_Numvector3 self, _Numvector3 other) -> double"""
        return _sim3dlong._Numvector3_dot(self, *args)

    def sq(self) -> "double" :
        """sq(_Numvector3 self) -> double"""
        return _sim3dlong._Numvector3_sq(self)

    def mag(self) -> "double" :
        """mag(_Numvector3 self) -> double"""
        return _sim3dlong._Numvector3_mag(self)

    def distance(self, *args) -> "double" :
        """distance(_Numvector3 self, _Numvector3 rhs) -> double"""
        return _sim3dlong._Numvector3_distance(self, *args)

    def perpto(self, *args) -> "Numvector< double,3 >" :
        """perpto(_Numvector3 self, _Numvector3 other) -> _Numvector3"""
        return _sim3dlong._Numvector3_perpto(self, *args)

    def normalize(self) -> "void" :
        """normalize(_Numvector3 self)"""
        return _sim3dlong._Numvector3_normalize(self)

    def norm(self) -> "Numvector< double,3 >" :
        """norm(_Numvector3 self) -> _Numvector3"""
        return _sim3dlong._Numvector3_norm(self)

    __swig_destroy__ = _sim3dlong.delete__Numvector3
    __del__ = lambda self : None;
_Numvector3_swigregister = _sim3dlong._Numvector3_swigregister
_Numvector3_swigregister(_Numvector3)

class _Numvector2(_Nvector2):
    """Proxy of C++ Numvector<(double,2)> class"""
    __swig_setmethods__ = {}
    for _s in [_Nvector2]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, _Numvector2, name, value)
    __swig_getmethods__ = {}
    for _s in [_Nvector2]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, _Numvector2, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(Numvector<(double,2)> self) -> _Numvector2
        __init__(Numvector<(double,2)> self, _Nvector2 rhs) -> _Numvector2
        __init__(Numvector<(double,2)> self, double const [2] rhs) -> _Numvector2
        """
        this = _sim3dlong.new__Numvector2(*args)
        try: self.this.append(this)
        except: self.this = this
    def dot(self, *args) -> "double" :
        """dot(_Numvector2 self, _Numvector2 other) -> double"""
        return _sim3dlong._Numvector2_dot(self, *args)

    def sq(self) -> "double" :
        """sq(_Numvector2 self) -> double"""
        return _sim3dlong._Numvector2_sq(self)

    def mag(self) -> "double" :
        """mag(_Numvector2 self) -> double"""
        return _sim3dlong._Numvector2_mag(self)

    def distance(self, *args) -> "double" :
        """distance(_Numvector2 self, _Numvector2 rhs) -> double"""
        return _sim3dlong._Numvector2_distance(self, *args)

    def perpto(self, *args) -> "Numvector< double,2 >" :
        """perpto(_Numvector2 self, _Numvector2 other) -> _Numvector2"""
        return _sim3dlong._Numvector2_perpto(self, *args)

    def normalize(self) -> "void" :
        """normalize(_Numvector2 self)"""
        return _sim3dlong._Numvector2_normalize(self)

    def norm(self) -> "Numvector< double,2 >" :
        """norm(_Numvector2 self) -> _Numvector2"""
        return _sim3dlong._Numvector2_norm(self)

    __swig_destroy__ = _sim3dlong.delete__Numvector2
    __del__ = lambda self : None;
_Numvector2_swigregister = _sim3dlong._Numvector2_swigregister
_Numvector2_swigregister(_Numvector2)

class _Nvector3L(_object):
    """Proxy of C++ Nvector<(long double,3)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _Nvector3L, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _Nvector3L, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(Nvector<(long double,3)> self) -> _Nvector3L
        __init__(Nvector<(long double,3)> self, _Nvector3L rhs) -> _Nvector3L
        __init__(Nvector<(long double,3)> self, long double const [3] locs) -> _Nvector3L
        """
        this = _sim3dlong.new__Nvector3L(*args)
        try: self.this.append(this)
        except: self.this = this
    def get(self, *args) -> "long double const &" :
        """get(_Nvector3L self, unsigned int const n) -> long double const &"""
        return _sim3dlong._Nvector3L_get(self, *args)

    def set(self, *args) -> "void" :
        """set(_Nvector3L self, unsigned int const n, long double const a)"""
        return _sim3dlong._Nvector3L_set(self, *args)

    def len(self) -> "unsigned int" :
        """len(_Nvector3L self) -> unsigned int"""
        return _sim3dlong._Nvector3L_len(self)

    def __iadd__(self, *args) -> "Nvector< long double,3 > &" :
        """__iadd__(_Nvector3L self, _Nvector3L rhs) -> _Nvector3L"""
        return _sim3dlong._Nvector3L___iadd__(self, *args)

    def __isub__(self, *args) -> "Nvector< long double,3 > &" :
        """__isub__(_Nvector3L self, _Nvector3L rhs) -> _Nvector3L"""
        return _sim3dlong._Nvector3L___isub__(self, *args)

    def __neg__(self) -> "Nvector< long double,3 >" :
        """__neg__(_Nvector3L self) -> _Nvector3L"""
        return _sim3dlong._Nvector3L___neg__(self)

    def __add__(self, *args) -> "Nvector< long double,3 >" :
        """__add__(_Nvector3L self, _Nvector3L rhs) -> _Nvector3L"""
        return _sim3dlong._Nvector3L___add__(self, *args)

    def __sub__(self, *args) -> "Nvector< long double,3 >" :
        """__sub__(_Nvector3L self, _Nvector3L rhs) -> _Nvector3L"""
        return _sim3dlong._Nvector3L___sub__(self, *args)

    def begin(self) -> "long double *" :
        """begin(_Nvector3L self) -> long double *"""
        return _sim3dlong._Nvector3L_begin(self)

    def end(self) -> "long double *" :
        """end(_Nvector3L self) -> long double *"""
        return _sim3dlong._Nvector3L_end(self)

    __swig_destroy__ = _sim3dlong.delete__Nvector3L
    __del__ = lambda self : None;
    def __mul__(self, *args) -> "Nvector< long double,3 >" :
        """__mul__(_Nvector3L self, double const rhs) -> _Nvector3L"""
        return _sim3dlong._Nvector3L___mul__(self, *args)

    def __div__(self, *args) -> "Nvector< long double,3 >" :
        """__div__(_Nvector3L self, double const rhs) -> _Nvector3L"""
        return _sim3dlong._Nvector3L___div__(self, *args)

    def __truediv__(self, *args) -> "Nvector< long double,3 >" :
        """__truediv__(_Nvector3L self, double const n) -> _Nvector3L"""
        return _sim3dlong._Nvector3L___truediv__(self, *args)

    def __getitem__(self, *args) -> "long double" :
        """__getitem__(_Nvector3L self, unsigned int const n) -> long double"""
        return _sim3dlong._Nvector3L___getitem__(self, *args)

    def __setitem__(self, *args) -> "void" :
        """__setitem__(_Nvector3L self, unsigned int const n, long double const val)"""
        return _sim3dlong._Nvector3L___setitem__(self, *args)

    def __len__(self) -> "unsigned int" :
        """__len__(_Nvector3L self) -> unsigned int"""
        return _sim3dlong._Nvector3L___len__(self)

    #~ def __setitem__(self, n, val):
        #~ return self.set(n, val)

    def __iter__(self):
        for i in range(len(self)):
            yield self.get(i)

    #~ def __len__(self):
        #~ return self.len()

_Nvector3L_swigregister = _sim3dlong._Nvector3L_swigregister
_Nvector3L_swigregister(_Nvector3L)

class _Nvector2L(_object):
    """Proxy of C++ Nvector<(long double,2)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _Nvector2L, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _Nvector2L, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(Nvector<(long double,2)> self) -> _Nvector2L
        __init__(Nvector<(long double,2)> self, _Nvector2L rhs) -> _Nvector2L
        __init__(Nvector<(long double,2)> self, long double const [2] locs) -> _Nvector2L
        """
        this = _sim3dlong.new__Nvector2L(*args)
        try: self.this.append(this)
        except: self.this = this
    def get(self, *args) -> "long double const &" :
        """get(_Nvector2L self, unsigned int const n) -> long double const &"""
        return _sim3dlong._Nvector2L_get(self, *args)

    def set(self, *args) -> "void" :
        """set(_Nvector2L self, unsigned int const n, long double const a)"""
        return _sim3dlong._Nvector2L_set(self, *args)

    def len(self) -> "unsigned int" :
        """len(_Nvector2L self) -> unsigned int"""
        return _sim3dlong._Nvector2L_len(self)

    def __iadd__(self, *args) -> "Nvector< long double,2 > &" :
        """__iadd__(_Nvector2L self, _Nvector2L rhs) -> _Nvector2L"""
        return _sim3dlong._Nvector2L___iadd__(self, *args)

    def __isub__(self, *args) -> "Nvector< long double,2 > &" :
        """__isub__(_Nvector2L self, _Nvector2L rhs) -> _Nvector2L"""
        return _sim3dlong._Nvector2L___isub__(self, *args)

    def __neg__(self) -> "Nvector< long double,2 >" :
        """__neg__(_Nvector2L self) -> _Nvector2L"""
        return _sim3dlong._Nvector2L___neg__(self)

    def __add__(self, *args) -> "Nvector< long double,2 >" :
        """__add__(_Nvector2L self, _Nvector2L rhs) -> _Nvector2L"""
        return _sim3dlong._Nvector2L___add__(self, *args)

    def __sub__(self, *args) -> "Nvector< long double,2 >" :
        """__sub__(_Nvector2L self, _Nvector2L rhs) -> _Nvector2L"""
        return _sim3dlong._Nvector2L___sub__(self, *args)

    def begin(self) -> "long double *" :
        """begin(_Nvector2L self) -> long double *"""
        return _sim3dlong._Nvector2L_begin(self)

    def end(self) -> "long double *" :
        """end(_Nvector2L self) -> long double *"""
        return _sim3dlong._Nvector2L_end(self)

    __swig_destroy__ = _sim3dlong.delete__Nvector2L
    __del__ = lambda self : None;
    def __mul__(self, *args) -> "Nvector< long double,2 >" :
        """__mul__(_Nvector2L self, double const rhs) -> _Nvector2L"""
        return _sim3dlong._Nvector2L___mul__(self, *args)

    def __div__(self, *args) -> "Nvector< long double,2 >" :
        """__div__(_Nvector2L self, double const rhs) -> _Nvector2L"""
        return _sim3dlong._Nvector2L___div__(self, *args)

    def __truediv__(self, *args) -> "Nvector< long double,2 >" :
        """__truediv__(_Nvector2L self, double const n) -> _Nvector2L"""
        return _sim3dlong._Nvector2L___truediv__(self, *args)

    def __getitem__(self, *args) -> "long double" :
        """__getitem__(_Nvector2L self, unsigned int const n) -> long double"""
        return _sim3dlong._Nvector2L___getitem__(self, *args)

    def __setitem__(self, *args) -> "void" :
        """__setitem__(_Nvector2L self, unsigned int const n, long double const val)"""
        return _sim3dlong._Nvector2L___setitem__(self, *args)

    def __len__(self) -> "unsigned int" :
        """__len__(_Nvector2L self) -> unsigned int"""
        return _sim3dlong._Nvector2L___len__(self)

    #~ def __setitem__(self, n, val):
        #~ return self.set(n, val)

    def __iter__(self):
        for i in range(len(self)):
            yield self.get(i)

    #~ def __len__(self):
        #~ return self.len()

_Nvector2L_swigregister = _sim3dlong._Nvector2L_swigregister
_Nvector2L_swigregister(_Nvector2L)

class _Numvector3L(_Nvector3L):
    """Proxy of C++ Numvector<(long double,3)> class"""
    __swig_setmethods__ = {}
    for _s in [_Nvector3L]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, _Numvector3L, name, value)
    __swig_getmethods__ = {}
    for _s in [_Nvector3L]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, _Numvector3L, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(Numvector<(long double,3)> self) -> _Numvector3L
        __init__(Numvector<(long double,3)> self, _Nvector3L rhs) -> _Numvector3L
        __init__(Numvector<(long double,3)> self, long double const [3] rhs) -> _Numvector3L
        """
        this = _sim3dlong.new__Numvector3L(*args)
        try: self.this.append(this)
        except: self.this = this
    def dot(self, *args) -> "long double" :
        """dot(_Numvector3L self, _Numvector3L other) -> long double"""
        return _sim3dlong._Numvector3L_dot(self, *args)

    def sq(self) -> "long double" :
        """sq(_Numvector3L self) -> long double"""
        return _sim3dlong._Numvector3L_sq(self)

    def mag(self) -> "long double" :
        """mag(_Numvector3L self) -> long double"""
        return _sim3dlong._Numvector3L_mag(self)

    def distance(self, *args) -> "long double" :
        """distance(_Numvector3L self, _Numvector3L rhs) -> long double"""
        return _sim3dlong._Numvector3L_distance(self, *args)

    def perpto(self, *args) -> "Numvector< long double,3 >" :
        """perpto(_Numvector3L self, _Numvector3L other) -> _Numvector3L"""
        return _sim3dlong._Numvector3L_perpto(self, *args)

    def normalize(self) -> "void" :
        """normalize(_Numvector3L self)"""
        return _sim3dlong._Numvector3L_normalize(self)

    def norm(self) -> "Numvector< long double,3 >" :
        """norm(_Numvector3L self) -> _Numvector3L"""
        return _sim3dlong._Numvector3L_norm(self)

    __swig_destroy__ = _sim3dlong.delete__Numvector3L
    __del__ = lambda self : None;
_Numvector3L_swigregister = _sim3dlong._Numvector3L_swigregister
_Numvector3L_swigregister(_Numvector3L)

class _Numvector2L(_Nvector2L):
    """Proxy of C++ Numvector<(long double,2)> class"""
    __swig_setmethods__ = {}
    for _s in [_Nvector2L]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, _Numvector2L, name, value)
    __swig_getmethods__ = {}
    for _s in [_Nvector2L]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, _Numvector2L, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(Numvector<(long double,2)> self) -> _Numvector2L
        __init__(Numvector<(long double,2)> self, _Nvector2L rhs) -> _Numvector2L
        __init__(Numvector<(long double,2)> self, long double const [2] rhs) -> _Numvector2L
        """
        this = _sim3dlong.new__Numvector2L(*args)
        try: self.this.append(this)
        except: self.this = this
    def dot(self, *args) -> "long double" :
        """dot(_Numvector2L self, _Numvector2L other) -> long double"""
        return _sim3dlong._Numvector2L_dot(self, *args)

    def sq(self) -> "long double" :
        """sq(_Numvector2L self) -> long double"""
        return _sim3dlong._Numvector2L_sq(self)

    def mag(self) -> "long double" :
        """mag(_Numvector2L self) -> long double"""
        return _sim3dlong._Numvector2L_mag(self)

    def distance(self, *args) -> "long double" :
        """distance(_Numvector2L self, _Numvector2L rhs) -> long double"""
        return _sim3dlong._Numvector2L_distance(self, *args)

    def perpto(self, *args) -> "Numvector< long double,2 >" :
        """perpto(_Numvector2L self, _Numvector2L other) -> _Numvector2L"""
        return _sim3dlong._Numvector2L_perpto(self, *args)

    def normalize(self) -> "void" :
        """normalize(_Numvector2L self)"""
        return _sim3dlong._Numvector2L_normalize(self)

    def norm(self) -> "Numvector< long double,2 >" :
        """norm(_Numvector2L self) -> _Numvector2L"""
        return _sim3dlong._Numvector2L_norm(self)

    __swig_destroy__ = _sim3dlong.delete__Numvector2L
    __del__ = lambda self : None;
_Numvector2L_swigregister = _sim3dlong._Numvector2L_swigregister
_Numvector2L_swigregister(_Numvector2L)

class Vec(_Numvector3):
    """Proxy of C++ Vector3<(double)> class"""
    __swig_setmethods__ = {}
    for _s in [_Numvector3]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Vec, name, value)
    __swig_getmethods__ = {}
    for _s in [_Numvector3]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Vec, name)
    def __init__(self, *args): 
        """
        __init__(Vector3<(double)> self) -> Vec
        __init__(Vector3<(double)> self, double const a, double const b, double const c) -> Vec
        __init__(Vector3<(double)> self, _Numvector3 rhs) -> Vec
        __init__(Vector3<(double)> self, _Nvector3 rhs) -> Vec
        """
        this = _sim3dlong.new_Vec(*args)
        try: self.this.append(this)
        except: self.this = this
    def getx(self) -> "double const" :
        """getx(Vec self) -> double const"""
        return _sim3dlong.Vec_getx(self)

    def gety(self) -> "double const" :
        """gety(Vec self) -> double const"""
        return _sim3dlong.Vec_gety(self)

    def getz(self) -> "double const" :
        """getz(Vec self) -> double const"""
        return _sim3dlong.Vec_getz(self)

    def getxd(self) -> "double" :
        """getxd(Vec self) -> double"""
        return _sim3dlong.Vec_getxd(self)

    def getyd(self) -> "double" :
        """getyd(Vec self) -> double"""
        return _sim3dlong.Vec_getyd(self)

    def getzd(self) -> "double" :
        """getzd(Vec self) -> double"""
        return _sim3dlong.Vec_getzd(self)

    def setx(self, *args) -> "void" :
        """setx(Vec self, double const a)"""
        return _sim3dlong.Vec_setx(self, *args)

    def sety(self, *args) -> "void" :
        """sety(Vec self, double const b)"""
        return _sim3dlong.Vec_sety(self, *args)

    def setz(self, *args) -> "void" :
        """setz(Vec self, double const c)"""
        return _sim3dlong.Vec_setz(self, *args)

    def setxd(self, *args) -> "void" :
        """setxd(Vec self, double const a)"""
        return _sim3dlong.Vec_setxd(self, *args)

    def setyd(self, *args) -> "void" :
        """setyd(Vec self, double const b)"""
        return _sim3dlong.Vec_setyd(self, *args)

    def setzd(self, *args) -> "void" :
        """setzd(Vec self, double const c)"""
        return _sim3dlong.Vec_setzd(self, *args)

    def set(self, *args) -> "void" :
        """set(Vec self, double const a, double const b, double const c)"""
        return _sim3dlong.Vec_set(self, *args)

    def __neg__(self) -> "Vector3< double >" :
        """__neg__(Vec self) -> Vec"""
        return _sim3dlong.Vec___neg__(self)

    def __add__(self, *args) -> "Vector3< double >" :
        """__add__(Vec self, Vec rhs) -> Vec"""
        return _sim3dlong.Vec___add__(self, *args)

    def __sub__(self, *args) -> "Vector3< double >" :
        """__sub__(Vec self, Vec rhs) -> Vec"""
        return _sim3dlong.Vec___sub__(self, *args)

    def cross(self, *args) -> "Vector3< double >" :
        """cross(Vec self, Vec rhs) -> Vec"""
        return _sim3dlong.Vec_cross(self, *args)

    def norm(self) -> "Vector3< double >" :
        """norm(Vec self) -> Vec"""
        return _sim3dlong.Vec_norm(self)

    def __isub__(self, *args) -> "Vector3< double > &" :
        """__isub__(Vec self, Vec rhs) -> Vec"""
        return _sim3dlong.Vec___isub__(self, *args)

    def __iadd__(self, *args) -> "Vector3< double > &" :
        """__iadd__(Vec self, Vec rhs) -> Vec"""
        return _sim3dlong.Vec___iadd__(self, *args)

    def angle(*args) -> "double" :
        """
        angle(Vec dx1, Vec dx2) -> double
        angle(Vec x1, Vec x2, Vec x3) -> double
        """
        return _sim3dlong.Vec_angle(*args)

    if _newclass:angle = staticmethod(angle)
    __swig_getmethods__["angle"] = lambda x: angle
    def dihedral(*args) -> "double" :
        """
        dihedral(Vec dx1, Vec dx2, Vec dx3) -> double
        dihedral(Vec x1, Vec x2, Vec x3, Vec x4) -> double
        """
        return _sim3dlong.Vec_dihedral(*args)

    if _newclass:dihedral = staticmethod(dihedral)
    __swig_getmethods__["dihedral"] = lambda x: dihedral
    __swig_destroy__ = _sim3dlong.delete_Vec
    __del__ = lambda self : None;
    def __str__(self) -> "char *" :
        """__str__(Vec self) -> char *"""
        return _sim3dlong.Vec___str__(self)

    def __repr__(self) -> "char *" :
        """__repr__(Vec self) -> char *"""
        return _sim3dlong.Vec___repr__(self)

    def __truediv__(self, *args) -> "Vector3< double >" :
        """__truediv__(Vec self, double const n) -> Vec"""
        return _sim3dlong.Vec___truediv__(self, *args)

    def __mul__(self, *args) -> "Vector3< double >" :
        """
        __mul__(Vec self, Vec rhs) -> double
        __mul__(Vec self, double const n) -> Vec
        """
        return _sim3dlong.Vec___mul__(self, *args)

    @property
    def X(self):
        return self.getxd()

    @property
    def Y(self):
        return self.getyd()

    @property
    def Z(self):
        return self.getzd()

Vec_swigregister = _sim3dlong.Vec_swigregister
Vec_swigregister(Vec)

def Vec_angle(*args) -> "double" :
  """
    angle(Vec dx1, Vec dx2) -> double
    Vec_angle(Vec x1, Vec x2, Vec x3) -> double
    """
  return _sim3dlong.Vec_angle(*args)

def Vec_dihedral(*args) -> "double" :
  """
    dihedral(Vec dx1, Vec dx2, Vec dx3) -> double
    Vec_dihedral(Vec x1, Vec x2, Vec x3, Vec x4) -> double
    """
  return _sim3dlong.Vec_dihedral(*args)

class VecL(_Numvector3L):
    """Proxy of C++ Vector3<(long double)> class"""
    __swig_setmethods__ = {}
    for _s in [_Numvector3L]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, VecL, name, value)
    __swig_getmethods__ = {}
    for _s in [_Numvector3L]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, VecL, name)
    def __init__(self, *args): 
        """
        __init__(Vector3<(long double)> self) -> VecL
        __init__(Vector3<(long double)> self, long double const a, long double const b, long double const c) -> VecL
        __init__(Vector3<(long double)> self, _Numvector3L rhs) -> VecL
        __init__(Vector3<(long double)> self, _Nvector3L rhs) -> VecL
        """
        this = _sim3dlong.new_VecL(*args)
        try: self.this.append(this)
        except: self.this = this
    def getx(self) -> "long double const" :
        """getx(VecL self) -> long double const"""
        return _sim3dlong.VecL_getx(self)

    def gety(self) -> "long double const" :
        """gety(VecL self) -> long double const"""
        return _sim3dlong.VecL_gety(self)

    def getz(self) -> "long double const" :
        """getz(VecL self) -> long double const"""
        return _sim3dlong.VecL_getz(self)

    def getxd(self) -> "double" :
        """getxd(VecL self) -> double"""
        return _sim3dlong.VecL_getxd(self)

    def getyd(self) -> "double" :
        """getyd(VecL self) -> double"""
        return _sim3dlong.VecL_getyd(self)

    def getzd(self) -> "double" :
        """getzd(VecL self) -> double"""
        return _sim3dlong.VecL_getzd(self)

    def setx(self, *args) -> "void" :
        """setx(VecL self, long double const a)"""
        return _sim3dlong.VecL_setx(self, *args)

    def sety(self, *args) -> "void" :
        """sety(VecL self, long double const b)"""
        return _sim3dlong.VecL_sety(self, *args)

    def setz(self, *args) -> "void" :
        """setz(VecL self, long double const c)"""
        return _sim3dlong.VecL_setz(self, *args)

    def setxd(self, *args) -> "void" :
        """setxd(VecL self, double const a)"""
        return _sim3dlong.VecL_setxd(self, *args)

    def setyd(self, *args) -> "void" :
        """setyd(VecL self, double const b)"""
        return _sim3dlong.VecL_setyd(self, *args)

    def setzd(self, *args) -> "void" :
        """setzd(VecL self, double const c)"""
        return _sim3dlong.VecL_setzd(self, *args)

    def set(self, *args) -> "void" :
        """set(VecL self, long double const a, long double const b, long double const c)"""
        return _sim3dlong.VecL_set(self, *args)

    def __neg__(self) -> "Vector3< long double >" :
        """__neg__(VecL self) -> VecL"""
        return _sim3dlong.VecL___neg__(self)

    def __add__(self, *args) -> "Vector3< long double >" :
        """__add__(VecL self, VecL rhs) -> VecL"""
        return _sim3dlong.VecL___add__(self, *args)

    def __sub__(self, *args) -> "Vector3< long double >" :
        """__sub__(VecL self, VecL rhs) -> VecL"""
        return _sim3dlong.VecL___sub__(self, *args)

    def cross(self, *args) -> "Vector3< long double >" :
        """cross(VecL self, VecL rhs) -> VecL"""
        return _sim3dlong.VecL_cross(self, *args)

    def norm(self) -> "Vector3< long double >" :
        """norm(VecL self) -> VecL"""
        return _sim3dlong.VecL_norm(self)

    def __isub__(self, *args) -> "Vector3< long double > &" :
        """__isub__(VecL self, VecL rhs) -> VecL"""
        return _sim3dlong.VecL___isub__(self, *args)

    def __iadd__(self, *args) -> "Vector3< long double > &" :
        """__iadd__(VecL self, VecL rhs) -> VecL"""
        return _sim3dlong.VecL___iadd__(self, *args)

    def angle(*args) -> "long double" :
        """
        angle(VecL dx1, VecL dx2) -> long double
        angle(VecL x1, VecL x2, VecL x3) -> long double
        """
        return _sim3dlong.VecL_angle(*args)

    if _newclass:angle = staticmethod(angle)
    __swig_getmethods__["angle"] = lambda x: angle
    def dihedral(*args) -> "long double" :
        """
        dihedral(VecL dx1, VecL dx2, VecL dx3) -> long double
        dihedral(VecL x1, VecL x2, VecL x3, VecL x4) -> long double
        """
        return _sim3dlong.VecL_dihedral(*args)

    if _newclass:dihedral = staticmethod(dihedral)
    __swig_getmethods__["dihedral"] = lambda x: dihedral
    __swig_destroy__ = _sim3dlong.delete_VecL
    __del__ = lambda self : None;
    def __str__(self) -> "char *" :
        """__str__(VecL self) -> char *"""
        return _sim3dlong.VecL___str__(self)

    def __repr__(self) -> "char *" :
        """__repr__(VecL self) -> char *"""
        return _sim3dlong.VecL___repr__(self)

    def __truediv__(self, *args) -> "Vector3< long double >" :
        """__truediv__(VecL self, double const n) -> VecL"""
        return _sim3dlong.VecL___truediv__(self, *args)

    def __mul__(self, *args) -> "Vector3< long double >" :
        """
        __mul__(VecL self, VecL rhs) -> long double
        __mul__(VecL self, double const n) -> VecL
        """
        return _sim3dlong.VecL___mul__(self, *args)

    @property
    def X(self):
        return self.getxd()

    @property
    def Y(self):
        return self.getyd()

    @property
    def Z(self):
        return self.getzd()

VecL_swigregister = _sim3dlong.VecL_swigregister
VecL_swigregister(VecL)

def VecL_angle(*args) -> "long double" :
  """
    angle(VecL dx1, VecL dx2) -> long double
    VecL_angle(VecL x1, VecL x2, VecL x3) -> long double
    """
  return _sim3dlong.VecL_angle(*args)

def VecL_dihedral(*args) -> "long double" :
  """
    dihedral(VecL dx1, VecL dx2, VecL dx3) -> long double
    VecL_dihedral(VecL x1, VecL x2, VecL x3, VecL x4) -> long double
    """
  return _sim3dlong.VecL_dihedral(*args)

class _MatrixBase(_object):
    """Proxy of C++ Nvector<(Vector3<(double)>,3)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _MatrixBase, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _MatrixBase, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(Nvector<(Vector3<(double)>,3)> self) -> _MatrixBase
        __init__(Nvector<(Vector3<(double)>,3)> self, _MatrixBase rhs) -> _MatrixBase
        __init__(Nvector<(Vector3<(double)>,3)> self, Vec locs) -> _MatrixBase
        """
        this = _sim3dlong.new__MatrixBase(*args)
        try: self.this.append(this)
        except: self.this = this
    def get(self, *args) -> "Vector3< double > const &" :
        """get(_MatrixBase self, unsigned int const n) -> Vec"""
        return _sim3dlong._MatrixBase_get(self, *args)

    def set(self, *args) -> "void" :
        """set(_MatrixBase self, unsigned int const n, Vec a)"""
        return _sim3dlong._MatrixBase_set(self, *args)

    def len(self) -> "unsigned int" :
        """len(_MatrixBase self) -> unsigned int"""
        return _sim3dlong._MatrixBase_len(self)

    def __iadd__(self, *args) -> "Nvector< Vector3< double >,3 > &" :
        """__iadd__(_MatrixBase self, _MatrixBase rhs) -> _MatrixBase"""
        return _sim3dlong._MatrixBase___iadd__(self, *args)

    def __isub__(self, *args) -> "Nvector< Vector3< double >,3 > &" :
        """__isub__(_MatrixBase self, _MatrixBase rhs) -> _MatrixBase"""
        return _sim3dlong._MatrixBase___isub__(self, *args)

    def __neg__(self) -> "Nvector< Vector3< double >,3 >" :
        """__neg__(_MatrixBase self) -> _MatrixBase"""
        return _sim3dlong._MatrixBase___neg__(self)

    def __add__(self, *args) -> "Nvector< Vector3< double >,3 >" :
        """__add__(_MatrixBase self, _MatrixBase rhs) -> _MatrixBase"""
        return _sim3dlong._MatrixBase___add__(self, *args)

    def __sub__(self, *args) -> "Nvector< Vector3< double >,3 >" :
        """__sub__(_MatrixBase self, _MatrixBase rhs) -> _MatrixBase"""
        return _sim3dlong._MatrixBase___sub__(self, *args)

    def begin(self) -> "Vector3< double > *" :
        """begin(_MatrixBase self) -> Vec"""
        return _sim3dlong._MatrixBase_begin(self)

    def end(self) -> "Vector3< double > *" :
        """end(_MatrixBase self) -> Vec"""
        return _sim3dlong._MatrixBase_end(self)

    __swig_destroy__ = _sim3dlong.delete__MatrixBase
    __del__ = lambda self : None;
    def __mul__(self, *args) -> "Nvector< Vector3< double >,3 >" :
        """__mul__(_MatrixBase self, double const rhs) -> _MatrixBase"""
        return _sim3dlong._MatrixBase___mul__(self, *args)

    def __div__(self, *args) -> "Nvector< Vector3< double >,3 >" :
        """__div__(_MatrixBase self, double const rhs) -> _MatrixBase"""
        return _sim3dlong._MatrixBase___div__(self, *args)

    def __truediv__(self, *args) -> "Nvector< Vector3< double >,3 >" :
        """__truediv__(_MatrixBase self, double const n) -> _MatrixBase"""
        return _sim3dlong._MatrixBase___truediv__(self, *args)

    def __getitem__(self, *args) -> "Vector3< double >" :
        """__getitem__(_MatrixBase self, unsigned int const n) -> Vec"""
        return _sim3dlong._MatrixBase___getitem__(self, *args)

    def __setitem__(self, *args) -> "void" :
        """__setitem__(_MatrixBase self, unsigned int const n, Vec val)"""
        return _sim3dlong._MatrixBase___setitem__(self, *args)

    def __len__(self) -> "unsigned int" :
        """__len__(_MatrixBase self) -> unsigned int"""
        return _sim3dlong._MatrixBase___len__(self)

    #~ def __setitem__(self, n, val):
        #~ return self.set(n, val)

    def __iter__(self):
        for i in range(len(self)):
            yield self.get(i)

    #~ def __len__(self):
        #~ return self.len()

_MatrixBase_swigregister = _sim3dlong._MatrixBase_swigregister
_MatrixBase_swigregister(_MatrixBase)

class Matr(_MatrixBase):
    """Proxy of C++ Matrix<(double)> class"""
    __swig_setmethods__ = {}
    for _s in [_MatrixBase]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Matr, name, value)
    __swig_getmethods__ = {}
    for _s in [_MatrixBase]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Matr, name)
    __repr__ = _swig_repr
    def dot(self, *args) -> "Vector3< double >" :
        """dot(Matr self, Vec v) -> Vec"""
        return _sim3dlong.Matr_dot(self, *args)

    def __mul__(self, *args) -> "Vector3< double >" :
        """__mul__(Matr self, Vec v) -> Vec"""
        return _sim3dlong.Matr___mul__(self, *args)

    def SymmetricInverse(self) -> "Matrix< double >" :
        """SymmetricInverse(Matr self) -> Matr"""
        return _sim3dlong.Matr_SymmetricInverse(self)

    def det(self) -> "double" :
        """det(Matr self) -> double"""
        return _sim3dlong.Matr_det(self)

    def __init__(self): 
        """__init__(Matrix<(double)> self) -> Matr"""
        this = _sim3dlong.new_Matr()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _sim3dlong.delete_Matr
    __del__ = lambda self : None;
Matr_swigregister = _sim3dlong.Matr_swigregister
Matr_swigregister(Matr)

class vecptrvector(_object):
    """Proxy of C++ std::vector<(p.Vector3<(double)>)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vecptrvector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vecptrvector, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" :
        """iterator(vecptrvector self) -> SwigPyIterator"""
        return _sim3dlong.vecptrvector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" :
        """__nonzero__(vecptrvector self) -> bool"""
        return _sim3dlong.vecptrvector___nonzero__(self)

    def __bool__(self) -> "bool" :
        """__bool__(vecptrvector self) -> bool"""
        return _sim3dlong.vecptrvector___bool__(self)

    def __len__(self) -> "std::vector< Vector3< double > * >::size_type" :
        """__len__(vecptrvector self) -> std::vector< Vector3< double > * >::size_type"""
        return _sim3dlong.vecptrvector___len__(self)

    def pop(self) -> "std::vector< Vector3< double > * >::value_type" :
        """pop(vecptrvector self) -> Vec"""
        return _sim3dlong.vecptrvector_pop(self)

    def __getslice__(self, *args) -> "std::vector< Vector3< double > *,std::allocator< Vector3< double > * > > *" :
        """__getslice__(vecptrvector self, std::vector< Vector3< double > * >::difference_type i, std::vector< Vector3< double > * >::difference_type j) -> vecptrvector"""
        return _sim3dlong.vecptrvector___getslice__(self, *args)

    def __setslice__(self, *args) -> "void" :
        """
        __setslice__(vecptrvector self, std::vector< Vector3< double > * >::difference_type i, std::vector< Vector3< double > * >::difference_type j, 
            vecptrvector v=std::vector< Vector3< double > *,std::allocator< Vector3< double > * > >())
        __setslice__(vecptrvector self, std::vector< Vector3< double > * >::difference_type i, std::vector< Vector3< double > * >::difference_type j)
        """
        return _sim3dlong.vecptrvector___setslice__(self, *args)

    def __delslice__(self, *args) -> "void" :
        """__delslice__(vecptrvector self, std::vector< Vector3< double > * >::difference_type i, std::vector< Vector3< double > * >::difference_type j)"""
        return _sim3dlong.vecptrvector___delslice__(self, *args)

    def __delitem__(self, *args) -> "void" :
        """
        __delitem__(vecptrvector self, std::vector< Vector3< double > * >::difference_type i)
        __delitem__(vecptrvector self, PySliceObject * slice)
        """
        return _sim3dlong.vecptrvector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< Vector3< double > * >::value_type" :
        """
        __getitem__(vecptrvector self, PySliceObject * slice) -> vecptrvector
        __getitem__(vecptrvector self, std::vector< Vector3< double > * >::difference_type i) -> Vec
        """
        return _sim3dlong.vecptrvector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void" :
        """
        __setitem__(vecptrvector self, PySliceObject * slice, vecptrvector v)
        __setitem__(vecptrvector self, PySliceObject * slice)
        __setitem__(vecptrvector self, std::vector< Vector3< double > * >::difference_type i, Vec x)
        """
        return _sim3dlong.vecptrvector___setitem__(self, *args)

    def append(self, *args) -> "void" :
        """append(vecptrvector self, Vec x)"""
        return _sim3dlong.vecptrvector_append(self, *args)

    def empty(self) -> "bool" :
        """empty(vecptrvector self) -> bool"""
        return _sim3dlong.vecptrvector_empty(self)

    def size(self) -> "std::vector< Vector3< double > * >::size_type" :
        """size(vecptrvector self) -> std::vector< Vector3< double > * >::size_type"""
        return _sim3dlong.vecptrvector_size(self)

    def clear(self) -> "void" :
        """clear(vecptrvector self)"""
        return _sim3dlong.vecptrvector_clear(self)

    def swap(self, *args) -> "void" :
        """swap(vecptrvector self, vecptrvector v)"""
        return _sim3dlong.vecptrvector_swap(self, *args)

    def get_allocator(self) -> "std::vector< Vector3< double > * >::allocator_type" :
        """get_allocator(vecptrvector self) -> std::vector< Vector3< double > * >::allocator_type"""
        return _sim3dlong.vecptrvector_get_allocator(self)

    def begin(self) -> "std::vector< Vector3< double > * >::iterator" :
        """begin(vecptrvector self) -> std::vector< Vector3< double > * >::iterator"""
        return _sim3dlong.vecptrvector_begin(self)

    def end(self) -> "std::vector< Vector3< double > * >::iterator" :
        """end(vecptrvector self) -> std::vector< Vector3< double > * >::iterator"""
        return _sim3dlong.vecptrvector_end(self)

    def rbegin(self) -> "std::vector< Vector3< double > * >::reverse_iterator" :
        """rbegin(vecptrvector self) -> std::vector< Vector3< double > * >::reverse_iterator"""
        return _sim3dlong.vecptrvector_rbegin(self)

    def rend(self) -> "std::vector< Vector3< double > * >::reverse_iterator" :
        """rend(vecptrvector self) -> std::vector< Vector3< double > * >::reverse_iterator"""
        return _sim3dlong.vecptrvector_rend(self)

    def pop_back(self) -> "void" :
        """pop_back(vecptrvector self)"""
        return _sim3dlong.vecptrvector_pop_back(self)

    def erase(self, *args) -> "std::vector< Vector3< double > * >::iterator" :
        """
        erase(vecptrvector self, std::vector< Vector3< double > * >::iterator pos) -> std::vector< Vector3< double > * >::iterator
        erase(vecptrvector self, std::vector< Vector3< double > * >::iterator first, std::vector< Vector3< double > * >::iterator last) -> std::vector< Vector3< double > * >::iterator
        """
        return _sim3dlong.vecptrvector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(p.Vector3<(double)>)> self) -> vecptrvector
        __init__(std::vector<(p.Vector3<(double)>)> self, vecptrvector arg2) -> vecptrvector
        __init__(std::vector<(p.Vector3<(double)>)> self, std::vector< Vector3< double > * >::size_type size) -> vecptrvector
        __init__(std::vector<(p.Vector3<(double)>)> self, std::vector< Vector3< double > * >::size_type size, Vec value) -> vecptrvector
        """
        this = _sim3dlong.new_vecptrvector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" :
        """push_back(vecptrvector self, Vec x)"""
        return _sim3dlong.vecptrvector_push_back(self, *args)

    def front(self) -> "std::vector< Vector3< double > * >::value_type" :
        """front(vecptrvector self) -> Vec"""
        return _sim3dlong.vecptrvector_front(self)

    def back(self) -> "std::vector< Vector3< double > * >::value_type" :
        """back(vecptrvector self) -> Vec"""
        return _sim3dlong.vecptrvector_back(self)

    def assign(self, *args) -> "void" :
        """assign(vecptrvector self, std::vector< Vector3< double > * >::size_type n, Vec x)"""
        return _sim3dlong.vecptrvector_assign(self, *args)

    def resize(self, *args) -> "void" :
        """
        resize(vecptrvector self, std::vector< Vector3< double > * >::size_type new_size)
        resize(vecptrvector self, std::vector< Vector3< double > * >::size_type new_size, Vec x)
        """
        return _sim3dlong.vecptrvector_resize(self, *args)

    def insert(self, *args) -> "void" :
        """
        insert(vecptrvector self, std::vector< Vector3< double > * >::iterator pos, Vec x) -> std::vector< Vector3< double > * >::iterator
        insert(vecptrvector self, std::vector< Vector3< double > * >::iterator pos, std::vector< Vector3< double > * >::size_type n, 
            Vec x)
        """
        return _sim3dlong.vecptrvector_insert(self, *args)

    def reserve(self, *args) -> "void" :
        """reserve(vecptrvector self, std::vector< Vector3< double > * >::size_type n)"""
        return _sim3dlong.vecptrvector_reserve(self, *args)

    def capacity(self) -> "std::vector< Vector3< double > * >::size_type" :
        """capacity(vecptrvector self) -> std::vector< Vector3< double > * >::size_type"""
        return _sim3dlong.vecptrvector_capacity(self)

    __swig_destroy__ = _sim3dlong.delete_vecptrvector
    __del__ = lambda self : None;
vecptrvector_swigregister = _sim3dlong.vecptrvector_swigregister
vecptrvector_swigregister(vecptrvector)

class vecvector(collections.MutableSequence):
    """Proxy of C++ std::vector<(Vector3<(double)>)> class"""
    __swig_setmethods__ = {}
    for _s in [collections.MutableSequence]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, vecvector, name, value)
    __swig_getmethods__ = {}
    for _s in [collections.MutableSequence]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, vecvector, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" :
        """iterator(vecvector self) -> SwigPyIterator"""
        return _sim3dlong.vecvector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" :
        """__nonzero__(vecvector self) -> bool"""
        return _sim3dlong.vecvector___nonzero__(self)

    def __bool__(self) -> "bool" :
        """__bool__(vecvector self) -> bool"""
        return _sim3dlong.vecvector___bool__(self)

    def __len__(self) -> "std::vector< Vector3< double > >::size_type" :
        """__len__(vecvector self) -> std::vector< Vector3< double > >::size_type"""
        return _sim3dlong.vecvector___len__(self)

    def pop(self) -> "std::vector< Vector3< double > >::value_type" :
        """pop(vecvector self) -> Vec"""
        return _sim3dlong.vecvector_pop(self)

    def __getslice__(self, *args) -> "std::vector< Vector3< double >,std::allocator< Vector3< double > > > *" :
        """__getslice__(vecvector self, std::vector< Vector3< double > >::difference_type i, std::vector< Vector3< double > >::difference_type j) -> vecvector"""
        return _sim3dlong.vecvector___getslice__(self, *args)

    def __setslice__(self, *args) -> "void" :
        """
        __setslice__(vecvector self, std::vector< Vector3< double > >::difference_type i, std::vector< Vector3< double > >::difference_type j, 
            vecvector v=std::vector< Vector3< double >,std::allocator< Vector3< double > > >())
        __setslice__(vecvector self, std::vector< Vector3< double > >::difference_type i, std::vector< Vector3< double > >::difference_type j)
        """
        return _sim3dlong.vecvector___setslice__(self, *args)

    def __delslice__(self, *args) -> "void" :
        """__delslice__(vecvector self, std::vector< Vector3< double > >::difference_type i, std::vector< Vector3< double > >::difference_type j)"""
        return _sim3dlong.vecvector___delslice__(self, *args)

    def __delitem__(self, *args) -> "void" :
        """
        __delitem__(vecvector self, std::vector< Vector3< double > >::difference_type i)
        __delitem__(vecvector self, PySliceObject * slice)
        """
        return _sim3dlong.vecvector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< Vector3< double > >::value_type const &" :
        """
        __getitem__(vecvector self, PySliceObject * slice) -> vecvector
        __getitem__(vecvector self, std::vector< Vector3< double > >::difference_type i) -> Vec
        """
        return _sim3dlong.vecvector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void" :
        """
        __setitem__(vecvector self, PySliceObject * slice, vecvector v)
        __setitem__(vecvector self, PySliceObject * slice)
        __setitem__(vecvector self, std::vector< Vector3< double > >::difference_type i, Vec x)
        """
        return _sim3dlong.vecvector___setitem__(self, *args)

    def append(self, *args) -> "void" :
        """append(vecvector self, Vec x)"""
        return _sim3dlong.vecvector_append(self, *args)

    def empty(self) -> "bool" :
        """empty(vecvector self) -> bool"""
        return _sim3dlong.vecvector_empty(self)

    def size(self) -> "std::vector< Vector3< double > >::size_type" :
        """size(vecvector self) -> std::vector< Vector3< double > >::size_type"""
        return _sim3dlong.vecvector_size(self)

    def clear(self) -> "void" :
        """clear(vecvector self)"""
        return _sim3dlong.vecvector_clear(self)

    def swap(self, *args) -> "void" :
        """swap(vecvector self, vecvector v)"""
        return _sim3dlong.vecvector_swap(self, *args)

    def get_allocator(self) -> "std::vector< Vector3< double > >::allocator_type" :
        """get_allocator(vecvector self) -> std::vector< Vector3< double > >::allocator_type"""
        return _sim3dlong.vecvector_get_allocator(self)

    def begin(self) -> "std::vector< Vector3< double > >::iterator" :
        """begin(vecvector self) -> std::vector< Vector3< double > >::iterator"""
        return _sim3dlong.vecvector_begin(self)

    def end(self) -> "std::vector< Vector3< double > >::iterator" :
        """end(vecvector self) -> std::vector< Vector3< double > >::iterator"""
        return _sim3dlong.vecvector_end(self)

    def rbegin(self) -> "std::vector< Vector3< double > >::reverse_iterator" :
        """rbegin(vecvector self) -> std::vector< Vector3< double > >::reverse_iterator"""
        return _sim3dlong.vecvector_rbegin(self)

    def rend(self) -> "std::vector< Vector3< double > >::reverse_iterator" :
        """rend(vecvector self) -> std::vector< Vector3< double > >::reverse_iterator"""
        return _sim3dlong.vecvector_rend(self)

    def pop_back(self) -> "void" :
        """pop_back(vecvector self)"""
        return _sim3dlong.vecvector_pop_back(self)

    def erase(self, *args) -> "std::vector< Vector3< double > >::iterator" :
        """
        erase(vecvector self, std::vector< Vector3< double > >::iterator pos) -> std::vector< Vector3< double > >::iterator
        erase(vecvector self, std::vector< Vector3< double > >::iterator first, std::vector< Vector3< double > >::iterator last) -> std::vector< Vector3< double > >::iterator
        """
        return _sim3dlong.vecvector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(Vector3<(double)>)> self) -> vecvector
        __init__(std::vector<(Vector3<(double)>)> self, vecvector arg2) -> vecvector
        __init__(std::vector<(Vector3<(double)>)> self, std::vector< Vector3< double > >::size_type size) -> vecvector
        __init__(std::vector<(Vector3<(double)>)> self, std::vector< Vector3< double > >::size_type size, Vec value) -> vecvector
        """
        this = _sim3dlong.new_vecvector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" :
        """push_back(vecvector self, Vec x)"""
        return _sim3dlong.vecvector_push_back(self, *args)

    def front(self) -> "std::vector< Vector3< double > >::value_type const &" :
        """front(vecvector self) -> Vec"""
        return _sim3dlong.vecvector_front(self)

    def back(self) -> "std::vector< Vector3< double > >::value_type const &" :
        """back(vecvector self) -> Vec"""
        return _sim3dlong.vecvector_back(self)

    def assign(self, *args) -> "void" :
        """assign(vecvector self, std::vector< Vector3< double > >::size_type n, Vec x)"""
        return _sim3dlong.vecvector_assign(self, *args)

    def resize(self, *args) -> "void" :
        """
        resize(vecvector self, std::vector< Vector3< double > >::size_type new_size)
        resize(vecvector self, std::vector< Vector3< double > >::size_type new_size, Vec x)
        """
        return _sim3dlong.vecvector_resize(self, *args)

    def insert(self, *args) -> "void" :
        """
        insert(vecvector self, std::vector< Vector3< double > >::iterator pos, Vec x) -> std::vector< Vector3< double > >::iterator
        insert(vecvector self, std::vector< Vector3< double > >::iterator pos, std::vector< Vector3< double > >::size_type n, 
            Vec x)
        """
        return _sim3dlong.vecvector_insert(self, *args)

    def reserve(self, *args) -> "void" :
        """reserve(vecvector self, std::vector< Vector3< double > >::size_type n)"""
        return _sim3dlong.vecvector_reserve(self, *args)

    def capacity(self) -> "std::vector< Vector3< double > >::size_type" :
        """capacity(vecvector self) -> std::vector< Vector3< double > >::size_type"""
        return _sim3dlong.vecvector_capacity(self)

    __swig_destroy__ = _sim3dlong.delete_vecvector
    __del__ = lambda self : None;
vecvector_swigregister = _sim3dlong.vecvector_swigregister
vecvector_swigregister(vecvector)

class vecptrvectorL(_object):
    """Proxy of C++ std::vector<(p.Vector3<(long double)>)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vecptrvectorL, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vecptrvectorL, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" :
        """iterator(vecptrvectorL self) -> SwigPyIterator"""
        return _sim3dlong.vecptrvectorL_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" :
        """__nonzero__(vecptrvectorL self) -> bool"""
        return _sim3dlong.vecptrvectorL___nonzero__(self)

    def __bool__(self) -> "bool" :
        """__bool__(vecptrvectorL self) -> bool"""
        return _sim3dlong.vecptrvectorL___bool__(self)

    def __len__(self) -> "std::vector< Vector3< long double > * >::size_type" :
        """__len__(vecptrvectorL self) -> std::vector< Vector3< long double > * >::size_type"""
        return _sim3dlong.vecptrvectorL___len__(self)

    def pop(self) -> "std::vector< Vector3< long double > * >::value_type" :
        """pop(vecptrvectorL self) -> VecL"""
        return _sim3dlong.vecptrvectorL_pop(self)

    def __getslice__(self, *args) -> "std::vector< Vector3< long double > *,std::allocator< Vector3< long double > * > > *" :
        """__getslice__(vecptrvectorL self, std::vector< Vector3< long double > * >::difference_type i, std::vector< Vector3< long double > * >::difference_type j) -> vecptrvectorL"""
        return _sim3dlong.vecptrvectorL___getslice__(self, *args)

    def __setslice__(self, *args) -> "void" :
        """
        __setslice__(vecptrvectorL self, std::vector< Vector3< long double > * >::difference_type i, std::vector< Vector3< long double > * >::difference_type j, 
            vecptrvectorL v=std::vector< Vector3< long double > *,std::allocator< Vector3< long double > * > >())
        __setslice__(vecptrvectorL self, std::vector< Vector3< long double > * >::difference_type i, std::vector< Vector3< long double > * >::difference_type j)
        """
        return _sim3dlong.vecptrvectorL___setslice__(self, *args)

    def __delslice__(self, *args) -> "void" :
        """__delslice__(vecptrvectorL self, std::vector< Vector3< long double > * >::difference_type i, std::vector< Vector3< long double > * >::difference_type j)"""
        return _sim3dlong.vecptrvectorL___delslice__(self, *args)

    def __delitem__(self, *args) -> "void" :
        """
        __delitem__(vecptrvectorL self, std::vector< Vector3< long double > * >::difference_type i)
        __delitem__(vecptrvectorL self, PySliceObject * slice)
        """
        return _sim3dlong.vecptrvectorL___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< Vector3< long double > * >::value_type" :
        """
        __getitem__(vecptrvectorL self, PySliceObject * slice) -> vecptrvectorL
        __getitem__(vecptrvectorL self, std::vector< Vector3< long double > * >::difference_type i) -> VecL
        """
        return _sim3dlong.vecptrvectorL___getitem__(self, *args)

    def __setitem__(self, *args) -> "void" :
        """
        __setitem__(vecptrvectorL self, PySliceObject * slice, vecptrvectorL v)
        __setitem__(vecptrvectorL self, PySliceObject * slice)
        __setitem__(vecptrvectorL self, std::vector< Vector3< long double > * >::difference_type i, VecL x)
        """
        return _sim3dlong.vecptrvectorL___setitem__(self, *args)

    def append(self, *args) -> "void" :
        """append(vecptrvectorL self, VecL x)"""
        return _sim3dlong.vecptrvectorL_append(self, *args)

    def empty(self) -> "bool" :
        """empty(vecptrvectorL self) -> bool"""
        return _sim3dlong.vecptrvectorL_empty(self)

    def size(self) -> "std::vector< Vector3< long double > * >::size_type" :
        """size(vecptrvectorL self) -> std::vector< Vector3< long double > * >::size_type"""
        return _sim3dlong.vecptrvectorL_size(self)

    def clear(self) -> "void" :
        """clear(vecptrvectorL self)"""
        return _sim3dlong.vecptrvectorL_clear(self)

    def swap(self, *args) -> "void" :
        """swap(vecptrvectorL self, vecptrvectorL v)"""
        return _sim3dlong.vecptrvectorL_swap(self, *args)

    def get_allocator(self) -> "std::vector< Vector3< long double > * >::allocator_type" :
        """get_allocator(vecptrvectorL self) -> std::vector< Vector3< long double > * >::allocator_type"""
        return _sim3dlong.vecptrvectorL_get_allocator(self)

    def begin(self) -> "std::vector< Vector3< long double > * >::iterator" :
        """begin(vecptrvectorL self) -> std::vector< Vector3< long double > * >::iterator"""
        return _sim3dlong.vecptrvectorL_begin(self)

    def end(self) -> "std::vector< Vector3< long double > * >::iterator" :
        """end(vecptrvectorL self) -> std::vector< Vector3< long double > * >::iterator"""
        return _sim3dlong.vecptrvectorL_end(self)

    def rbegin(self) -> "std::vector< Vector3< long double > * >::reverse_iterator" :
        """rbegin(vecptrvectorL self) -> std::vector< Vector3< long double > * >::reverse_iterator"""
        return _sim3dlong.vecptrvectorL_rbegin(self)

    def rend(self) -> "std::vector< Vector3< long double > * >::reverse_iterator" :
        """rend(vecptrvectorL self) -> std::vector< Vector3< long double > * >::reverse_iterator"""
        return _sim3dlong.vecptrvectorL_rend(self)

    def pop_back(self) -> "void" :
        """pop_back(vecptrvectorL self)"""
        return _sim3dlong.vecptrvectorL_pop_back(self)

    def erase(self, *args) -> "std::vector< Vector3< long double > * >::iterator" :
        """
        erase(vecptrvectorL self, std::vector< Vector3< long double > * >::iterator pos) -> std::vector< Vector3< long double > * >::iterator
        erase(vecptrvectorL self, std::vector< Vector3< long double > * >::iterator first, std::vector< Vector3< long double > * >::iterator last) -> std::vector< Vector3< long double > * >::iterator
        """
        return _sim3dlong.vecptrvectorL_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(p.Vector3<(long double)>)> self) -> vecptrvectorL
        __init__(std::vector<(p.Vector3<(long double)>)> self, vecptrvectorL arg2) -> vecptrvectorL
        __init__(std::vector<(p.Vector3<(long double)>)> self, std::vector< Vector3< long double > * >::size_type size) -> vecptrvectorL
        __init__(std::vector<(p.Vector3<(long double)>)> self, std::vector< Vector3< long double > * >::size_type size, VecL value) -> vecptrvectorL
        """
        this = _sim3dlong.new_vecptrvectorL(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" :
        """push_back(vecptrvectorL self, VecL x)"""
        return _sim3dlong.vecptrvectorL_push_back(self, *args)

    def front(self) -> "std::vector< Vector3< long double > * >::value_type" :
        """front(vecptrvectorL self) -> VecL"""
        return _sim3dlong.vecptrvectorL_front(self)

    def back(self) -> "std::vector< Vector3< long double > * >::value_type" :
        """back(vecptrvectorL self) -> VecL"""
        return _sim3dlong.vecptrvectorL_back(self)

    def assign(self, *args) -> "void" :
        """assign(vecptrvectorL self, std::vector< Vector3< long double > * >::size_type n, VecL x)"""
        return _sim3dlong.vecptrvectorL_assign(self, *args)

    def resize(self, *args) -> "void" :
        """
        resize(vecptrvectorL self, std::vector< Vector3< long double > * >::size_type new_size)
        resize(vecptrvectorL self, std::vector< Vector3< long double > * >::size_type new_size, VecL x)
        """
        return _sim3dlong.vecptrvectorL_resize(self, *args)

    def insert(self, *args) -> "void" :
        """
        insert(vecptrvectorL self, std::vector< Vector3< long double > * >::iterator pos, VecL x) -> std::vector< Vector3< long double > * >::iterator
        insert(vecptrvectorL self, std::vector< Vector3< long double > * >::iterator pos, std::vector< Vector3< long double > * >::size_type n, 
            VecL x)
        """
        return _sim3dlong.vecptrvectorL_insert(self, *args)

    def reserve(self, *args) -> "void" :
        """reserve(vecptrvectorL self, std::vector< Vector3< long double > * >::size_type n)"""
        return _sim3dlong.vecptrvectorL_reserve(self, *args)

    def capacity(self) -> "std::vector< Vector3< long double > * >::size_type" :
        """capacity(vecptrvectorL self) -> std::vector< Vector3< long double > * >::size_type"""
        return _sim3dlong.vecptrvectorL_capacity(self)

    __swig_destroy__ = _sim3dlong.delete_vecptrvectorL
    __del__ = lambda self : None;
vecptrvectorL_swigregister = _sim3dlong.vecptrvectorL_swigregister
vecptrvectorL_swigregister(vecptrvectorL)

class vecvectorL(collections.MutableSequence):
    """Proxy of C++ std::vector<(Vector3<(long double)>)> class"""
    __swig_setmethods__ = {}
    for _s in [collections.MutableSequence]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, vecvectorL, name, value)
    __swig_getmethods__ = {}
    for _s in [collections.MutableSequence]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, vecvectorL, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" :
        """iterator(vecvectorL self) -> SwigPyIterator"""
        return _sim3dlong.vecvectorL_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" :
        """__nonzero__(vecvectorL self) -> bool"""
        return _sim3dlong.vecvectorL___nonzero__(self)

    def __bool__(self) -> "bool" :
        """__bool__(vecvectorL self) -> bool"""
        return _sim3dlong.vecvectorL___bool__(self)

    def __len__(self) -> "std::vector< Vector3< long double > >::size_type" :
        """__len__(vecvectorL self) -> std::vector< Vector3< long double > >::size_type"""
        return _sim3dlong.vecvectorL___len__(self)

    def pop(self) -> "std::vector< Vector3< long double > >::value_type" :
        """pop(vecvectorL self) -> VecL"""
        return _sim3dlong.vecvectorL_pop(self)

    def __getslice__(self, *args) -> "std::vector< Vector3< long double >,std::allocator< Vector3< long double > > > *" :
        """__getslice__(vecvectorL self, std::vector< Vector3< long double > >::difference_type i, std::vector< Vector3< long double > >::difference_type j) -> vecvectorL"""
        return _sim3dlong.vecvectorL___getslice__(self, *args)

    def __setslice__(self, *args) -> "void" :
        """
        __setslice__(vecvectorL self, std::vector< Vector3< long double > >::difference_type i, std::vector< Vector3< long double > >::difference_type j, 
            vecvectorL v=std::vector< Vector3< long double >,std::allocator< Vector3< long double > > >())
        __setslice__(vecvectorL self, std::vector< Vector3< long double > >::difference_type i, std::vector< Vector3< long double > >::difference_type j)
        """
        return _sim3dlong.vecvectorL___setslice__(self, *args)

    def __delslice__(self, *args) -> "void" :
        """__delslice__(vecvectorL self, std::vector< Vector3< long double > >::difference_type i, std::vector< Vector3< long double > >::difference_type j)"""
        return _sim3dlong.vecvectorL___delslice__(self, *args)

    def __delitem__(self, *args) -> "void" :
        """
        __delitem__(vecvectorL self, std::vector< Vector3< long double > >::difference_type i)
        __delitem__(vecvectorL self, PySliceObject * slice)
        """
        return _sim3dlong.vecvectorL___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< Vector3< long double > >::value_type const &" :
        """
        __getitem__(vecvectorL self, PySliceObject * slice) -> vecvectorL
        __getitem__(vecvectorL self, std::vector< Vector3< long double > >::difference_type i) -> VecL
        """
        return _sim3dlong.vecvectorL___getitem__(self, *args)

    def __setitem__(self, *args) -> "void" :
        """
        __setitem__(vecvectorL self, PySliceObject * slice, vecvectorL v)
        __setitem__(vecvectorL self, PySliceObject * slice)
        __setitem__(vecvectorL self, std::vector< Vector3< long double > >::difference_type i, VecL x)
        """
        return _sim3dlong.vecvectorL___setitem__(self, *args)

    def append(self, *args) -> "void" :
        """append(vecvectorL self, VecL x)"""
        return _sim3dlong.vecvectorL_append(self, *args)

    def empty(self) -> "bool" :
        """empty(vecvectorL self) -> bool"""
        return _sim3dlong.vecvectorL_empty(self)

    def size(self) -> "std::vector< Vector3< long double > >::size_type" :
        """size(vecvectorL self) -> std::vector< Vector3< long double > >::size_type"""
        return _sim3dlong.vecvectorL_size(self)

    def clear(self) -> "void" :
        """clear(vecvectorL self)"""
        return _sim3dlong.vecvectorL_clear(self)

    def swap(self, *args) -> "void" :
        """swap(vecvectorL self, vecvectorL v)"""
        return _sim3dlong.vecvectorL_swap(self, *args)

    def get_allocator(self) -> "std::vector< Vector3< long double > >::allocator_type" :
        """get_allocator(vecvectorL self) -> std::vector< Vector3< long double > >::allocator_type"""
        return _sim3dlong.vecvectorL_get_allocator(self)

    def begin(self) -> "std::vector< Vector3< long double > >::iterator" :
        """begin(vecvectorL self) -> std::vector< Vector3< long double > >::iterator"""
        return _sim3dlong.vecvectorL_begin(self)

    def end(self) -> "std::vector< Vector3< long double > >::iterator" :
        """end(vecvectorL self) -> std::vector< Vector3< long double > >::iterator"""
        return _sim3dlong.vecvectorL_end(self)

    def rbegin(self) -> "std::vector< Vector3< long double > >::reverse_iterator" :
        """rbegin(vecvectorL self) -> std::vector< Vector3< long double > >::reverse_iterator"""
        return _sim3dlong.vecvectorL_rbegin(self)

    def rend(self) -> "std::vector< Vector3< long double > >::reverse_iterator" :
        """rend(vecvectorL self) -> std::vector< Vector3< long double > >::reverse_iterator"""
        return _sim3dlong.vecvectorL_rend(self)

    def pop_back(self) -> "void" :
        """pop_back(vecvectorL self)"""
        return _sim3dlong.vecvectorL_pop_back(self)

    def erase(self, *args) -> "std::vector< Vector3< long double > >::iterator" :
        """
        erase(vecvectorL self, std::vector< Vector3< long double > >::iterator pos) -> std::vector< Vector3< long double > >::iterator
        erase(vecvectorL self, std::vector< Vector3< long double > >::iterator first, std::vector< Vector3< long double > >::iterator last) -> std::vector< Vector3< long double > >::iterator
        """
        return _sim3dlong.vecvectorL_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(Vector3<(long double)>)> self) -> vecvectorL
        __init__(std::vector<(Vector3<(long double)>)> self, vecvectorL arg2) -> vecvectorL
        __init__(std::vector<(Vector3<(long double)>)> self, std::vector< Vector3< long double > >::size_type size) -> vecvectorL
        __init__(std::vector<(Vector3<(long double)>)> self, std::vector< Vector3< long double > >::size_type size, VecL value) -> vecvectorL
        """
        this = _sim3dlong.new_vecvectorL(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" :
        """push_back(vecvectorL self, VecL x)"""
        return _sim3dlong.vecvectorL_push_back(self, *args)

    def front(self) -> "std::vector< Vector3< long double > >::value_type const &" :
        """front(vecvectorL self) -> VecL"""
        return _sim3dlong.vecvectorL_front(self)

    def back(self) -> "std::vector< Vector3< long double > >::value_type const &" :
        """back(vecvectorL self) -> VecL"""
        return _sim3dlong.vecvectorL_back(self)

    def assign(self, *args) -> "void" :
        """assign(vecvectorL self, std::vector< Vector3< long double > >::size_type n, VecL x)"""
        return _sim3dlong.vecvectorL_assign(self, *args)

    def resize(self, *args) -> "void" :
        """
        resize(vecvectorL self, std::vector< Vector3< long double > >::size_type new_size)
        resize(vecvectorL self, std::vector< Vector3< long double > >::size_type new_size, VecL x)
        """
        return _sim3dlong.vecvectorL_resize(self, *args)

    def insert(self, *args) -> "void" :
        """
        insert(vecvectorL self, std::vector< Vector3< long double > >::iterator pos, VecL x) -> std::vector< Vector3< long double > >::iterator
        insert(vecvectorL self, std::vector< Vector3< long double > >::iterator pos, std::vector< Vector3< long double > >::size_type n, 
            VecL x)
        """
        return _sim3dlong.vecvectorL_insert(self, *args)

    def reserve(self, *args) -> "void" :
        """reserve(vecvectorL self, std::vector< Vector3< long double > >::size_type n)"""
        return _sim3dlong.vecvectorL_reserve(self, *args)

    def capacity(self) -> "std::vector< Vector3< long double > >::size_type" :
        """capacity(vecvectorL self) -> std::vector< Vector3< long double > >::size_type"""
        return _sim3dlong.vecvectorL_capacity(self)

    __swig_destroy__ = _sim3dlong.delete_vecvectorL
    __del__ = lambda self : None;
vecvectorL_swigregister = _sim3dlong.vecvectorL_swigregister
vecvectorL_swigregister(vecvectorL)

class Pair(_Nvector2):
    """Proxy of C++ Numvector<(double,2)> class"""
    __swig_setmethods__ = {}
    for _s in [_Nvector2]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Pair, name, value)
    __swig_getmethods__ = {}
    for _s in [_Nvector2]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Pair, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(Numvector<(double,2)> self) -> Pair
        __init__(Numvector<(double,2)> self, _Nvector2 rhs) -> Pair
        __init__(Numvector<(double,2)> self, double const [2] rhs) -> Pair
        """
        this = _sim3dlong.new_Pair(*args)
        try: self.this.append(this)
        except: self.this = this
    def dot(self, *args) -> "double" :
        """dot(Pair self, _Numvector2 other) -> double"""
        return _sim3dlong.Pair_dot(self, *args)

    def sq(self) -> "double" :
        """sq(Pair self) -> double"""
        return _sim3dlong.Pair_sq(self)

    def mag(self) -> "double" :
        """mag(Pair self) -> double"""
        return _sim3dlong.Pair_mag(self)

    def distance(self, *args) -> "double" :
        """distance(Pair self, _Numvector2 rhs) -> double"""
        return _sim3dlong.Pair_distance(self, *args)

    def perpto(self, *args) -> "Numvector< double,2 >" :
        """perpto(Pair self, _Numvector2 other) -> _Numvector2"""
        return _sim3dlong.Pair_perpto(self, *args)

    def normalize(self) -> "void" :
        """normalize(Pair self)"""
        return _sim3dlong.Pair_normalize(self)

    def norm(self) -> "Numvector< double,2 >" :
        """norm(Pair self) -> _Numvector2"""
        return _sim3dlong.Pair_norm(self)

    __swig_destroy__ = _sim3dlong.delete_Pair
    __del__ = lambda self : None;
Pair_swigregister = _sim3dlong.Pair_swigregister
Pair_swigregister(Pair)

class VecPair(_object):
    """Proxy of C++ Nvector<(Vec,2)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VecPair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VecPair, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(Nvector<(Vec,2)> self) -> VecPair
        __init__(Nvector<(Vec,2)> self, VecPair rhs) -> VecPair
        __init__(Nvector<(Vec,2)> self, VecL locs) -> VecPair
        """
        this = _sim3dlong.new_VecPair(*args)
        try: self.this.append(this)
        except: self.this = this
    def get(self, *args) -> "Vec const &" :
        """get(VecPair self, unsigned int const n) -> VecL"""
        return _sim3dlong.VecPair_get(self, *args)

    def set(self, *args) -> "void" :
        """set(VecPair self, unsigned int const n, VecL a)"""
        return _sim3dlong.VecPair_set(self, *args)

    def len(self) -> "unsigned int" :
        """len(VecPair self) -> unsigned int"""
        return _sim3dlong.VecPair_len(self)

    def __iadd__(self, *args) -> "Nvector< Vec,2 > &" :
        """__iadd__(VecPair self, VecPair rhs) -> VecPair"""
        return _sim3dlong.VecPair___iadd__(self, *args)

    def __isub__(self, *args) -> "Nvector< Vec,2 > &" :
        """__isub__(VecPair self, VecPair rhs) -> VecPair"""
        return _sim3dlong.VecPair___isub__(self, *args)

    def __neg__(self) -> "Nvector< Vec,2 >" :
        """__neg__(VecPair self) -> VecPair"""
        return _sim3dlong.VecPair___neg__(self)

    def __add__(self, *args) -> "Nvector< Vec,2 >" :
        """__add__(VecPair self, VecPair rhs) -> VecPair"""
        return _sim3dlong.VecPair___add__(self, *args)

    def __sub__(self, *args) -> "Nvector< Vec,2 >" :
        """__sub__(VecPair self, VecPair rhs) -> VecPair"""
        return _sim3dlong.VecPair___sub__(self, *args)

    def begin(self) -> "Vec *" :
        """begin(VecPair self) -> VecL"""
        return _sim3dlong.VecPair_begin(self)

    def end(self) -> "Vec *" :
        """end(VecPair self) -> VecL"""
        return _sim3dlong.VecPair_end(self)

    __swig_destroy__ = _sim3dlong.delete_VecPair
    __del__ = lambda self : None;
    def __mul__(self, *args) -> "Nvector< Vec,2 >" :
        """__mul__(VecPair self, double const rhs) -> VecPair"""
        return _sim3dlong.VecPair___mul__(self, *args)

    def __div__(self, *args) -> "Nvector< Vec,2 >" :
        """__div__(VecPair self, double const rhs) -> VecPair"""
        return _sim3dlong.VecPair___div__(self, *args)

    def __truediv__(self, *args) -> "Nvector< Vec,2 >" :
        """__truediv__(VecPair self, double const n) -> VecPair"""
        return _sim3dlong.VecPair___truediv__(self, *args)

    def __getitem__(self, *args) -> "Vec" :
        """__getitem__(VecPair self, unsigned int const n) -> VecL"""
        return _sim3dlong.VecPair___getitem__(self, *args)

    def __setitem__(self, *args) -> "void" :
        """__setitem__(VecPair self, unsigned int const n, VecL val)"""
        return _sim3dlong.VecPair___setitem__(self, *args)

    def __len__(self) -> "unsigned int" :
        """__len__(VecPair self) -> unsigned int"""
        return _sim3dlong.VecPair___len__(self)

    #~ def __setitem__(self, n, val):
        #~ return self.set(n, val)

    def __iter__(self):
        for i in range(len(self)):
            yield self.get(i)

    #~ def __len__(self):
        #~ return self.len()

VecPair_swigregister = _sim3dlong.VecPair_swigregister
VecPair_swigregister(VecPair)

class _atomarray2(_object):
    """Proxy of C++ array<(p.atom,2)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _atomarray2, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _atomarray2, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(array<(p.atom,2)> self) -> _atomarray2
        __init__(array<(p.atom,2)> self, _atomarray2 rhs) -> _atomarray2
        __init__(array<(p.atom,2)> self, atom *const [2] locs) -> _atomarray2
        """
        this = _sim3dlong.new__atomarray2(*args)
        try: self.this.append(this)
        except: self.this = this
    def get(self, *args) -> "atom *const &" :
        """get(_atomarray2 self, unsigned int const n) -> atom"""
        return _sim3dlong._atomarray2_get(self, *args)

    def set(self, *args) -> "void" :
        """set(_atomarray2 self, unsigned int const n, atom a)"""
        return _sim3dlong._atomarray2_set(self, *args)

    def len(self) -> "unsigned int" :
        """len(_atomarray2 self) -> unsigned int"""
        return _sim3dlong._atomarray2_len(self)

    def begin(self) -> "atom **" :
        """begin(_atomarray2 self) -> atom **"""
        return _sim3dlong._atomarray2_begin(self)

    def end(self) -> "atom **" :
        """end(_atomarray2 self) -> atom **"""
        return _sim3dlong._atomarray2_end(self)

    __swig_destroy__ = _sim3dlong.delete__atomarray2
    __del__ = lambda self : None;
_atomarray2_swigregister = _sim3dlong._atomarray2_swigregister
_atomarray2_swigregister(_atomarray2)

class _idarray2(_object):
    """Proxy of C++ array<(atomid,2)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _idarray2, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _idarray2, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(array<(atomid,2)> self) -> _idarray2
        __init__(array<(atomid,2)> self, _idarray2 rhs) -> _idarray2
        __init__(array<(atomid,2)> self, atomid locs) -> _idarray2
        """
        this = _sim3dlong.new__idarray2(*args)
        try: self.this.append(this)
        except: self.this = this
    def get(self, *args) -> "atomid const &" :
        """get(_idarray2 self, unsigned int const n) -> atomid"""
        return _sim3dlong._idarray2_get(self, *args)

    def set(self, *args) -> "void" :
        """set(_idarray2 self, unsigned int const n, atomid a)"""
        return _sim3dlong._idarray2_set(self, *args)

    def len(self) -> "unsigned int" :
        """len(_idarray2 self) -> unsigned int"""
        return _sim3dlong._idarray2_len(self)

    def begin(self) -> "atomid *" :
        """begin(_idarray2 self) -> atomid"""
        return _sim3dlong._idarray2_begin(self)

    def end(self) -> "atomid *" :
        """end(_idarray2 self) -> atomid"""
        return _sim3dlong._idarray2_end(self)

    __swig_destroy__ = _sim3dlong.delete__idarray2
    __del__ = lambda self : None;
_idarray2_swigregister = _sim3dlong._idarray2_swigregister
_idarray2_swigregister(_idarray2)

class _atomarray3(_object):
    """Proxy of C++ array<(p.atom,3)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _atomarray3, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _atomarray3, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(array<(p.atom,3)> self) -> _atomarray3
        __init__(array<(p.atom,3)> self, _atomarray3 rhs) -> _atomarray3
        __init__(array<(p.atom,3)> self, atom *const [3] locs) -> _atomarray3
        """
        this = _sim3dlong.new__atomarray3(*args)
        try: self.this.append(this)
        except: self.this = this
    def get(self, *args) -> "atom *const &" :
        """get(_atomarray3 self, unsigned int const n) -> atom"""
        return _sim3dlong._atomarray3_get(self, *args)

    def set(self, *args) -> "void" :
        """set(_atomarray3 self, unsigned int const n, atom a)"""
        return _sim3dlong._atomarray3_set(self, *args)

    def len(self) -> "unsigned int" :
        """len(_atomarray3 self) -> unsigned int"""
        return _sim3dlong._atomarray3_len(self)

    def begin(self) -> "atom **" :
        """begin(_atomarray3 self) -> atom **"""
        return _sim3dlong._atomarray3_begin(self)

    def end(self) -> "atom **" :
        """end(_atomarray3 self) -> atom **"""
        return _sim3dlong._atomarray3_end(self)

    __swig_destroy__ = _sim3dlong.delete__atomarray3
    __del__ = lambda self : None;
_atomarray3_swigregister = _sim3dlong._atomarray3_swigregister
_atomarray3_swigregister(_atomarray3)

class _atomarray4(_object):
    """Proxy of C++ array<(p.atom,4)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _atomarray4, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _atomarray4, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(array<(p.atom,4)> self) -> _atomarray4
        __init__(array<(p.atom,4)> self, _atomarray4 rhs) -> _atomarray4
        __init__(array<(p.atom,4)> self, atom *const [4] locs) -> _atomarray4
        """
        this = _sim3dlong.new__atomarray4(*args)
        try: self.this.append(this)
        except: self.this = this
    def get(self, *args) -> "atom *const &" :
        """get(_atomarray4 self, unsigned int const n) -> atom"""
        return _sim3dlong._atomarray4_get(self, *args)

    def set(self, *args) -> "void" :
        """set(_atomarray4 self, unsigned int const n, atom a)"""
        return _sim3dlong._atomarray4_set(self, *args)

    def len(self) -> "unsigned int" :
        """len(_atomarray4 self) -> unsigned int"""
        return _sim3dlong._atomarray4_len(self)

    def begin(self) -> "atom **" :
        """begin(_atomarray4 self) -> atom **"""
        return _sim3dlong._atomarray4_begin(self)

    def end(self) -> "atom **" :
        """end(_atomarray4 self) -> atom **"""
        return _sim3dlong._atomarray4_end(self)

    __swig_destroy__ = _sim3dlong.delete__atomarray4
    __del__ = lambda self : None;
_atomarray4_swigregister = _sim3dlong._atomarray4_swigregister
_atomarray4_swigregister(_atomarray4)

class fvector(collections.MutableSequence):
    """Proxy of C++ std::vector<(float)> class"""
    __swig_setmethods__ = {}
    for _s in [collections.MutableSequence]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, fvector, name, value)
    __swig_getmethods__ = {}
    for _s in [collections.MutableSequence]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, fvector, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" :
        """iterator(fvector self) -> SwigPyIterator"""
        return _sim3dlong.fvector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" :
        """__nonzero__(fvector self) -> bool"""
        return _sim3dlong.fvector___nonzero__(self)

    def __bool__(self) -> "bool" :
        """__bool__(fvector self) -> bool"""
        return _sim3dlong.fvector___bool__(self)

    def __len__(self) -> "std::vector< float >::size_type" :
        """__len__(fvector self) -> std::vector< float >::size_type"""
        return _sim3dlong.fvector___len__(self)

    def pop(self) -> "std::vector< float >::value_type" :
        """pop(fvector self) -> std::vector< float >::value_type"""
        return _sim3dlong.fvector_pop(self)

    def __getslice__(self, *args) -> "std::vector< float,std::allocator< float > > *" :
        """__getslice__(fvector self, std::vector< float >::difference_type i, std::vector< float >::difference_type j) -> fvector"""
        return _sim3dlong.fvector___getslice__(self, *args)

    def __setslice__(self, *args) -> "void" :
        """
        __setslice__(fvector self, std::vector< float >::difference_type i, std::vector< float >::difference_type j, 
            fvector v=std::vector< float,std::allocator< float > >())
        __setslice__(fvector self, std::vector< float >::difference_type i, std::vector< float >::difference_type j)
        """
        return _sim3dlong.fvector___setslice__(self, *args)

    def __delslice__(self, *args) -> "void" :
        """__delslice__(fvector self, std::vector< float >::difference_type i, std::vector< float >::difference_type j)"""
        return _sim3dlong.fvector___delslice__(self, *args)

    def __delitem__(self, *args) -> "void" :
        """
        __delitem__(fvector self, std::vector< float >::difference_type i)
        __delitem__(fvector self, PySliceObject * slice)
        """
        return _sim3dlong.fvector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< float >::value_type const &" :
        """
        __getitem__(fvector self, PySliceObject * slice) -> fvector
        __getitem__(fvector self, std::vector< float >::difference_type i) -> std::vector< float >::value_type const &
        """
        return _sim3dlong.fvector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void" :
        """
        __setitem__(fvector self, PySliceObject * slice, fvector v)
        __setitem__(fvector self, PySliceObject * slice)
        __setitem__(fvector self, std::vector< float >::difference_type i, std::vector< float >::value_type const & x)
        """
        return _sim3dlong.fvector___setitem__(self, *args)

    def append(self, *args) -> "void" :
        """append(fvector self, std::vector< float >::value_type const & x)"""
        return _sim3dlong.fvector_append(self, *args)

    def empty(self) -> "bool" :
        """empty(fvector self) -> bool"""
        return _sim3dlong.fvector_empty(self)

    def size(self) -> "std::vector< float >::size_type" :
        """size(fvector self) -> std::vector< float >::size_type"""
        return _sim3dlong.fvector_size(self)

    def clear(self) -> "void" :
        """clear(fvector self)"""
        return _sim3dlong.fvector_clear(self)

    def swap(self, *args) -> "void" :
        """swap(fvector self, fvector v)"""
        return _sim3dlong.fvector_swap(self, *args)

    def get_allocator(self) -> "std::vector< float >::allocator_type" :
        """get_allocator(fvector self) -> std::vector< float >::allocator_type"""
        return _sim3dlong.fvector_get_allocator(self)

    def begin(self) -> "std::vector< float >::iterator" :
        """begin(fvector self) -> std::vector< float >::iterator"""
        return _sim3dlong.fvector_begin(self)

    def end(self) -> "std::vector< float >::iterator" :
        """end(fvector self) -> std::vector< float >::iterator"""
        return _sim3dlong.fvector_end(self)

    def rbegin(self) -> "std::vector< float >::reverse_iterator" :
        """rbegin(fvector self) -> std::vector< float >::reverse_iterator"""
        return _sim3dlong.fvector_rbegin(self)

    def rend(self) -> "std::vector< float >::reverse_iterator" :
        """rend(fvector self) -> std::vector< float >::reverse_iterator"""
        return _sim3dlong.fvector_rend(self)

    def pop_back(self) -> "void" :
        """pop_back(fvector self)"""
        return _sim3dlong.fvector_pop_back(self)

    def erase(self, *args) -> "std::vector< float >::iterator" :
        """
        erase(fvector self, std::vector< float >::iterator pos) -> std::vector< float >::iterator
        erase(fvector self, std::vector< float >::iterator first, std::vector< float >::iterator last) -> std::vector< float >::iterator
        """
        return _sim3dlong.fvector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(float)> self) -> fvector
        __init__(std::vector<(float)> self, fvector arg2) -> fvector
        __init__(std::vector<(float)> self, std::vector< float >::size_type size) -> fvector
        __init__(std::vector<(float)> self, std::vector< float >::size_type size, std::vector< float >::value_type const & value) -> fvector
        """
        this = _sim3dlong.new_fvector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" :
        """push_back(fvector self, std::vector< float >::value_type const & x)"""
        return _sim3dlong.fvector_push_back(self, *args)

    def front(self) -> "std::vector< float >::value_type const &" :
        """front(fvector self) -> std::vector< float >::value_type const &"""
        return _sim3dlong.fvector_front(self)

    def back(self) -> "std::vector< float >::value_type const &" :
        """back(fvector self) -> std::vector< float >::value_type const &"""
        return _sim3dlong.fvector_back(self)

    def assign(self, *args) -> "void" :
        """assign(fvector self, std::vector< float >::size_type n, std::vector< float >::value_type const & x)"""
        return _sim3dlong.fvector_assign(self, *args)

    def resize(self, *args) -> "void" :
        """
        resize(fvector self, std::vector< float >::size_type new_size)
        resize(fvector self, std::vector< float >::size_type new_size, std::vector< float >::value_type const & x)
        """
        return _sim3dlong.fvector_resize(self, *args)

    def insert(self, *args) -> "void" :
        """
        insert(fvector self, std::vector< float >::iterator pos, std::vector< float >::value_type const & x) -> std::vector< float >::iterator
        insert(fvector self, std::vector< float >::iterator pos, std::vector< float >::size_type n, std::vector< float >::value_type const & x)
        """
        return _sim3dlong.fvector_insert(self, *args)

    def reserve(self, *args) -> "void" :
        """reserve(fvector self, std::vector< float >::size_type n)"""
        return _sim3dlong.fvector_reserve(self, *args)

    def capacity(self) -> "std::vector< float >::size_type" :
        """capacity(fvector self) -> std::vector< float >::size_type"""
        return _sim3dlong.fvector_capacity(self)

    __swig_destroy__ = _sim3dlong.delete_fvector
    __del__ = lambda self : None;
fvector_swigregister = _sim3dlong.fvector_swigregister
fvector_swigregister(fvector)

class dvector(collections.MutableSequence):
    """Proxy of C++ std::vector<(double)> class"""
    __swig_setmethods__ = {}
    for _s in [collections.MutableSequence]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, dvector, name, value)
    __swig_getmethods__ = {}
    for _s in [collections.MutableSequence]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, dvector, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" :
        """iterator(dvector self) -> SwigPyIterator"""
        return _sim3dlong.dvector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" :
        """__nonzero__(dvector self) -> bool"""
        return _sim3dlong.dvector___nonzero__(self)

    def __bool__(self) -> "bool" :
        """__bool__(dvector self) -> bool"""
        return _sim3dlong.dvector___bool__(self)

    def __len__(self) -> "std::vector< double >::size_type" :
        """__len__(dvector self) -> std::vector< double >::size_type"""
        return _sim3dlong.dvector___len__(self)

    def pop(self) -> "std::vector< double >::value_type" :
        """pop(dvector self) -> std::vector< double >::value_type"""
        return _sim3dlong.dvector_pop(self)

    def __getslice__(self, *args) -> "std::vector< double,std::allocator< double > > *" :
        """__getslice__(dvector self, std::vector< double >::difference_type i, std::vector< double >::difference_type j) -> dvector"""
        return _sim3dlong.dvector___getslice__(self, *args)

    def __setslice__(self, *args) -> "void" :
        """
        __setslice__(dvector self, std::vector< double >::difference_type i, std::vector< double >::difference_type j, 
            dvector v=std::vector< double,std::allocator< double > >())
        __setslice__(dvector self, std::vector< double >::difference_type i, std::vector< double >::difference_type j)
        """
        return _sim3dlong.dvector___setslice__(self, *args)

    def __delslice__(self, *args) -> "void" :
        """__delslice__(dvector self, std::vector< double >::difference_type i, std::vector< double >::difference_type j)"""
        return _sim3dlong.dvector___delslice__(self, *args)

    def __delitem__(self, *args) -> "void" :
        """
        __delitem__(dvector self, std::vector< double >::difference_type i)
        __delitem__(dvector self, PySliceObject * slice)
        """
        return _sim3dlong.dvector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< double >::value_type const &" :
        """
        __getitem__(dvector self, PySliceObject * slice) -> dvector
        __getitem__(dvector self, std::vector< double >::difference_type i) -> std::vector< double >::value_type const &
        """
        return _sim3dlong.dvector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void" :
        """
        __setitem__(dvector self, PySliceObject * slice, dvector v)
        __setitem__(dvector self, PySliceObject * slice)
        __setitem__(dvector self, std::vector< double >::difference_type i, std::vector< double >::value_type const & x)
        """
        return _sim3dlong.dvector___setitem__(self, *args)

    def append(self, *args) -> "void" :
        """append(dvector self, std::vector< double >::value_type const & x)"""
        return _sim3dlong.dvector_append(self, *args)

    def empty(self) -> "bool" :
        """empty(dvector self) -> bool"""
        return _sim3dlong.dvector_empty(self)

    def size(self) -> "std::vector< double >::size_type" :
        """size(dvector self) -> std::vector< double >::size_type"""
        return _sim3dlong.dvector_size(self)

    def clear(self) -> "void" :
        """clear(dvector self)"""
        return _sim3dlong.dvector_clear(self)

    def swap(self, *args) -> "void" :
        """swap(dvector self, dvector v)"""
        return _sim3dlong.dvector_swap(self, *args)

    def get_allocator(self) -> "std::vector< double >::allocator_type" :
        """get_allocator(dvector self) -> std::vector< double >::allocator_type"""
        return _sim3dlong.dvector_get_allocator(self)

    def begin(self) -> "std::vector< double >::iterator" :
        """begin(dvector self) -> std::vector< double >::iterator"""
        return _sim3dlong.dvector_begin(self)

    def end(self) -> "std::vector< double >::iterator" :
        """end(dvector self) -> std::vector< double >::iterator"""
        return _sim3dlong.dvector_end(self)

    def rbegin(self) -> "std::vector< double >::reverse_iterator" :
        """rbegin(dvector self) -> std::vector< double >::reverse_iterator"""
        return _sim3dlong.dvector_rbegin(self)

    def rend(self) -> "std::vector< double >::reverse_iterator" :
        """rend(dvector self) -> std::vector< double >::reverse_iterator"""
        return _sim3dlong.dvector_rend(self)

    def pop_back(self) -> "void" :
        """pop_back(dvector self)"""
        return _sim3dlong.dvector_pop_back(self)

    def erase(self, *args) -> "std::vector< double >::iterator" :
        """
        erase(dvector self, std::vector< double >::iterator pos) -> std::vector< double >::iterator
        erase(dvector self, std::vector< double >::iterator first, std::vector< double >::iterator last) -> std::vector< double >::iterator
        """
        return _sim3dlong.dvector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(double)> self) -> dvector
        __init__(std::vector<(double)> self, dvector arg2) -> dvector
        __init__(std::vector<(double)> self, std::vector< double >::size_type size) -> dvector
        __init__(std::vector<(double)> self, std::vector< double >::size_type size, std::vector< double >::value_type const & value) -> dvector
        """
        this = _sim3dlong.new_dvector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" :
        """push_back(dvector self, std::vector< double >::value_type const & x)"""
        return _sim3dlong.dvector_push_back(self, *args)

    def front(self) -> "std::vector< double >::value_type const &" :
        """front(dvector self) -> std::vector< double >::value_type const &"""
        return _sim3dlong.dvector_front(self)

    def back(self) -> "std::vector< double >::value_type const &" :
        """back(dvector self) -> std::vector< double >::value_type const &"""
        return _sim3dlong.dvector_back(self)

    def assign(self, *args) -> "void" :
        """assign(dvector self, std::vector< double >::size_type n, std::vector< double >::value_type const & x)"""
        return _sim3dlong.dvector_assign(self, *args)

    def resize(self, *args) -> "void" :
        """
        resize(dvector self, std::vector< double >::size_type new_size)
        resize(dvector self, std::vector< double >::size_type new_size, std::vector< double >::value_type const & x)
        """
        return _sim3dlong.dvector_resize(self, *args)

    def insert(self, *args) -> "void" :
        """
        insert(dvector self, std::vector< double >::iterator pos, std::vector< double >::value_type const & x) -> std::vector< double >::iterator
        insert(dvector self, std::vector< double >::iterator pos, std::vector< double >::size_type n, std::vector< double >::value_type const & x)
        """
        return _sim3dlong.dvector_insert(self, *args)

    def reserve(self, *args) -> "void" :
        """reserve(dvector self, std::vector< double >::size_type n)"""
        return _sim3dlong.dvector_reserve(self, *args)

    def capacity(self) -> "std::vector< double >::size_type" :
        """capacity(dvector self) -> std::vector< double >::size_type"""
        return _sim3dlong.dvector_capacity(self)

    __swig_destroy__ = _sim3dlong.delete_dvector
    __del__ = lambda self : None;
dvector_swigregister = _sim3dlong.dvector_swigregister
dvector_swigregister(dvector)

class ldvector(collections.MutableSequence):
    """Proxy of C++ std::vector<(long double)> class"""
    __swig_setmethods__ = {}
    for _s in [collections.MutableSequence]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ldvector, name, value)
    __swig_getmethods__ = {}
    for _s in [collections.MutableSequence]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ldvector, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" :
        """iterator(ldvector self) -> SwigPyIterator"""
        return _sim3dlong.ldvector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" :
        """__nonzero__(ldvector self) -> bool"""
        return _sim3dlong.ldvector___nonzero__(self)

    def __bool__(self) -> "bool" :
        """__bool__(ldvector self) -> bool"""
        return _sim3dlong.ldvector___bool__(self)

    def __len__(self) -> "std::vector< long double >::size_type" :
        """__len__(ldvector self) -> std::vector< long double >::size_type"""
        return _sim3dlong.ldvector___len__(self)

    def pop(self) -> "std::vector< long double >::value_type" :
        """pop(ldvector self) -> std::vector< long double >::value_type"""
        return _sim3dlong.ldvector_pop(self)

    def __getslice__(self, *args) -> "std::vector< long double,std::allocator< long double > > *" :
        """__getslice__(ldvector self, std::vector< long double >::difference_type i, std::vector< long double >::difference_type j) -> ldvector"""
        return _sim3dlong.ldvector___getslice__(self, *args)

    def __setslice__(self, *args) -> "void" :
        """
        __setslice__(ldvector self, std::vector< long double >::difference_type i, std::vector< long double >::difference_type j, 
            ldvector v=std::vector< long double,std::allocator< long double > >())
        __setslice__(ldvector self, std::vector< long double >::difference_type i, std::vector< long double >::difference_type j)
        """
        return _sim3dlong.ldvector___setslice__(self, *args)

    def __delslice__(self, *args) -> "void" :
        """__delslice__(ldvector self, std::vector< long double >::difference_type i, std::vector< long double >::difference_type j)"""
        return _sim3dlong.ldvector___delslice__(self, *args)

    def __delitem__(self, *args) -> "void" :
        """
        __delitem__(ldvector self, std::vector< long double >::difference_type i)
        __delitem__(ldvector self, PySliceObject * slice)
        """
        return _sim3dlong.ldvector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< long double >::value_type const &" :
        """
        __getitem__(ldvector self, PySliceObject * slice) -> ldvector
        __getitem__(ldvector self, std::vector< long double >::difference_type i) -> std::vector< long double >::value_type const &
        """
        return _sim3dlong.ldvector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void" :
        """
        __setitem__(ldvector self, PySliceObject * slice, ldvector v)
        __setitem__(ldvector self, PySliceObject * slice)
        __setitem__(ldvector self, std::vector< long double >::difference_type i, std::vector< long double >::value_type const & x)
        """
        return _sim3dlong.ldvector___setitem__(self, *args)

    def append(self, *args) -> "void" :
        """append(ldvector self, std::vector< long double >::value_type const & x)"""
        return _sim3dlong.ldvector_append(self, *args)

    def empty(self) -> "bool" :
        """empty(ldvector self) -> bool"""
        return _sim3dlong.ldvector_empty(self)

    def size(self) -> "std::vector< long double >::size_type" :
        """size(ldvector self) -> std::vector< long double >::size_type"""
        return _sim3dlong.ldvector_size(self)

    def clear(self) -> "void" :
        """clear(ldvector self)"""
        return _sim3dlong.ldvector_clear(self)

    def swap(self, *args) -> "void" :
        """swap(ldvector self, ldvector v)"""
        return _sim3dlong.ldvector_swap(self, *args)

    def get_allocator(self) -> "std::vector< long double >::allocator_type" :
        """get_allocator(ldvector self) -> std::vector< long double >::allocator_type"""
        return _sim3dlong.ldvector_get_allocator(self)

    def begin(self) -> "std::vector< long double >::iterator" :
        """begin(ldvector self) -> std::vector< long double >::iterator"""
        return _sim3dlong.ldvector_begin(self)

    def end(self) -> "std::vector< long double >::iterator" :
        """end(ldvector self) -> std::vector< long double >::iterator"""
        return _sim3dlong.ldvector_end(self)

    def rbegin(self) -> "std::vector< long double >::reverse_iterator" :
        """rbegin(ldvector self) -> std::vector< long double >::reverse_iterator"""
        return _sim3dlong.ldvector_rbegin(self)

    def rend(self) -> "std::vector< long double >::reverse_iterator" :
        """rend(ldvector self) -> std::vector< long double >::reverse_iterator"""
        return _sim3dlong.ldvector_rend(self)

    def pop_back(self) -> "void" :
        """pop_back(ldvector self)"""
        return _sim3dlong.ldvector_pop_back(self)

    def erase(self, *args) -> "std::vector< long double >::iterator" :
        """
        erase(ldvector self, std::vector< long double >::iterator pos) -> std::vector< long double >::iterator
        erase(ldvector self, std::vector< long double >::iterator first, std::vector< long double >::iterator last) -> std::vector< long double >::iterator
        """
        return _sim3dlong.ldvector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(long double)> self) -> ldvector
        __init__(std::vector<(long double)> self, ldvector arg2) -> ldvector
        __init__(std::vector<(long double)> self, std::vector< long double >::size_type size) -> ldvector
        __init__(std::vector<(long double)> self, std::vector< long double >::size_type size, std::vector< long double >::value_type const & value) -> ldvector
        """
        this = _sim3dlong.new_ldvector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" :
        """push_back(ldvector self, std::vector< long double >::value_type const & x)"""
        return _sim3dlong.ldvector_push_back(self, *args)

    def front(self) -> "std::vector< long double >::value_type const &" :
        """front(ldvector self) -> std::vector< long double >::value_type const &"""
        return _sim3dlong.ldvector_front(self)

    def back(self) -> "std::vector< long double >::value_type const &" :
        """back(ldvector self) -> std::vector< long double >::value_type const &"""
        return _sim3dlong.ldvector_back(self)

    def assign(self, *args) -> "void" :
        """assign(ldvector self, std::vector< long double >::size_type n, std::vector< long double >::value_type const & x)"""
        return _sim3dlong.ldvector_assign(self, *args)

    def resize(self, *args) -> "void" :
        """
        resize(ldvector self, std::vector< long double >::size_type new_size)
        resize(ldvector self, std::vector< long double >::size_type new_size, std::vector< long double >::value_type const & x)
        """
        return _sim3dlong.ldvector_resize(self, *args)

    def insert(self, *args) -> "void" :
        """
        insert(ldvector self, std::vector< long double >::iterator pos, std::vector< long double >::value_type const & x) -> std::vector< long double >::iterator
        insert(ldvector self, std::vector< long double >::iterator pos, std::vector< long double >::size_type n, 
            std::vector< long double >::value_type const & x)
        """
        return _sim3dlong.ldvector_insert(self, *args)

    def reserve(self, *args) -> "void" :
        """reserve(ldvector self, std::vector< long double >::size_type n)"""
        return _sim3dlong.ldvector_reserve(self, *args)

    def capacity(self) -> "std::vector< long double >::size_type" :
        """capacity(ldvector self) -> std::vector< long double >::size_type"""
        return _sim3dlong.ldvector_capacity(self)

    __swig_destroy__ = _sim3dlong.delete_ldvector
    __del__ = lambda self : None;
ldvector_swigregister = _sim3dlong.ldvector_swigregister
ldvector_swigregister(ldvector)

class avector(_object):
    """Proxy of C++ std::vector<(p.atomgroup)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, avector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, avector, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" :
        """iterator(avector self) -> SwigPyIterator"""
        return _sim3dlong.avector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" :
        """__nonzero__(avector self) -> bool"""
        return _sim3dlong.avector___nonzero__(self)

    def __bool__(self) -> "bool" :
        """__bool__(avector self) -> bool"""
        return _sim3dlong.avector___bool__(self)

    def __len__(self) -> "std::vector< atomgroup * >::size_type" :
        """__len__(avector self) -> std::vector< atomgroup * >::size_type"""
        return _sim3dlong.avector___len__(self)

    def pop(self) -> "std::vector< atomgroup * >::value_type" :
        """pop(avector self) -> atomgroup"""
        return _sim3dlong.avector_pop(self)

    def __getslice__(self, *args) -> "std::vector< atomgroup *,std::allocator< atomgroup * > > *" :
        """__getslice__(avector self, std::vector< atomgroup * >::difference_type i, std::vector< atomgroup * >::difference_type j) -> avector"""
        return _sim3dlong.avector___getslice__(self, *args)

    def __setslice__(self, *args) -> "void" :
        """
        __setslice__(avector self, std::vector< atomgroup * >::difference_type i, std::vector< atomgroup * >::difference_type j, 
            avector v=std::vector< atomgroup *,std::allocator< atomgroup * > >())
        __setslice__(avector self, std::vector< atomgroup * >::difference_type i, std::vector< atomgroup * >::difference_type j)
        """
        return _sim3dlong.avector___setslice__(self, *args)

    def __delslice__(self, *args) -> "void" :
        """__delslice__(avector self, std::vector< atomgroup * >::difference_type i, std::vector< atomgroup * >::difference_type j)"""
        return _sim3dlong.avector___delslice__(self, *args)

    def __delitem__(self, *args) -> "void" :
        """
        __delitem__(avector self, std::vector< atomgroup * >::difference_type i)
        __delitem__(avector self, PySliceObject * slice)
        """
        return _sim3dlong.avector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< atomgroup * >::value_type" :
        """
        __getitem__(avector self, PySliceObject * slice) -> avector
        __getitem__(avector self, std::vector< atomgroup * >::difference_type i) -> atomgroup
        """
        return _sim3dlong.avector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void" :
        """
        __setitem__(avector self, PySliceObject * slice, avector v)
        __setitem__(avector self, PySliceObject * slice)
        __setitem__(avector self, std::vector< atomgroup * >::difference_type i, atomgroup x)
        """
        return _sim3dlong.avector___setitem__(self, *args)

    def append(self, *args) -> "void" :
        """append(avector self, atomgroup x)"""
        return _sim3dlong.avector_append(self, *args)

    def empty(self) -> "bool" :
        """empty(avector self) -> bool"""
        return _sim3dlong.avector_empty(self)

    def size(self) -> "std::vector< atomgroup * >::size_type" :
        """size(avector self) -> std::vector< atomgroup * >::size_type"""
        return _sim3dlong.avector_size(self)

    def clear(self) -> "void" :
        """clear(avector self)"""
        return _sim3dlong.avector_clear(self)

    def swap(self, *args) -> "void" :
        """swap(avector self, avector v)"""
        return _sim3dlong.avector_swap(self, *args)

    def get_allocator(self) -> "std::vector< atomgroup * >::allocator_type" :
        """get_allocator(avector self) -> std::vector< atomgroup * >::allocator_type"""
        return _sim3dlong.avector_get_allocator(self)

    def begin(self) -> "std::vector< atomgroup * >::iterator" :
        """begin(avector self) -> std::vector< atomgroup * >::iterator"""
        return _sim3dlong.avector_begin(self)

    def end(self) -> "std::vector< atomgroup * >::iterator" :
        """end(avector self) -> std::vector< atomgroup * >::iterator"""
        return _sim3dlong.avector_end(self)

    def rbegin(self) -> "std::vector< atomgroup * >::reverse_iterator" :
        """rbegin(avector self) -> std::vector< atomgroup * >::reverse_iterator"""
        return _sim3dlong.avector_rbegin(self)

    def rend(self) -> "std::vector< atomgroup * >::reverse_iterator" :
        """rend(avector self) -> std::vector< atomgroup * >::reverse_iterator"""
        return _sim3dlong.avector_rend(self)

    def pop_back(self) -> "void" :
        """pop_back(avector self)"""
        return _sim3dlong.avector_pop_back(self)

    def erase(self, *args) -> "std::vector< atomgroup * >::iterator" :
        """
        erase(avector self, std::vector< atomgroup * >::iterator pos) -> std::vector< atomgroup * >::iterator
        erase(avector self, std::vector< atomgroup * >::iterator first, std::vector< atomgroup * >::iterator last) -> std::vector< atomgroup * >::iterator
        """
        return _sim3dlong.avector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(p.atomgroup)> self) -> avector
        __init__(std::vector<(p.atomgroup)> self, avector arg2) -> avector
        __init__(std::vector<(p.atomgroup)> self, std::vector< atomgroup * >::size_type size) -> avector
        __init__(std::vector<(p.atomgroup)> self, std::vector< atomgroup * >::size_type size, atomgroup value) -> avector
        """
        this = _sim3dlong.new_avector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" :
        """push_back(avector self, atomgroup x)"""
        return _sim3dlong.avector_push_back(self, *args)

    def front(self) -> "std::vector< atomgroup * >::value_type" :
        """front(avector self) -> atomgroup"""
        return _sim3dlong.avector_front(self)

    def back(self) -> "std::vector< atomgroup * >::value_type" :
        """back(avector self) -> atomgroup"""
        return _sim3dlong.avector_back(self)

    def assign(self, *args) -> "void" :
        """assign(avector self, std::vector< atomgroup * >::size_type n, atomgroup x)"""
        return _sim3dlong.avector_assign(self, *args)

    def resize(self, *args) -> "void" :
        """
        resize(avector self, std::vector< atomgroup * >::size_type new_size)
        resize(avector self, std::vector< atomgroup * >::size_type new_size, atomgroup x)
        """
        return _sim3dlong.avector_resize(self, *args)

    def insert(self, *args) -> "void" :
        """
        insert(avector self, std::vector< atomgroup * >::iterator pos, atomgroup x) -> std::vector< atomgroup * >::iterator
        insert(avector self, std::vector< atomgroup * >::iterator pos, std::vector< atomgroup * >::size_type n, 
            atomgroup x)
        """
        return _sim3dlong.avector_insert(self, *args)

    def reserve(self, *args) -> "void" :
        """reserve(avector self, std::vector< atomgroup * >::size_type n)"""
        return _sim3dlong.avector_reserve(self, *args)

    def capacity(self) -> "std::vector< atomgroup * >::size_type" :
        """capacity(avector self) -> std::vector< atomgroup * >::size_type"""
        return _sim3dlong.avector_capacity(self)

    __swig_destroy__ = _sim3dlong.delete_avector
    __del__ = lambda self : None;
avector_swigregister = _sim3dlong.avector_swigregister
avector_swigregister(avector)

class aptrvector(_object):
    """Proxy of C++ std::vector<(p.atom)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, aptrvector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, aptrvector, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" :
        """iterator(aptrvector self) -> SwigPyIterator"""
        return _sim3dlong.aptrvector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" :
        """__nonzero__(aptrvector self) -> bool"""
        return _sim3dlong.aptrvector___nonzero__(self)

    def __bool__(self) -> "bool" :
        """__bool__(aptrvector self) -> bool"""
        return _sim3dlong.aptrvector___bool__(self)

    def __len__(self) -> "std::vector< atom * >::size_type" :
        """__len__(aptrvector self) -> std::vector< atom * >::size_type"""
        return _sim3dlong.aptrvector___len__(self)

    def pop(self) -> "std::vector< atom * >::value_type" :
        """pop(aptrvector self) -> atom"""
        return _sim3dlong.aptrvector_pop(self)

    def __getslice__(self, *args) -> "std::vector< atom *,std::allocator< atom * > > *" :
        """__getslice__(aptrvector self, std::vector< atom * >::difference_type i, std::vector< atom * >::difference_type j) -> aptrvector"""
        return _sim3dlong.aptrvector___getslice__(self, *args)

    def __setslice__(self, *args) -> "void" :
        """
        __setslice__(aptrvector self, std::vector< atom * >::difference_type i, std::vector< atom * >::difference_type j, 
            aptrvector v=std::vector< atom *,std::allocator< atom * > >())
        __setslice__(aptrvector self, std::vector< atom * >::difference_type i, std::vector< atom * >::difference_type j)
        """
        return _sim3dlong.aptrvector___setslice__(self, *args)

    def __delslice__(self, *args) -> "void" :
        """__delslice__(aptrvector self, std::vector< atom * >::difference_type i, std::vector< atom * >::difference_type j)"""
        return _sim3dlong.aptrvector___delslice__(self, *args)

    def __delitem__(self, *args) -> "void" :
        """
        __delitem__(aptrvector self, std::vector< atom * >::difference_type i)
        __delitem__(aptrvector self, PySliceObject * slice)
        """
        return _sim3dlong.aptrvector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< atom * >::value_type" :
        """
        __getitem__(aptrvector self, PySliceObject * slice) -> aptrvector
        __getitem__(aptrvector self, std::vector< atom * >::difference_type i) -> atom
        """
        return _sim3dlong.aptrvector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void" :
        """
        __setitem__(aptrvector self, PySliceObject * slice, aptrvector v)
        __setitem__(aptrvector self, PySliceObject * slice)
        __setitem__(aptrvector self, std::vector< atom * >::difference_type i, atom x)
        """
        return _sim3dlong.aptrvector___setitem__(self, *args)

    def append(self, *args) -> "void" :
        """append(aptrvector self, atom x)"""
        return _sim3dlong.aptrvector_append(self, *args)

    def empty(self) -> "bool" :
        """empty(aptrvector self) -> bool"""
        return _sim3dlong.aptrvector_empty(self)

    def size(self) -> "std::vector< atom * >::size_type" :
        """size(aptrvector self) -> std::vector< atom * >::size_type"""
        return _sim3dlong.aptrvector_size(self)

    def clear(self) -> "void" :
        """clear(aptrvector self)"""
        return _sim3dlong.aptrvector_clear(self)

    def swap(self, *args) -> "void" :
        """swap(aptrvector self, aptrvector v)"""
        return _sim3dlong.aptrvector_swap(self, *args)

    def get_allocator(self) -> "std::vector< atom * >::allocator_type" :
        """get_allocator(aptrvector self) -> std::vector< atom * >::allocator_type"""
        return _sim3dlong.aptrvector_get_allocator(self)

    def begin(self) -> "std::vector< atom * >::iterator" :
        """begin(aptrvector self) -> std::vector< atom * >::iterator"""
        return _sim3dlong.aptrvector_begin(self)

    def end(self) -> "std::vector< atom * >::iterator" :
        """end(aptrvector self) -> std::vector< atom * >::iterator"""
        return _sim3dlong.aptrvector_end(self)

    def rbegin(self) -> "std::vector< atom * >::reverse_iterator" :
        """rbegin(aptrvector self) -> std::vector< atom * >::reverse_iterator"""
        return _sim3dlong.aptrvector_rbegin(self)

    def rend(self) -> "std::vector< atom * >::reverse_iterator" :
        """rend(aptrvector self) -> std::vector< atom * >::reverse_iterator"""
        return _sim3dlong.aptrvector_rend(self)

    def pop_back(self) -> "void" :
        """pop_back(aptrvector self)"""
        return _sim3dlong.aptrvector_pop_back(self)

    def erase(self, *args) -> "std::vector< atom * >::iterator" :
        """
        erase(aptrvector self, std::vector< atom * >::iterator pos) -> std::vector< atom * >::iterator
        erase(aptrvector self, std::vector< atom * >::iterator first, std::vector< atom * >::iterator last) -> std::vector< atom * >::iterator
        """
        return _sim3dlong.aptrvector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(p.atom)> self) -> aptrvector
        __init__(std::vector<(p.atom)> self, aptrvector arg2) -> aptrvector
        __init__(std::vector<(p.atom)> self, std::vector< atom * >::size_type size) -> aptrvector
        __init__(std::vector<(p.atom)> self, std::vector< atom * >::size_type size, atom value) -> aptrvector
        """
        this = _sim3dlong.new_aptrvector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" :
        """push_back(aptrvector self, atom x)"""
        return _sim3dlong.aptrvector_push_back(self, *args)

    def front(self) -> "std::vector< atom * >::value_type" :
        """front(aptrvector self) -> atom"""
        return _sim3dlong.aptrvector_front(self)

    def back(self) -> "std::vector< atom * >::value_type" :
        """back(aptrvector self) -> atom"""
        return _sim3dlong.aptrvector_back(self)

    def assign(self, *args) -> "void" :
        """assign(aptrvector self, std::vector< atom * >::size_type n, atom x)"""
        return _sim3dlong.aptrvector_assign(self, *args)

    def resize(self, *args) -> "void" :
        """
        resize(aptrvector self, std::vector< atom * >::size_type new_size)
        resize(aptrvector self, std::vector< atom * >::size_type new_size, atom x)
        """
        return _sim3dlong.aptrvector_resize(self, *args)

    def insert(self, *args) -> "void" :
        """
        insert(aptrvector self, std::vector< atom * >::iterator pos, atom x) -> std::vector< atom * >::iterator
        insert(aptrvector self, std::vector< atom * >::iterator pos, std::vector< atom * >::size_type n, atom x)
        """
        return _sim3dlong.aptrvector_insert(self, *args)

    def reserve(self, *args) -> "void" :
        """reserve(aptrvector self, std::vector< atom * >::size_type n)"""
        return _sim3dlong.aptrvector_reserve(self, *args)

    def capacity(self) -> "std::vector< atom * >::size_type" :
        """capacity(aptrvector self) -> std::vector< atom * >::size_type"""
        return _sim3dlong.aptrvector_capacity(self)

    __swig_destroy__ = _sim3dlong.delete_aptrvector
    __del__ = lambda self : None;
aptrvector_swigregister = _sim3dlong.aptrvector_swigregister
aptrvector_swigregister(aptrvector)

class ivector(_object):
    """Proxy of C++ std::vector<(p.interaction)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ivector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ivector, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" :
        """iterator(ivector self) -> SwigPyIterator"""
        return _sim3dlong.ivector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" :
        """__nonzero__(ivector self) -> bool"""
        return _sim3dlong.ivector___nonzero__(self)

    def __bool__(self) -> "bool" :
        """__bool__(ivector self) -> bool"""
        return _sim3dlong.ivector___bool__(self)

    def __len__(self) -> "std::vector< interaction * >::size_type" :
        """__len__(ivector self) -> std::vector< interaction * >::size_type"""
        return _sim3dlong.ivector___len__(self)

    def pop(self) -> "std::vector< interaction * >::value_type" :
        """pop(ivector self) -> interaction"""
        return _sim3dlong.ivector_pop(self)

    def __getslice__(self, *args) -> "std::vector< interaction *,std::allocator< interaction * > > *" :
        """__getslice__(ivector self, std::vector< interaction * >::difference_type i, std::vector< interaction * >::difference_type j) -> ivector"""
        return _sim3dlong.ivector___getslice__(self, *args)

    def __setslice__(self, *args) -> "void" :
        """
        __setslice__(ivector self, std::vector< interaction * >::difference_type i, std::vector< interaction * >::difference_type j, 
            ivector v=std::vector< interaction *,std::allocator< interaction * > >())
        __setslice__(ivector self, std::vector< interaction * >::difference_type i, std::vector< interaction * >::difference_type j)
        """
        return _sim3dlong.ivector___setslice__(self, *args)

    def __delslice__(self, *args) -> "void" :
        """__delslice__(ivector self, std::vector< interaction * >::difference_type i, std::vector< interaction * >::difference_type j)"""
        return _sim3dlong.ivector___delslice__(self, *args)

    def __delitem__(self, *args) -> "void" :
        """
        __delitem__(ivector self, std::vector< interaction * >::difference_type i)
        __delitem__(ivector self, PySliceObject * slice)
        """
        return _sim3dlong.ivector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< interaction * >::value_type" :
        """
        __getitem__(ivector self, PySliceObject * slice) -> ivector
        __getitem__(ivector self, std::vector< interaction * >::difference_type i) -> interaction
        """
        return _sim3dlong.ivector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void" :
        """
        __setitem__(ivector self, PySliceObject * slice, ivector v)
        __setitem__(ivector self, PySliceObject * slice)
        __setitem__(ivector self, std::vector< interaction * >::difference_type i, interaction x)
        """
        return _sim3dlong.ivector___setitem__(self, *args)

    def append(self, *args) -> "void" :
        """append(ivector self, interaction x)"""
        return _sim3dlong.ivector_append(self, *args)

    def empty(self) -> "bool" :
        """empty(ivector self) -> bool"""
        return _sim3dlong.ivector_empty(self)

    def size(self) -> "std::vector< interaction * >::size_type" :
        """size(ivector self) -> std::vector< interaction * >::size_type"""
        return _sim3dlong.ivector_size(self)

    def clear(self) -> "void" :
        """clear(ivector self)"""
        return _sim3dlong.ivector_clear(self)

    def swap(self, *args) -> "void" :
        """swap(ivector self, ivector v)"""
        return _sim3dlong.ivector_swap(self, *args)

    def get_allocator(self) -> "std::vector< interaction * >::allocator_type" :
        """get_allocator(ivector self) -> std::vector< interaction * >::allocator_type"""
        return _sim3dlong.ivector_get_allocator(self)

    def begin(self) -> "std::vector< interaction * >::iterator" :
        """begin(ivector self) -> std::vector< interaction * >::iterator"""
        return _sim3dlong.ivector_begin(self)

    def end(self) -> "std::vector< interaction * >::iterator" :
        """end(ivector self) -> std::vector< interaction * >::iterator"""
        return _sim3dlong.ivector_end(self)

    def rbegin(self) -> "std::vector< interaction * >::reverse_iterator" :
        """rbegin(ivector self) -> std::vector< interaction * >::reverse_iterator"""
        return _sim3dlong.ivector_rbegin(self)

    def rend(self) -> "std::vector< interaction * >::reverse_iterator" :
        """rend(ivector self) -> std::vector< interaction * >::reverse_iterator"""
        return _sim3dlong.ivector_rend(self)

    def pop_back(self) -> "void" :
        """pop_back(ivector self)"""
        return _sim3dlong.ivector_pop_back(self)

    def erase(self, *args) -> "std::vector< interaction * >::iterator" :
        """
        erase(ivector self, std::vector< interaction * >::iterator pos) -> std::vector< interaction * >::iterator
        erase(ivector self, std::vector< interaction * >::iterator first, std::vector< interaction * >::iterator last) -> std::vector< interaction * >::iterator
        """
        return _sim3dlong.ivector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(p.interaction)> self) -> ivector
        __init__(std::vector<(p.interaction)> self, ivector arg2) -> ivector
        __init__(std::vector<(p.interaction)> self, std::vector< interaction * >::size_type size) -> ivector
        __init__(std::vector<(p.interaction)> self, std::vector< interaction * >::size_type size, interaction value) -> ivector
        """
        this = _sim3dlong.new_ivector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" :
        """push_back(ivector self, interaction x)"""
        return _sim3dlong.ivector_push_back(self, *args)

    def front(self) -> "std::vector< interaction * >::value_type" :
        """front(ivector self) -> interaction"""
        return _sim3dlong.ivector_front(self)

    def back(self) -> "std::vector< interaction * >::value_type" :
        """back(ivector self) -> interaction"""
        return _sim3dlong.ivector_back(self)

    def assign(self, *args) -> "void" :
        """assign(ivector self, std::vector< interaction * >::size_type n, interaction x)"""
        return _sim3dlong.ivector_assign(self, *args)

    def resize(self, *args) -> "void" :
        """
        resize(ivector self, std::vector< interaction * >::size_type new_size)
        resize(ivector self, std::vector< interaction * >::size_type new_size, interaction x)
        """
        return _sim3dlong.ivector_resize(self, *args)

    def insert(self, *args) -> "void" :
        """
        insert(ivector self, std::vector< interaction * >::iterator pos, interaction x) -> std::vector< interaction * >::iterator
        insert(ivector self, std::vector< interaction * >::iterator pos, std::vector< interaction * >::size_type n, 
            interaction x)
        """
        return _sim3dlong.ivector_insert(self, *args)

    def reserve(self, *args) -> "void" :
        """reserve(ivector self, std::vector< interaction * >::size_type n)"""
        return _sim3dlong.ivector_reserve(self, *args)

    def capacity(self) -> "std::vector< interaction * >::size_type" :
        """capacity(ivector self) -> std::vector< interaction * >::size_type"""
        return _sim3dlong.ivector_capacity(self)

    __swig_destroy__ = _sim3dlong.delete_ivector
    __del__ = lambda self : None;
ivector_swigregister = _sim3dlong.ivector_swigregister
ivector_swigregister(ivector)

class ifxvector(_object):
    """Proxy of C++ std::vector<(p.interactionpairsx)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ifxvector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ifxvector, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" :
        """iterator(ifxvector self) -> SwigPyIterator"""
        return _sim3dlong.ifxvector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" :
        """__nonzero__(ifxvector self) -> bool"""
        return _sim3dlong.ifxvector___nonzero__(self)

    def __bool__(self) -> "bool" :
        """__bool__(ifxvector self) -> bool"""
        return _sim3dlong.ifxvector___bool__(self)

    def __len__(self) -> "std::vector< interactionpairsx * >::size_type" :
        """__len__(ifxvector self) -> std::vector< interactionpairsx * >::size_type"""
        return _sim3dlong.ifxvector___len__(self)

    def pop(self) -> "std::vector< interactionpairsx * >::value_type" :
        """pop(ifxvector self) -> interactionpairsx"""
        return _sim3dlong.ifxvector_pop(self)

    def __getslice__(self, *args) -> "std::vector< interactionpairsx *,std::allocator< interactionpairsx * > > *" :
        """__getslice__(ifxvector self, std::vector< interactionpairsx * >::difference_type i, std::vector< interactionpairsx * >::difference_type j) -> ifxvector"""
        return _sim3dlong.ifxvector___getslice__(self, *args)

    def __setslice__(self, *args) -> "void" :
        """
        __setslice__(ifxvector self, std::vector< interactionpairsx * >::difference_type i, std::vector< interactionpairsx * >::difference_type j, 
            ifxvector v=std::vector< interactionpairsx *,std::allocator< interactionpairsx * > >())
        __setslice__(ifxvector self, std::vector< interactionpairsx * >::difference_type i, std::vector< interactionpairsx * >::difference_type j)
        """
        return _sim3dlong.ifxvector___setslice__(self, *args)

    def __delslice__(self, *args) -> "void" :
        """__delslice__(ifxvector self, std::vector< interactionpairsx * >::difference_type i, std::vector< interactionpairsx * >::difference_type j)"""
        return _sim3dlong.ifxvector___delslice__(self, *args)

    def __delitem__(self, *args) -> "void" :
        """
        __delitem__(ifxvector self, std::vector< interactionpairsx * >::difference_type i)
        __delitem__(ifxvector self, PySliceObject * slice)
        """
        return _sim3dlong.ifxvector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< interactionpairsx * >::value_type" :
        """
        __getitem__(ifxvector self, PySliceObject * slice) -> ifxvector
        __getitem__(ifxvector self, std::vector< interactionpairsx * >::difference_type i) -> interactionpairsx
        """
        return _sim3dlong.ifxvector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void" :
        """
        __setitem__(ifxvector self, PySliceObject * slice, ifxvector v)
        __setitem__(ifxvector self, PySliceObject * slice)
        __setitem__(ifxvector self, std::vector< interactionpairsx * >::difference_type i, interactionpairsx x)
        """
        return _sim3dlong.ifxvector___setitem__(self, *args)

    def append(self, *args) -> "void" :
        """append(ifxvector self, interactionpairsx x)"""
        return _sim3dlong.ifxvector_append(self, *args)

    def empty(self) -> "bool" :
        """empty(ifxvector self) -> bool"""
        return _sim3dlong.ifxvector_empty(self)

    def size(self) -> "std::vector< interactionpairsx * >::size_type" :
        """size(ifxvector self) -> std::vector< interactionpairsx * >::size_type"""
        return _sim3dlong.ifxvector_size(self)

    def clear(self) -> "void" :
        """clear(ifxvector self)"""
        return _sim3dlong.ifxvector_clear(self)

    def swap(self, *args) -> "void" :
        """swap(ifxvector self, ifxvector v)"""
        return _sim3dlong.ifxvector_swap(self, *args)

    def get_allocator(self) -> "std::vector< interactionpairsx * >::allocator_type" :
        """get_allocator(ifxvector self) -> std::vector< interactionpairsx * >::allocator_type"""
        return _sim3dlong.ifxvector_get_allocator(self)

    def begin(self) -> "std::vector< interactionpairsx * >::iterator" :
        """begin(ifxvector self) -> std::vector< interactionpairsx * >::iterator"""
        return _sim3dlong.ifxvector_begin(self)

    def end(self) -> "std::vector< interactionpairsx * >::iterator" :
        """end(ifxvector self) -> std::vector< interactionpairsx * >::iterator"""
        return _sim3dlong.ifxvector_end(self)

    def rbegin(self) -> "std::vector< interactionpairsx * >::reverse_iterator" :
        """rbegin(ifxvector self) -> std::vector< interactionpairsx * >::reverse_iterator"""
        return _sim3dlong.ifxvector_rbegin(self)

    def rend(self) -> "std::vector< interactionpairsx * >::reverse_iterator" :
        """rend(ifxvector self) -> std::vector< interactionpairsx * >::reverse_iterator"""
        return _sim3dlong.ifxvector_rend(self)

    def pop_back(self) -> "void" :
        """pop_back(ifxvector self)"""
        return _sim3dlong.ifxvector_pop_back(self)

    def erase(self, *args) -> "std::vector< interactionpairsx * >::iterator" :
        """
        erase(ifxvector self, std::vector< interactionpairsx * >::iterator pos) -> std::vector< interactionpairsx * >::iterator
        erase(ifxvector self, std::vector< interactionpairsx * >::iterator first, std::vector< interactionpairsx * >::iterator last) -> std::vector< interactionpairsx * >::iterator
        """
        return _sim3dlong.ifxvector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(p.interactionpairsx)> self) -> ifxvector
        __init__(std::vector<(p.interactionpairsx)> self, ifxvector arg2) -> ifxvector
        __init__(std::vector<(p.interactionpairsx)> self, std::vector< interactionpairsx * >::size_type size) -> ifxvector
        __init__(std::vector<(p.interactionpairsx)> self, std::vector< interactionpairsx * >::size_type size, interactionpairsx value) -> ifxvector
        """
        this = _sim3dlong.new_ifxvector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" :
        """push_back(ifxvector self, interactionpairsx x)"""
        return _sim3dlong.ifxvector_push_back(self, *args)

    def front(self) -> "std::vector< interactionpairsx * >::value_type" :
        """front(ifxvector self) -> interactionpairsx"""
        return _sim3dlong.ifxvector_front(self)

    def back(self) -> "std::vector< interactionpairsx * >::value_type" :
        """back(ifxvector self) -> interactionpairsx"""
        return _sim3dlong.ifxvector_back(self)

    def assign(self, *args) -> "void" :
        """assign(ifxvector self, std::vector< interactionpairsx * >::size_type n, interactionpairsx x)"""
        return _sim3dlong.ifxvector_assign(self, *args)

    def resize(self, *args) -> "void" :
        """
        resize(ifxvector self, std::vector< interactionpairsx * >::size_type new_size)
        resize(ifxvector self, std::vector< interactionpairsx * >::size_type new_size, interactionpairsx x)
        """
        return _sim3dlong.ifxvector_resize(self, *args)

    def insert(self, *args) -> "void" :
        """
        insert(ifxvector self, std::vector< interactionpairsx * >::iterator pos, interactionpairsx x) -> std::vector< interactionpairsx * >::iterator
        insert(ifxvector self, std::vector< interactionpairsx * >::iterator pos, std::vector< interactionpairsx * >::size_type n, 
            interactionpairsx x)
        """
        return _sim3dlong.ifxvector_insert(self, *args)

    def reserve(self, *args) -> "void" :
        """reserve(ifxvector self, std::vector< interactionpairsx * >::size_type n)"""
        return _sim3dlong.ifxvector_reserve(self, *args)

    def capacity(self) -> "std::vector< interactionpairsx * >::size_type" :
        """capacity(ifxvector self) -> std::vector< interactionpairsx * >::size_type"""
        return _sim3dlong.ifxvector_capacity(self)

    __swig_destroy__ = _sim3dlong.delete_ifxvector
    __del__ = lambda self : None;
ifxvector_swigregister = _sim3dlong.ifxvector_swigregister
ifxvector_swigregister(ifxvector)

class tvector(_object):
    """Proxy of C++ std::vector<(p.statetracker)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, tvector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, tvector, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" :
        """iterator(tvector self) -> SwigPyIterator"""
        return _sim3dlong.tvector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" :
        """__nonzero__(tvector self) -> bool"""
        return _sim3dlong.tvector___nonzero__(self)

    def __bool__(self) -> "bool" :
        """__bool__(tvector self) -> bool"""
        return _sim3dlong.tvector___bool__(self)

    def __len__(self) -> "std::vector< statetracker * >::size_type" :
        """__len__(tvector self) -> std::vector< statetracker * >::size_type"""
        return _sim3dlong.tvector___len__(self)

    def pop(self) -> "std::vector< statetracker * >::value_type" :
        """pop(tvector self) -> statetracker"""
        return _sim3dlong.tvector_pop(self)

    def __getslice__(self, *args) -> "std::vector< statetracker *,std::allocator< statetracker * > > *" :
        """__getslice__(tvector self, std::vector< statetracker * >::difference_type i, std::vector< statetracker * >::difference_type j) -> tvector"""
        return _sim3dlong.tvector___getslice__(self, *args)

    def __setslice__(self, *args) -> "void" :
        """
        __setslice__(tvector self, std::vector< statetracker * >::difference_type i, std::vector< statetracker * >::difference_type j, 
            tvector v=std::vector< statetracker *,std::allocator< statetracker * > >())
        __setslice__(tvector self, std::vector< statetracker * >::difference_type i, std::vector< statetracker * >::difference_type j)
        """
        return _sim3dlong.tvector___setslice__(self, *args)

    def __delslice__(self, *args) -> "void" :
        """__delslice__(tvector self, std::vector< statetracker * >::difference_type i, std::vector< statetracker * >::difference_type j)"""
        return _sim3dlong.tvector___delslice__(self, *args)

    def __delitem__(self, *args) -> "void" :
        """
        __delitem__(tvector self, std::vector< statetracker * >::difference_type i)
        __delitem__(tvector self, PySliceObject * slice)
        """
        return _sim3dlong.tvector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< statetracker * >::value_type" :
        """
        __getitem__(tvector self, PySliceObject * slice) -> tvector
        __getitem__(tvector self, std::vector< statetracker * >::difference_type i) -> statetracker
        """
        return _sim3dlong.tvector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void" :
        """
        __setitem__(tvector self, PySliceObject * slice, tvector v)
        __setitem__(tvector self, PySliceObject * slice)
        __setitem__(tvector self, std::vector< statetracker * >::difference_type i, statetracker x)
        """
        return _sim3dlong.tvector___setitem__(self, *args)

    def append(self, *args) -> "void" :
        """append(tvector self, statetracker x)"""
        return _sim3dlong.tvector_append(self, *args)

    def empty(self) -> "bool" :
        """empty(tvector self) -> bool"""
        return _sim3dlong.tvector_empty(self)

    def size(self) -> "std::vector< statetracker * >::size_type" :
        """size(tvector self) -> std::vector< statetracker * >::size_type"""
        return _sim3dlong.tvector_size(self)

    def clear(self) -> "void" :
        """clear(tvector self)"""
        return _sim3dlong.tvector_clear(self)

    def swap(self, *args) -> "void" :
        """swap(tvector self, tvector v)"""
        return _sim3dlong.tvector_swap(self, *args)

    def get_allocator(self) -> "std::vector< statetracker * >::allocator_type" :
        """get_allocator(tvector self) -> std::vector< statetracker * >::allocator_type"""
        return _sim3dlong.tvector_get_allocator(self)

    def begin(self) -> "std::vector< statetracker * >::iterator" :
        """begin(tvector self) -> std::vector< statetracker * >::iterator"""
        return _sim3dlong.tvector_begin(self)

    def end(self) -> "std::vector< statetracker * >::iterator" :
        """end(tvector self) -> std::vector< statetracker * >::iterator"""
        return _sim3dlong.tvector_end(self)

    def rbegin(self) -> "std::vector< statetracker * >::reverse_iterator" :
        """rbegin(tvector self) -> std::vector< statetracker * >::reverse_iterator"""
        return _sim3dlong.tvector_rbegin(self)

    def rend(self) -> "std::vector< statetracker * >::reverse_iterator" :
        """rend(tvector self) -> std::vector< statetracker * >::reverse_iterator"""
        return _sim3dlong.tvector_rend(self)

    def pop_back(self) -> "void" :
        """pop_back(tvector self)"""
        return _sim3dlong.tvector_pop_back(self)

    def erase(self, *args) -> "std::vector< statetracker * >::iterator" :
        """
        erase(tvector self, std::vector< statetracker * >::iterator pos) -> std::vector< statetracker * >::iterator
        erase(tvector self, std::vector< statetracker * >::iterator first, std::vector< statetracker * >::iterator last) -> std::vector< statetracker * >::iterator
        """
        return _sim3dlong.tvector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(p.statetracker)> self) -> tvector
        __init__(std::vector<(p.statetracker)> self, tvector arg2) -> tvector
        __init__(std::vector<(p.statetracker)> self, std::vector< statetracker * >::size_type size) -> tvector
        __init__(std::vector<(p.statetracker)> self, std::vector< statetracker * >::size_type size, statetracker value) -> tvector
        """
        this = _sim3dlong.new_tvector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" :
        """push_back(tvector self, statetracker x)"""
        return _sim3dlong.tvector_push_back(self, *args)

    def front(self) -> "std::vector< statetracker * >::value_type" :
        """front(tvector self) -> statetracker"""
        return _sim3dlong.tvector_front(self)

    def back(self) -> "std::vector< statetracker * >::value_type" :
        """back(tvector self) -> statetracker"""
        return _sim3dlong.tvector_back(self)

    def assign(self, *args) -> "void" :
        """assign(tvector self, std::vector< statetracker * >::size_type n, statetracker x)"""
        return _sim3dlong.tvector_assign(self, *args)

    def resize(self, *args) -> "void" :
        """
        resize(tvector self, std::vector< statetracker * >::size_type new_size)
        resize(tvector self, std::vector< statetracker * >::size_type new_size, statetracker x)
        """
        return _sim3dlong.tvector_resize(self, *args)

    def insert(self, *args) -> "void" :
        """
        insert(tvector self, std::vector< statetracker * >::iterator pos, statetracker x) -> std::vector< statetracker * >::iterator
        insert(tvector self, std::vector< statetracker * >::iterator pos, std::vector< statetracker * >::size_type n, 
            statetracker x)
        """
        return _sim3dlong.tvector_insert(self, *args)

    def reserve(self, *args) -> "void" :
        """reserve(tvector self, std::vector< statetracker * >::size_type n)"""
        return _sim3dlong.tvector_reserve(self, *args)

    def capacity(self) -> "std::vector< statetracker * >::size_type" :
        """capacity(tvector self) -> std::vector< statetracker * >::size_type"""
        return _sim3dlong.tvector_capacity(self)

    __swig_destroy__ = _sim3dlong.delete_tvector
    __del__ = lambda self : None;
tvector_swigregister = _sim3dlong.tvector_swigregister
tvector_swigregister(tvector)

class constraintvector(_object):
    """Proxy of C++ std::vector<(p.constraint)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, constraintvector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, constraintvector, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" :
        """iterator(constraintvector self) -> SwigPyIterator"""
        return _sim3dlong.constraintvector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" :
        """__nonzero__(constraintvector self) -> bool"""
        return _sim3dlong.constraintvector___nonzero__(self)

    def __bool__(self) -> "bool" :
        """__bool__(constraintvector self) -> bool"""
        return _sim3dlong.constraintvector___bool__(self)

    def __len__(self) -> "std::vector< constraint * >::size_type" :
        """__len__(constraintvector self) -> std::vector< constraint * >::size_type"""
        return _sim3dlong.constraintvector___len__(self)

    def pop(self) -> "std::vector< constraint * >::value_type" :
        """pop(constraintvector self) -> constraint"""
        return _sim3dlong.constraintvector_pop(self)

    def __getslice__(self, *args) -> "std::vector< constraint *,std::allocator< constraint * > > *" :
        """__getslice__(constraintvector self, std::vector< constraint * >::difference_type i, std::vector< constraint * >::difference_type j) -> constraintvector"""
        return _sim3dlong.constraintvector___getslice__(self, *args)

    def __setslice__(self, *args) -> "void" :
        """
        __setslice__(constraintvector self, std::vector< constraint * >::difference_type i, std::vector< constraint * >::difference_type j, 
            constraintvector v=std::vector< constraint *,std::allocator< constraint * > >())
        __setslice__(constraintvector self, std::vector< constraint * >::difference_type i, std::vector< constraint * >::difference_type j)
        """
        return _sim3dlong.constraintvector___setslice__(self, *args)

    def __delslice__(self, *args) -> "void" :
        """__delslice__(constraintvector self, std::vector< constraint * >::difference_type i, std::vector< constraint * >::difference_type j)"""
        return _sim3dlong.constraintvector___delslice__(self, *args)

    def __delitem__(self, *args) -> "void" :
        """
        __delitem__(constraintvector self, std::vector< constraint * >::difference_type i)
        __delitem__(constraintvector self, PySliceObject * slice)
        """
        return _sim3dlong.constraintvector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< constraint * >::value_type" :
        """
        __getitem__(constraintvector self, PySliceObject * slice) -> constraintvector
        __getitem__(constraintvector self, std::vector< constraint * >::difference_type i) -> constraint
        """
        return _sim3dlong.constraintvector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void" :
        """
        __setitem__(constraintvector self, PySliceObject * slice, constraintvector v)
        __setitem__(constraintvector self, PySliceObject * slice)
        __setitem__(constraintvector self, std::vector< constraint * >::difference_type i, constraint x)
        """
        return _sim3dlong.constraintvector___setitem__(self, *args)

    def append(self, *args) -> "void" :
        """append(constraintvector self, constraint x)"""
        return _sim3dlong.constraintvector_append(self, *args)

    def empty(self) -> "bool" :
        """empty(constraintvector self) -> bool"""
        return _sim3dlong.constraintvector_empty(self)

    def size(self) -> "std::vector< constraint * >::size_type" :
        """size(constraintvector self) -> std::vector< constraint * >::size_type"""
        return _sim3dlong.constraintvector_size(self)

    def clear(self) -> "void" :
        """clear(constraintvector self)"""
        return _sim3dlong.constraintvector_clear(self)

    def swap(self, *args) -> "void" :
        """swap(constraintvector self, constraintvector v)"""
        return _sim3dlong.constraintvector_swap(self, *args)

    def get_allocator(self) -> "std::vector< constraint * >::allocator_type" :
        """get_allocator(constraintvector self) -> std::vector< constraint * >::allocator_type"""
        return _sim3dlong.constraintvector_get_allocator(self)

    def begin(self) -> "std::vector< constraint * >::iterator" :
        """begin(constraintvector self) -> std::vector< constraint * >::iterator"""
        return _sim3dlong.constraintvector_begin(self)

    def end(self) -> "std::vector< constraint * >::iterator" :
        """end(constraintvector self) -> std::vector< constraint * >::iterator"""
        return _sim3dlong.constraintvector_end(self)

    def rbegin(self) -> "std::vector< constraint * >::reverse_iterator" :
        """rbegin(constraintvector self) -> std::vector< constraint * >::reverse_iterator"""
        return _sim3dlong.constraintvector_rbegin(self)

    def rend(self) -> "std::vector< constraint * >::reverse_iterator" :
        """rend(constraintvector self) -> std::vector< constraint * >::reverse_iterator"""
        return _sim3dlong.constraintvector_rend(self)

    def pop_back(self) -> "void" :
        """pop_back(constraintvector self)"""
        return _sim3dlong.constraintvector_pop_back(self)

    def erase(self, *args) -> "std::vector< constraint * >::iterator" :
        """
        erase(constraintvector self, std::vector< constraint * >::iterator pos) -> std::vector< constraint * >::iterator
        erase(constraintvector self, std::vector< constraint * >::iterator first, std::vector< constraint * >::iterator last) -> std::vector< constraint * >::iterator
        """
        return _sim3dlong.constraintvector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(p.constraint)> self) -> constraintvector
        __init__(std::vector<(p.constraint)> self, constraintvector arg2) -> constraintvector
        __init__(std::vector<(p.constraint)> self, std::vector< constraint * >::size_type size) -> constraintvector
        __init__(std::vector<(p.constraint)> self, std::vector< constraint * >::size_type size, constraint value) -> constraintvector
        """
        this = _sim3dlong.new_constraintvector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" :
        """push_back(constraintvector self, constraint x)"""
        return _sim3dlong.constraintvector_push_back(self, *args)

    def front(self) -> "std::vector< constraint * >::value_type" :
        """front(constraintvector self) -> constraint"""
        return _sim3dlong.constraintvector_front(self)

    def back(self) -> "std::vector< constraint * >::value_type" :
        """back(constraintvector self) -> constraint"""
        return _sim3dlong.constraintvector_back(self)

    def assign(self, *args) -> "void" :
        """assign(constraintvector self, std::vector< constraint * >::size_type n, constraint x)"""
        return _sim3dlong.constraintvector_assign(self, *args)

    def resize(self, *args) -> "void" :
        """
        resize(constraintvector self, std::vector< constraint * >::size_type new_size)
        resize(constraintvector self, std::vector< constraint * >::size_type new_size, constraint x)
        """
        return _sim3dlong.constraintvector_resize(self, *args)

    def insert(self, *args) -> "void" :
        """
        insert(constraintvector self, std::vector< constraint * >::iterator pos, constraint x) -> std::vector< constraint * >::iterator
        insert(constraintvector self, std::vector< constraint * >::iterator pos, std::vector< constraint * >::size_type n, 
            constraint x)
        """
        return _sim3dlong.constraintvector_insert(self, *args)

    def reserve(self, *args) -> "void" :
        """reserve(constraintvector self, std::vector< constraint * >::size_type n)"""
        return _sim3dlong.constraintvector_reserve(self, *args)

    def capacity(self) -> "std::vector< constraint * >::size_type" :
        """capacity(constraintvector self) -> std::vector< constraint * >::size_type"""
        return _sim3dlong.constraintvector_capacity(self)

    __swig_destroy__ = _sim3dlong.delete_constraintvector
    __del__ = lambda self : None;
constraintvector_swigregister = _sim3dlong.constraintvector_swigregister
constraintvector_swigregister(constraintvector)

class aRK4vector(_object):
    """Proxy of C++ std::vector<(p.atomvecRK4)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, aRK4vector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, aRK4vector, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" :
        """iterator(aRK4vector self) -> SwigPyIterator"""
        return _sim3dlong.aRK4vector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" :
        """__nonzero__(aRK4vector self) -> bool"""
        return _sim3dlong.aRK4vector___nonzero__(self)

    def __bool__(self) -> "bool" :
        """__bool__(aRK4vector self) -> bool"""
        return _sim3dlong.aRK4vector___bool__(self)

    def __len__(self) -> "std::vector< atomvecRK4 * >::size_type" :
        """__len__(aRK4vector self) -> std::vector< atomvecRK4 * >::size_type"""
        return _sim3dlong.aRK4vector___len__(self)

    def pop(self) -> "std::vector< atomvecRK4 * >::value_type" :
        """pop(aRK4vector self) -> atomvecRK4"""
        return _sim3dlong.aRK4vector_pop(self)

    def __getslice__(self, *args) -> "std::vector< atomvecRK4 *,std::allocator< atomvecRK4 * > > *" :
        """__getslice__(aRK4vector self, std::vector< atomvecRK4 * >::difference_type i, std::vector< atomvecRK4 * >::difference_type j) -> aRK4vector"""
        return _sim3dlong.aRK4vector___getslice__(self, *args)

    def __setslice__(self, *args) -> "void" :
        """
        __setslice__(aRK4vector self, std::vector< atomvecRK4 * >::difference_type i, std::vector< atomvecRK4 * >::difference_type j, 
            aRK4vector v=std::vector< atomvecRK4 *,std::allocator< atomvecRK4 * > >())
        __setslice__(aRK4vector self, std::vector< atomvecRK4 * >::difference_type i, std::vector< atomvecRK4 * >::difference_type j)
        """
        return _sim3dlong.aRK4vector___setslice__(self, *args)

    def __delslice__(self, *args) -> "void" :
        """__delslice__(aRK4vector self, std::vector< atomvecRK4 * >::difference_type i, std::vector< atomvecRK4 * >::difference_type j)"""
        return _sim3dlong.aRK4vector___delslice__(self, *args)

    def __delitem__(self, *args) -> "void" :
        """
        __delitem__(aRK4vector self, std::vector< atomvecRK4 * >::difference_type i)
        __delitem__(aRK4vector self, PySliceObject * slice)
        """
        return _sim3dlong.aRK4vector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< atomvecRK4 * >::value_type" :
        """
        __getitem__(aRK4vector self, PySliceObject * slice) -> aRK4vector
        __getitem__(aRK4vector self, std::vector< atomvecRK4 * >::difference_type i) -> atomvecRK4
        """
        return _sim3dlong.aRK4vector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void" :
        """
        __setitem__(aRK4vector self, PySliceObject * slice, aRK4vector v)
        __setitem__(aRK4vector self, PySliceObject * slice)
        __setitem__(aRK4vector self, std::vector< atomvecRK4 * >::difference_type i, atomvecRK4 x)
        """
        return _sim3dlong.aRK4vector___setitem__(self, *args)

    def append(self, *args) -> "void" :
        """append(aRK4vector self, atomvecRK4 x)"""
        return _sim3dlong.aRK4vector_append(self, *args)

    def empty(self) -> "bool" :
        """empty(aRK4vector self) -> bool"""
        return _sim3dlong.aRK4vector_empty(self)

    def size(self) -> "std::vector< atomvecRK4 * >::size_type" :
        """size(aRK4vector self) -> std::vector< atomvecRK4 * >::size_type"""
        return _sim3dlong.aRK4vector_size(self)

    def clear(self) -> "void" :
        """clear(aRK4vector self)"""
        return _sim3dlong.aRK4vector_clear(self)

    def swap(self, *args) -> "void" :
        """swap(aRK4vector self, aRK4vector v)"""
        return _sim3dlong.aRK4vector_swap(self, *args)

    def get_allocator(self) -> "std::vector< atomvecRK4 * >::allocator_type" :
        """get_allocator(aRK4vector self) -> std::vector< atomvecRK4 * >::allocator_type"""
        return _sim3dlong.aRK4vector_get_allocator(self)

    def begin(self) -> "std::vector< atomvecRK4 * >::iterator" :
        """begin(aRK4vector self) -> std::vector< atomvecRK4 * >::iterator"""
        return _sim3dlong.aRK4vector_begin(self)

    def end(self) -> "std::vector< atomvecRK4 * >::iterator" :
        """end(aRK4vector self) -> std::vector< atomvecRK4 * >::iterator"""
        return _sim3dlong.aRK4vector_end(self)

    def rbegin(self) -> "std::vector< atomvecRK4 * >::reverse_iterator" :
        """rbegin(aRK4vector self) -> std::vector< atomvecRK4 * >::reverse_iterator"""
        return _sim3dlong.aRK4vector_rbegin(self)

    def rend(self) -> "std::vector< atomvecRK4 * >::reverse_iterator" :
        """rend(aRK4vector self) -> std::vector< atomvecRK4 * >::reverse_iterator"""
        return _sim3dlong.aRK4vector_rend(self)

    def pop_back(self) -> "void" :
        """pop_back(aRK4vector self)"""
        return _sim3dlong.aRK4vector_pop_back(self)

    def erase(self, *args) -> "std::vector< atomvecRK4 * >::iterator" :
        """
        erase(aRK4vector self, std::vector< atomvecRK4 * >::iterator pos) -> std::vector< atomvecRK4 * >::iterator
        erase(aRK4vector self, std::vector< atomvecRK4 * >::iterator first, std::vector< atomvecRK4 * >::iterator last) -> std::vector< atomvecRK4 * >::iterator
        """
        return _sim3dlong.aRK4vector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(p.atomvecRK4)> self) -> aRK4vector
        __init__(std::vector<(p.atomvecRK4)> self, aRK4vector arg2) -> aRK4vector
        __init__(std::vector<(p.atomvecRK4)> self, std::vector< atomvecRK4 * >::size_type size) -> aRK4vector
        __init__(std::vector<(p.atomvecRK4)> self, std::vector< atomvecRK4 * >::size_type size, atomvecRK4 value) -> aRK4vector
        """
        this = _sim3dlong.new_aRK4vector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" :
        """push_back(aRK4vector self, atomvecRK4 x)"""
        return _sim3dlong.aRK4vector_push_back(self, *args)

    def front(self) -> "std::vector< atomvecRK4 * >::value_type" :
        """front(aRK4vector self) -> atomvecRK4"""
        return _sim3dlong.aRK4vector_front(self)

    def back(self) -> "std::vector< atomvecRK4 * >::value_type" :
        """back(aRK4vector self) -> atomvecRK4"""
        return _sim3dlong.aRK4vector_back(self)

    def assign(self, *args) -> "void" :
        """assign(aRK4vector self, std::vector< atomvecRK4 * >::size_type n, atomvecRK4 x)"""
        return _sim3dlong.aRK4vector_assign(self, *args)

    def resize(self, *args) -> "void" :
        """
        resize(aRK4vector self, std::vector< atomvecRK4 * >::size_type new_size)
        resize(aRK4vector self, std::vector< atomvecRK4 * >::size_type new_size, atomvecRK4 x)
        """
        return _sim3dlong.aRK4vector_resize(self, *args)

    def insert(self, *args) -> "void" :
        """
        insert(aRK4vector self, std::vector< atomvecRK4 * >::iterator pos, atomvecRK4 x) -> std::vector< atomvecRK4 * >::iterator
        insert(aRK4vector self, std::vector< atomvecRK4 * >::iterator pos, std::vector< atomvecRK4 * >::size_type n, 
            atomvecRK4 x)
        """
        return _sim3dlong.aRK4vector_insert(self, *args)

    def reserve(self, *args) -> "void" :
        """reserve(aRK4vector self, std::vector< atomvecRK4 * >::size_type n)"""
        return _sim3dlong.aRK4vector_reserve(self, *args)

    def capacity(self) -> "std::vector< atomvecRK4 * >::size_type" :
        """capacity(aRK4vector self) -> std::vector< atomvecRK4 * >::size_type"""
        return _sim3dlong.aRK4vector_capacity(self)

    __swig_destroy__ = _sim3dlong.delete_aRK4vector
    __del__ = lambda self : None;
aRK4vector_swigregister = _sim3dlong.aRK4vector_swigregister
aRK4vector_swigregister(aRK4vector)

class _uintvector(collections.MutableSequence):
    """Proxy of C++ std::vector<(unsigned int)> class"""
    __swig_setmethods__ = {}
    for _s in [collections.MutableSequence]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, _uintvector, name, value)
    __swig_getmethods__ = {}
    for _s in [collections.MutableSequence]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, _uintvector, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" :
        """iterator(_uintvector self) -> SwigPyIterator"""
        return _sim3dlong._uintvector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" :
        """__nonzero__(_uintvector self) -> bool"""
        return _sim3dlong._uintvector___nonzero__(self)

    def __bool__(self) -> "bool" :
        """__bool__(_uintvector self) -> bool"""
        return _sim3dlong._uintvector___bool__(self)

    def __len__(self) -> "std::vector< unsigned int >::size_type" :
        """__len__(_uintvector self) -> std::vector< unsigned int >::size_type"""
        return _sim3dlong._uintvector___len__(self)

    def pop(self) -> "std::vector< unsigned int >::value_type" :
        """pop(_uintvector self) -> std::vector< unsigned int >::value_type"""
        return _sim3dlong._uintvector_pop(self)

    def __getslice__(self, *args) -> "std::vector< unsigned int,std::allocator< unsigned int > > *" :
        """__getslice__(_uintvector self, std::vector< unsigned int >::difference_type i, std::vector< unsigned int >::difference_type j) -> _uintvector"""
        return _sim3dlong._uintvector___getslice__(self, *args)

    def __setslice__(self, *args) -> "void" :
        """
        __setslice__(_uintvector self, std::vector< unsigned int >::difference_type i, std::vector< unsigned int >::difference_type j, 
            _uintvector v=std::vector< unsigned int,std::allocator< unsigned int > >())
        __setslice__(_uintvector self, std::vector< unsigned int >::difference_type i, std::vector< unsigned int >::difference_type j)
        """
        return _sim3dlong._uintvector___setslice__(self, *args)

    def __delslice__(self, *args) -> "void" :
        """__delslice__(_uintvector self, std::vector< unsigned int >::difference_type i, std::vector< unsigned int >::difference_type j)"""
        return _sim3dlong._uintvector___delslice__(self, *args)

    def __delitem__(self, *args) -> "void" :
        """
        __delitem__(_uintvector self, std::vector< unsigned int >::difference_type i)
        __delitem__(_uintvector self, PySliceObject * slice)
        """
        return _sim3dlong._uintvector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< unsigned int >::value_type const &" :
        """
        __getitem__(_uintvector self, PySliceObject * slice) -> _uintvector
        __getitem__(_uintvector self, std::vector< unsigned int >::difference_type i) -> std::vector< unsigned int >::value_type const &
        """
        return _sim3dlong._uintvector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void" :
        """
        __setitem__(_uintvector self, PySliceObject * slice, _uintvector v)
        __setitem__(_uintvector self, PySliceObject * slice)
        __setitem__(_uintvector self, std::vector< unsigned int >::difference_type i, std::vector< unsigned int >::value_type const & x)
        """
        return _sim3dlong._uintvector___setitem__(self, *args)

    def append(self, *args) -> "void" :
        """append(_uintvector self, std::vector< unsigned int >::value_type const & x)"""
        return _sim3dlong._uintvector_append(self, *args)

    def empty(self) -> "bool" :
        """empty(_uintvector self) -> bool"""
        return _sim3dlong._uintvector_empty(self)

    def size(self) -> "std::vector< unsigned int >::size_type" :
        """size(_uintvector self) -> std::vector< unsigned int >::size_type"""
        return _sim3dlong._uintvector_size(self)

    def clear(self) -> "void" :
        """clear(_uintvector self)"""
        return _sim3dlong._uintvector_clear(self)

    def swap(self, *args) -> "void" :
        """swap(_uintvector self, _uintvector v)"""
        return _sim3dlong._uintvector_swap(self, *args)

    def get_allocator(self) -> "std::vector< unsigned int >::allocator_type" :
        """get_allocator(_uintvector self) -> std::vector< unsigned int >::allocator_type"""
        return _sim3dlong._uintvector_get_allocator(self)

    def begin(self) -> "std::vector< unsigned int >::iterator" :
        """begin(_uintvector self) -> std::vector< unsigned int >::iterator"""
        return _sim3dlong._uintvector_begin(self)

    def end(self) -> "std::vector< unsigned int >::iterator" :
        """end(_uintvector self) -> std::vector< unsigned int >::iterator"""
        return _sim3dlong._uintvector_end(self)

    def rbegin(self) -> "std::vector< unsigned int >::reverse_iterator" :
        """rbegin(_uintvector self) -> std::vector< unsigned int >::reverse_iterator"""
        return _sim3dlong._uintvector_rbegin(self)

    def rend(self) -> "std::vector< unsigned int >::reverse_iterator" :
        """rend(_uintvector self) -> std::vector< unsigned int >::reverse_iterator"""
        return _sim3dlong._uintvector_rend(self)

    def pop_back(self) -> "void" :
        """pop_back(_uintvector self)"""
        return _sim3dlong._uintvector_pop_back(self)

    def erase(self, *args) -> "std::vector< unsigned int >::iterator" :
        """
        erase(_uintvector self, std::vector< unsigned int >::iterator pos) -> std::vector< unsigned int >::iterator
        erase(_uintvector self, std::vector< unsigned int >::iterator first, std::vector< unsigned int >::iterator last) -> std::vector< unsigned int >::iterator
        """
        return _sim3dlong._uintvector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(unsigned int)> self) -> _uintvector
        __init__(std::vector<(unsigned int)> self, _uintvector arg2) -> _uintvector
        __init__(std::vector<(unsigned int)> self, std::vector< unsigned int >::size_type size) -> _uintvector
        __init__(std::vector<(unsigned int)> self, std::vector< unsigned int >::size_type size, std::vector< unsigned int >::value_type const & value) -> _uintvector
        """
        this = _sim3dlong.new__uintvector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" :
        """push_back(_uintvector self, std::vector< unsigned int >::value_type const & x)"""
        return _sim3dlong._uintvector_push_back(self, *args)

    def front(self) -> "std::vector< unsigned int >::value_type const &" :
        """front(_uintvector self) -> std::vector< unsigned int >::value_type const &"""
        return _sim3dlong._uintvector_front(self)

    def back(self) -> "std::vector< unsigned int >::value_type const &" :
        """back(_uintvector self) -> std::vector< unsigned int >::value_type const &"""
        return _sim3dlong._uintvector_back(self)

    def assign(self, *args) -> "void" :
        """assign(_uintvector self, std::vector< unsigned int >::size_type n, std::vector< unsigned int >::value_type const & x)"""
        return _sim3dlong._uintvector_assign(self, *args)

    def resize(self, *args) -> "void" :
        """
        resize(_uintvector self, std::vector< unsigned int >::size_type new_size)
        resize(_uintvector self, std::vector< unsigned int >::size_type new_size, std::vector< unsigned int >::value_type const & x)
        """
        return _sim3dlong._uintvector_resize(self, *args)

    def insert(self, *args) -> "void" :
        """
        insert(_uintvector self, std::vector< unsigned int >::iterator pos, std::vector< unsigned int >::value_type const & x) -> std::vector< unsigned int >::iterator
        insert(_uintvector self, std::vector< unsigned int >::iterator pos, std::vector< unsigned int >::size_type n, 
            std::vector< unsigned int >::value_type const & x)
        """
        return _sim3dlong._uintvector_insert(self, *args)

    def reserve(self, *args) -> "void" :
        """reserve(_uintvector self, std::vector< unsigned int >::size_type n)"""
        return _sim3dlong._uintvector_reserve(self, *args)

    def capacity(self) -> "std::vector< unsigned int >::size_type" :
        """capacity(_uintvector self) -> std::vector< unsigned int >::size_type"""
        return _sim3dlong._uintvector_capacity(self)

    __swig_destroy__ = _sim3dlong.delete__uintvector
    __del__ = lambda self : None;
_uintvector_swigregister = _sim3dlong._uintvector_swigregister
_uintvector_swigregister(_uintvector)

NDIM = _sim3dlong.NDIM

def toLD(*args) -> "long double" :
  """toLD(double e) -> long double"""
  return _sim3dlong.toLD(*args)

def fromLD(*args) -> "double" :
  """fromLD(long double e) -> double"""
  return _sim3dlong.fromLD(*args)

def LDVector(*args) -> "std::vector< flt,std::allocator< flt > >" :
  """LDVector(dvector dists) -> ldvector"""
  return _sim3dlong.LDVector(*args)

def isinfflt(*args) -> "bool" :
  """isinfflt(long double n) -> bool"""
  return _sim3dlong.isinfflt(*args)

def isnanflt(*args) -> "bool" :
  """isnanflt(long double n) -> bool"""
  return _sim3dlong.isnanflt(*args)

def powflt(*args) -> "flt" :
  """powflt(flt n, flt m) -> flt"""
  return _sim3dlong.powflt(*args)

def sqrtflt(*args) -> "flt" :
  """sqrtflt(flt n) -> flt"""
  return _sim3dlong.sqrtflt(*args)

def cbrtflt(*args) -> "flt" :
  """cbrtflt(flt n) -> flt"""
  return _sim3dlong.cbrtflt(*args)

def expm1flt(*args) -> "flt" :
  """expm1flt(flt n) -> flt"""
  return _sim3dlong.expm1flt(*args)

def vec(*args) -> "Vector3< flt >" :
  """
    vec(double x, double y) -> Vector2< flt >
    vec(double x, double y, double z) -> VecL
    """
  return _sim3dlong.vec(*args)

def vecsize() -> "uint" :
  """vecsize() -> uint"""
  return _sim3dlong.vecsize()

def randVec() -> "Vec" :
  """randVec() -> VecL"""
  return _sim3dlong.randVec()

def randVecBoxed() -> "Vec" :
  """randVecBoxed() -> VecL"""
  return _sim3dlong.randVecBoxed()

def seed(*args) -> "unsigned int" :
  """
    seed(unsigned int n) -> unsigned int
    seed() -> unsigned int
    """
  return _sim3dlong.seed(*args)
class gaussVec(_object):
    """Proxy of C++ gaussVec class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, gaussVec, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, gaussVec, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(gaussVec self, flt sigma) -> gaussVec"""
        this = _sim3dlong.new_gaussVec(*args)
        try: self.this.append(this)
        except: self.this = this
    def set(self, *args) -> "void" :
        """set(gaussVec self, flt sigma)"""
        return _sim3dlong.gaussVec_set(self, *args)

    def generate(self) -> "Vec" :
        """generate(gaussVec self) -> VecL"""
        return _sim3dlong.gaussVec_generate(self)

    __swig_destroy__ = _sim3dlong.delete_gaussVec
    __del__ = lambda self : None;
gaussVec_swigregister = _sim3dlong.gaussVec_swigregister
gaussVec_swigregister(gaussVec)
cvar = _sim3dlong.cvar
OVERNDIM = cvar.OVERNDIM

class bivariateGauss(_object):
    """Proxy of C++ bivariateGauss class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, bivariateGauss, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, bivariateGauss, name)
    __repr__ = _swig_repr
    def __init__(self, s1 : 'flt const'=1, s2 : 'flt const'=1, corr : 'flt const'=0): 
        """
        __init__(bivariateGauss self, flt const s1=1, flt const s2=1, flt const corr=0) -> bivariateGauss
        __init__(bivariateGauss self, flt const s1=1, flt const s2=1) -> bivariateGauss
        __init__(bivariateGauss self, flt const s1=1) -> bivariateGauss
        __init__(bivariateGauss self) -> bivariateGauss
        """
        this = _sim3dlong.new_bivariateGauss(s1, s2, corr)
        try: self.this.append(this)
        except: self.this = this
    def set(self, *args) -> "void" :
        """set(bivariateGauss self, flt const s1, flt const s2, flt const corr)"""
        return _sim3dlong.bivariateGauss_set(self, *args)

    def generate(self) -> "Pair" :
        """generate(bivariateGauss self) -> _Numvector2L"""
        return _sim3dlong.bivariateGauss_generate(self)

    def genVec(self) -> "Vec" :
        """genVec(bivariateGauss self) -> VecL"""
        return _sim3dlong.bivariateGauss_genVec(self)

    def genVecs(self) -> "VecPair" :
        """genVecs(bivariateGauss self) -> VecPair"""
        return _sim3dlong.bivariateGauss_genVecs(self)

    __swig_destroy__ = _sim3dlong.delete_bivariateGauss
    __del__ = lambda self : None;
bivariateGauss_swigregister = _sim3dlong.bivariateGauss_swigregister
bivariateGauss_swigregister(bivariateGauss)

class Box(_object):
    """Proxy of C++ Box class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Box, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Box, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def diff(self, *args) -> "Vec" :
        """diff(Box self, VecL r1, VecL r2) -> VecL"""
        return _sim3dlong.Box_diff(self, *args)

    def V(self) -> "flt" :
        """V(Box self) -> flt"""
        return _sim3dlong.Box_V(self)

    __swig_destroy__ = _sim3dlong.delete_Box
    __del__ = lambda self : None;
Box_swigregister = _sim3dlong.Box_swigregister
Box_swigregister(Box)

class interaction(_object):
    """Proxy of C++ interaction class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, interaction, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, interaction, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def energy(self, *args) -> "flt" :
        """energy(interaction self, Box box) -> flt"""
        return _sim3dlong.interaction_energy(self, *args)

    def setForces(self, *args) -> "void" :
        """setForces(interaction self, Box box)"""
        return _sim3dlong.interaction_setForces(self, *args)

    def setForcesGetPressure(self, *args) -> "flt" :
        """setForcesGetPressure(interaction self, Box box) -> flt"""
        return _sim3dlong.interaction_setForcesGetPressure(self, *args)

    def pressure(self, *args) -> "flt" :
        """pressure(interaction self, Box box) -> flt"""
        return _sim3dlong.interaction_pressure(self, *args)

    __swig_destroy__ = _sim3dlong.delete_interaction
    __del__ = lambda self : None;
interaction_swigregister = _sim3dlong.interaction_swigregister
interaction_swigregister(interaction)

class statetracker(_object):
    """Proxy of C++ statetracker class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, statetracker, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, statetracker, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def update(self, *args) -> "void" :
        """update(statetracker self, Box box)"""
        return _sim3dlong.statetracker_update(self, *args)

    __swig_destroy__ = _sim3dlong.delete_statetracker
    __del__ = lambda self : None;
statetracker_swigregister = _sim3dlong.statetracker_swigregister
statetracker_swigregister(statetracker)


def vecmod(*args) -> "Vec" :
  """vecmod(VecL r1, VecL r2) -> VecL"""
  return _sim3dlong.vecmod(*args)
class InfiniteBox(Box):
    """Proxy of C++ InfiniteBox class"""
    __swig_setmethods__ = {}
    for _s in [Box]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, InfiniteBox, name, value)
    __swig_getmethods__ = {}
    for _s in [Box]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, InfiniteBox, name)
    __repr__ = _swig_repr
    def diff(self, *args) -> "Vec" :
        """diff(InfiniteBox self, VecL r1, VecL r2) -> VecL"""
        return _sim3dlong.InfiniteBox_diff(self, *args)

    def V(self) -> "flt" :
        """V(InfiniteBox self) -> flt"""
        return _sim3dlong.InfiniteBox_V(self)

    def __init__(self): 
        """__init__(InfiniteBox self) -> InfiniteBox"""
        this = _sim3dlong.new_InfiniteBox()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _sim3dlong.delete_InfiniteBox
    __del__ = lambda self : None;
InfiniteBox_swigregister = _sim3dlong.InfiniteBox_swigregister
InfiniteBox_swigregister(InfiniteBox)

class OriginBox(Box):
    """Proxy of C++ OriginBox class"""
    __swig_setmethods__ = {}
    for _s in [Box]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, OriginBox, name, value)
    __swig_getmethods__ = {}
    for _s in [Box]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, OriginBox, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(OriginBox self, VecL size) -> OriginBox"""
        this = _sim3dlong.new_OriginBox(*args)
        try: self.this.append(this)
        except: self.this = this
    def diff(self, *args) -> "Vec" :
        """diff(OriginBox self, VecL r1, VecL r2) -> VecL"""
        return _sim3dlong.OriginBox_diff(self, *args)

    def V(self) -> "flt" :
        """V(OriginBox self) -> flt"""
        return _sim3dlong.OriginBox_V(self)

    def L(self) -> "flt" :
        """L(OriginBox self) -> flt"""
        return _sim3dlong.OriginBox_L(self)

    def resize(self, *args) -> "flt" :
        """resize(OriginBox self, flt factor) -> flt"""
        return _sim3dlong.OriginBox_resize(self, *args)

    def resizeV(self, *args) -> "flt" :
        """resizeV(OriginBox self, flt newV) -> flt"""
        return _sim3dlong.OriginBox_resizeV(self, *args)

    def randLoc(self) -> "Vec" :
        """randLoc(OriginBox self) -> VecL"""
        return _sim3dlong.OriginBox_randLoc(self)

    __swig_destroy__ = _sim3dlong.delete_OriginBox
    __del__ = lambda self : None;
OriginBox_swigregister = _sim3dlong.OriginBox_swigregister
OriginBox_swigregister(OriginBox)

class atom(_object):
    """Proxy of C++ atom class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, atom, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, atom, name)
    __repr__ = _swig_repr
    __swig_setmethods__["x"] = _sim3dlong.atom_x_set
    __swig_getmethods__["x"] = _sim3dlong.atom_x_get
    if _newclass:x = _swig_property(_sim3dlong.atom_x_get, _sim3dlong.atom_x_set)
    __swig_setmethods__["v"] = _sim3dlong.atom_v_set
    __swig_getmethods__["v"] = _sim3dlong.atom_v_get
    if _newclass:v = _swig_property(_sim3dlong.atom_v_get, _sim3dlong.atom_v_set)
    __swig_setmethods__["a"] = _sim3dlong.atom_a_set
    __swig_getmethods__["a"] = _sim3dlong.atom_a_get
    if _newclass:a = _swig_property(_sim3dlong.atom_a_get, _sim3dlong.atom_a_set)
    __swig_setmethods__["f"] = _sim3dlong.atom_f_set
    __swig_getmethods__["f"] = _sim3dlong.atom_f_get
    if _newclass:f = _swig_property(_sim3dlong.atom_f_get, _sim3dlong.atom_f_set)
    __swig_setmethods__["m"] = _sim3dlong.atom_m_set
    __swig_getmethods__["m"] = _sim3dlong.atom_m_get
    if _newclass:m = _swig_property(_sim3dlong.atom_m_get, _sim3dlong.atom_m_set)
    def __getstate__(self):
        return (tuple(self.x),tuple(self.v),tuple(self.f), tuple(self.a))

    def __setstate__(self, lst):
        self.x, self.v, self.f, self.a = [Vec(*r) for r in lst]

    def __str__(self):
        if hasattr(self, 'name'):
            return "<atom %s>" % self.name
        return "<atom>"

    def __repr__(self):
        #ifdef VEC2D
        x,y = tuple(self.x)
        if hasattr(self, 'name'):
            return "<atom %s at (%.2f,%.2f)>" % (self.name,x,y)
        return "<atom at (%.2f,%.2f)>" % (x,y)
        #else
        x,y,z = tuple(self.x)
        if hasattr(self, 'name'):
            return "<atom %s at (%.2f,%.2f,%.2f)>" % (self.name,x,y,z)
        return "<atom at (%.2f,%.2f,%.2f)>" % (x,y,z)
        #endif

    def __init__(self): 
        """__init__(atom self) -> atom"""
        this = _sim3dlong.new_atom()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _sim3dlong.delete_atom
    __del__ = lambda self : None;
atom_swigregister = _sim3dlong.atom_swigregister
atom_swigregister(atom)

class atomref(_object):
    """Proxy of C++ atomref class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, atomref, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, atomref, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(atomref self) -> atomref
        __init__(atomref self, atom a) -> atomref
        """
        this = _sim3dlong.new_atomref(*args)
        try: self.this.append(this)
        except: self.this = this
    def __ref__(self) -> "atom &" :
        """__ref__(atomref self) -> atom"""
        return _sim3dlong.atomref___ref__(self)

    def pointer(self) -> "atom *" :
        """pointer(atomref self) -> atom"""
        return _sim3dlong.atomref_pointer(self)

    def x(self) -> "Vec &" :
        """x(atomref self) -> VecL"""
        return _sim3dlong.atomref_x(self)

    def v(self) -> "Vec &" :
        """v(atomref self) -> VecL"""
        return _sim3dlong.atomref_v(self)

    def f(self) -> "Vec &" :
        """f(atomref self) -> VecL"""
        return _sim3dlong.atomref_f(self)

    def a(self) -> "Vec &" :
        """a(atomref self) -> VecL"""
        return _sim3dlong.atomref_a(self)

    def m(self) -> "flt &" :
        """m(atomref self) -> flt &"""
        return _sim3dlong.atomref_m(self)

    def __eq__(self, *args) -> "bool" :
        """
        __eq__(atomref self, atomref other) -> bool
        __eq__(atomref self, atom other) -> bool
        """
        return _sim3dlong.atomref___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        """__ne__(atomref self, atomref other) -> bool"""
        return _sim3dlong.atomref___ne__(self, *args)

    def __lt__(self, *args) -> "bool" :
        """__lt__(atomref self, atomref other) -> bool"""
        return _sim3dlong.atomref___lt__(self, *args)

    def __le__(self, *args) -> "bool" :
        """__le__(atomref self, atomref other) -> bool"""
        return _sim3dlong.atomref___le__(self, *args)

    def __ge__(self, *args) -> "bool" :
        """__ge__(atomref self, atomref other) -> bool"""
        return _sim3dlong.atomref___ge__(self, *args)

    def __gt__(self, *args) -> "bool" :
        """__gt__(atomref self, atomref other) -> bool"""
        return _sim3dlong.atomref___gt__(self, *args)

    __swig_destroy__ = _sim3dlong.delete_atomref
    __del__ = lambda self : None;
atomref_swigregister = _sim3dlong.atomref_swigregister
atomref_swigregister(atomref)

class atomid(atomref):
    """Proxy of C++ atomid class"""
    __swig_setmethods__ = {}
    for _s in [atomref]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, atomid, name, value)
    __swig_getmethods__ = {}
    for _s in [atomref]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, atomid, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(atomid self) -> atomid
        __init__(atomid self, atom a) -> atomid
        __init__(atomid self, atom a, uint n) -> atomid
        """
        this = _sim3dlong.new_atomid(*args)
        try: self.this.append(this)
        except: self.this = this
    def n(self) -> "uint" :
        """n(atomid self) -> uint"""
        return _sim3dlong.atomid_n(self)

    __swig_destroy__ = _sim3dlong.delete_atomid
    __del__ = lambda self : None;
atomid_swigregister = _sim3dlong.atomid_swigregister
atomid_swigregister(atomid)

class idpair(_idarray2):
    """Proxy of C++ idpair class"""
    __swig_setmethods__ = {}
    for _s in [_idarray2]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, idpair, name, value)
    __swig_getmethods__ = {}
    for _s in [_idarray2]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, idpair, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(idpair self, atomid a, atomid b) -> idpair"""
        this = _sim3dlong.new_idpair(*args)
        try: self.this.append(this)
        except: self.this = this
    def first(self) -> "atomid" :
        """first(idpair self) -> atomid"""
        return _sim3dlong.idpair_first(self)

    def last(self) -> "atomid" :
        """last(idpair self) -> atomid"""
        return _sim3dlong.idpair_last(self)

    __swig_destroy__ = _sim3dlong.delete_idpair
    __del__ = lambda self : None;
idpair_swigregister = _sim3dlong.idpair_swigregister
idpair_swigregister(idpair)

class atompair(_atomarray2):
    """Proxy of C++ atompair class"""
    __swig_setmethods__ = {}
    for _s in [_atomarray2]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, atompair, name, value)
    __swig_getmethods__ = {}
    for _s in [_atomarray2]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, atompair, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(atompair self, atom a, atom b) -> atompair"""
        this = _sim3dlong.new_atompair(*args)
        try: self.this.append(this)
        except: self.this = this
    def first(self) -> "atom &" :
        """first(atompair self) -> atom"""
        return _sim3dlong.atompair_first(self)

    def last(self) -> "atom &" :
        """last(atompair self) -> atom"""
        return _sim3dlong.atompair_last(self)

    __swig_destroy__ = _sim3dlong.delete_atompair
    __del__ = lambda self : None;
atompair_swigregister = _sim3dlong.atompair_swigregister
atompair_swigregister(atompair)

class atomgroup(_object):
    """Proxy of C++ atomgroup class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, atomgroup, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, atomgroup, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def get(self, *args) -> "atom *" :
        """get(atomgroup self, cuint n) -> atom"""
        return _sim3dlong.atomgroup_get(self, *args)

    def get_id(self, *args) -> "atomid" :
        """get_id(atomgroup self, cuint n) -> atomid"""
        return _sim3dlong.atomgroup_get_id(self, *args)

    def size(self) -> "uint" :
        """size(atomgroup self) -> uint"""
        return _sim3dlong.atomgroup_size(self)

    def getmass(self, *args) -> "flt" :
        """getmass(atomgroup self, unsigned int const n) -> flt"""
        return _sim3dlong.atomgroup_getmass(self, *args)

    def com(self) -> "Vec" :
        """com(atomgroup self) -> VecL"""
        return _sim3dlong.atomgroup_com(self)

    def comv(self) -> "Vec" :
        """comv(atomgroup self) -> VecL"""
        return _sim3dlong.atomgroup_comv(self)

    def mass(self) -> "flt" :
        """mass(atomgroup self) -> flt"""
        return _sim3dlong.atomgroup_mass(self)

    def kinetic(self, *args) -> "flt" :
        """
        kinetic(atomgroup self, VecL originvelocity=Vec()) -> flt
        kinetic(atomgroup self) -> flt
        """
        return _sim3dlong.atomgroup_kinetic(self, *args)

    def momentum(self) -> "Vec" :
        """momentum(atomgroup self) -> VecL"""
        return _sim3dlong.atomgroup_momentum(self)

    def angmomentum(self, *args) -> "Vec" :
        """angmomentum(atomgroup self, VecL loc, Box box) -> VecL"""
        return _sim3dlong.atomgroup_angmomentum(self, *args)

    def moment(self, *args) -> "Matrix< flt >" :
        """
        moment(atomgroup self, VecL loc, VecL axis, Box box) -> flt
        moment(atomgroup self, VecL loc, Box box) -> Matrix< flt >
        """
        return _sim3dlong.atomgroup_moment(self, *args)

    def omega(self, *args) -> "Vec" :
        """omega(atomgroup self, VecL loc, Box box) -> VecL"""
        return _sim3dlong.atomgroup_omega(self, *args)

    def addOmega(self, *args) -> "void" :
        """addOmega(atomgroup self, VecL w, VecL origin, Box box)"""
        return _sim3dlong.atomgroup_addOmega(self, *args)

    def resetL(self, *args) -> "void" :
        """resetL(atomgroup self, Box box)"""
        return _sim3dlong.atomgroup_resetL(self, *args)

    def addv(self, *args) -> "void" :
        """addv(atomgroup self, VecL v)"""
        return _sim3dlong.atomgroup_addv(self, *args)

    def resetcomv(self) -> "void" :
        """resetcomv(atomgroup self)"""
        return _sim3dlong.atomgroup_resetcomv(self)

    def resetForces(self) -> "void" :
        """resetForces(atomgroup self)"""
        return _sim3dlong.atomgroup_resetForces(self)

    def setAccel(self) -> "void" :
        """setAccel(atomgroup self)"""
        return _sim3dlong.atomgroup_setAccel(self)

    __swig_destroy__ = _sim3dlong.delete_atomgroup
    __del__ = lambda self : None;
    def __iter__(self):
        for i in range(self.size()):
            yield self.get(i)

atomgroup_swigregister = _sim3dlong.atomgroup_swigregister
atomgroup_swigregister(atomgroup)

class atomvec(atomgroup):
    """Proxy of C++ atomvec class"""
    __swig_setmethods__ = {}
    for _s in [atomgroup]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, atomvec, name, value)
    __swig_getmethods__ = {}
    for _s in [atomgroup]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, atomvec, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(atomvec self, dvector masses) -> atomvec
        __init__(atomvec self, uint N, flt mass) -> atomvec
        __init__(atomvec self, atomvec other) -> atomvec
        """
        this = _sim3dlong.new_atomvec(*args)
        try: self.this.append(this)
        except: self.this = this
    def get_id(self, *args) -> "atomid" :
        """
        get_id(atomvec self, atom a) -> atomid
        get_id(atomvec self, uint n) -> atomid
        """
        return _sim3dlong.atomvec_get_id(self, *args)

    def size(self) -> "uint" :
        """size(atomvec self) -> uint"""
        return _sim3dlong.atomvec_size(self)

    __swig_destroy__ = _sim3dlong.delete_atomvec
    __del__ = lambda self : None;
    def __iter__(self):
        for i in range(self.size()):
            yield self[i]

    def __len__(self):
        return self.size()

    def __getitem__(self, obj):
        return self.get(obj)

    def __setitem__(self, obj, val):
        return self.set(obj, val)

    def __getstate__(self):
        return ([self.getmass(i) for i in range(self.N())],
                    [a.__getstate__() for a in self])

    def __setstate__(self, lst):
        masses, atomstates = lst
        self.__init__(fvector(masses))
        for i, atomstate in enumerate(atomstates):
            #~ print "i:",i
            a = self.get(i)
            a.__setstate__(atomstate)

atomvec_swigregister = _sim3dlong.atomvec_swigregister
atomvec_swigregister(atomvec)

class metagroup(atomgroup):
    """Proxy of C++ metagroup class"""
    __swig_setmethods__ = {}
    for _s in [atomgroup]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, metagroup, name, value)
    __swig_getmethods__ = {}
    for _s in [atomgroup]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, metagroup, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(metagroup self) -> metagroup
        __init__(metagroup self, avector arg2) -> metagroup
        """
        this = _sim3dlong.new_metagroup(*args)
        try: self.this.append(this)
        except: self.this = this
    def get(self, *args) -> "atom *" :
        """get(metagroup self, cuint n) -> atom"""
        return _sim3dlong.metagroup_get(self, *args)

    def add(self, *args) -> "void" :
        """add(metagroup self, atom a)"""
        return _sim3dlong.metagroup_add(self, *args)

    def get_id(self, *args) -> "atomid" :
        """
        get_id(metagroup self, atom a) -> atomid
        get_id(metagroup self, uint n) -> atomid
        """
        return _sim3dlong.metagroup_get_id(self, *args)

    def size(self) -> "uint" :
        """size(metagroup self) -> uint"""
        return _sim3dlong.metagroup_size(self)

    __swig_destroy__ = _sim3dlong.delete_metagroup
    __del__ = lambda self : None;
metagroup_swigregister = _sim3dlong.metagroup_swigregister
metagroup_swigregister(metagroup)

class interactpair(_object):
    """Proxy of C++ interactpair class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, interactpair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, interactpair, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def energy(self, *args) -> "flt" :
        """energy(interactpair self, VecL diff) -> flt"""
        return _sim3dlong.interactpair_energy(self, *args)

    def forces(self, *args) -> "Vec" :
        """forces(interactpair self, VecL diff) -> VecL"""
        return _sim3dlong.interactpair_forces(self, *args)

    __swig_destroy__ = _sim3dlong.delete_interactpair
    __del__ = lambda self : None;
interactpair_swigregister = _sim3dlong.interactpair_swigregister
interactpair_swigregister(interactpair)

class LJrepulsive(_object):
    """Proxy of C++ LJrepulsive class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJrepulsive, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LJrepulsive, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(LJrepulsive self, flt const epsilon, flt const sigma) -> LJrepulsive"""
        this = _sim3dlong.new_LJrepulsive(*args)
        try: self.this.append(this)
        except: self.this = this
    def energy(self, *args) -> "flt" :
        """
        energy(LJrepulsive self, VecL diff, flt const eps, flt const sig) -> flt
        energy(LJrepulsive self, VecL diff) -> flt
        """
        return _sim3dlong.LJrepulsive_energy(self, *args)

    def forces(self, *args) -> "Vec" :
        """
        forces(LJrepulsive self, VecL diff, flt const eps, flt const sig) -> VecL
        forces(LJrepulsive self, VecL diff) -> VecL
        """
        return _sim3dlong.LJrepulsive_forces(self, *args)

    __swig_destroy__ = _sim3dlong.delete_LJrepulsive
    __del__ = lambda self : None;
LJrepulsive_swigregister = _sim3dlong.LJrepulsive_swigregister
LJrepulsive_swigregister(LJrepulsive)
LJr0 = cvar.LJr0
LJr0sq = cvar.LJr0sq

class LJattract(_object):
    """Proxy of C++ LJattract class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJattract, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LJattract, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(LJattract self, flt const epsilon, flt const sigma) -> LJattract"""
        this = _sim3dlong.new_LJattract(*args)
        try: self.this.append(this)
        except: self.this = this
    def energy(self, *args) -> "flt" :
        """
        energy(LJattract self, VecL diff, flt const eps, flt const sig) -> flt
        energy(LJattract self, flt const rsig) -> flt
        energy(LJattract self, VecL diff) -> flt
        """
        return _sim3dlong.LJattract_energy(self, *args)

    def forces(self, *args) -> "Vec" :
        """
        forces(LJattract self, VecL diff, flt const eps, flt const sig) -> VecL
        forces(LJattract self, flt const rsig) -> flt
        forces(LJattract self, VecL diff) -> VecL
        """
        return _sim3dlong.LJattract_forces(self, *args)

    __swig_destroy__ = _sim3dlong.delete_LJattract
    __del__ = lambda self : None;
LJattract_swigregister = _sim3dlong.LJattract_swigregister
LJattract_swigregister(LJattract)

class LJattractCut(_object):
    """Proxy of C++ LJattractCut class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJattractCut, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LJattractCut, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(LJattractCut self, flt const epsilon, flt const sigma, flt const cutsig) -> LJattractCut"""
        this = _sim3dlong.new_LJattractCut(*args)
        try: self.this.append(this)
        except: self.this = this
    def energy(self, *args) -> "flt" :
        """
        energy(LJattractCut self, VecL diff, flt const eps, flt const sig, flt const cutsig) -> flt
        energy(LJattractCut self, VecL diff) -> flt
        """
        return _sim3dlong.LJattractCut_energy(self, *args)

    def forces(self, *args) -> "Vec" :
        """
        forces(LJattractCut self, VecL diff, flt const eps, flt const sig, flt const cutsig) -> VecL
        forces(LJattractCut self, VecL diff) -> VecL
        """
        return _sim3dlong.LJattractCut_forces(self, *args)

    __swig_destroy__ = _sim3dlong.delete_LJattractCut
    __del__ = lambda self : None;
LJattractCut_swigregister = _sim3dlong.LJattractCut_swigregister
LJattractCut_swigregister(LJattractCut)

class LJFullCut(_object):
    """Proxy of C++ LJFullCut class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJFullCut, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LJFullCut, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(LJFullCut self, flt const epsilon, flt const sigma, flt const cutsig) -> LJFullCut"""
        this = _sim3dlong.new_LJFullCut(*args)
        try: self.this.append(this)
        except: self.this = this
    def energy(self, *args) -> "flt" :
        """
        energy(LJFullCut self, VecL diff, flt const eps, flt const sig, flt const cutsig) -> flt
        energy(LJFullCut self, flt const rsig, flt const cutsig) -> flt
        energy(LJFullCut self, VecL diff) -> flt
        """
        return _sim3dlong.LJFullCut_energy(self, *args)

    def forces(self, *args) -> "Vec" :
        """
        forces(LJFullCut self, VecL diff, flt const eps, flt const sig, flt const cutsig) -> VecL
        forces(LJFullCut self, flt const rsig, flt const cutsig) -> flt
        forces(LJFullCut self, VecL diff) -> VecL
        """
        return _sim3dlong.LJFullCut_forces(self, *args)

    __swig_destroy__ = _sim3dlong.delete_LJFullCut
    __del__ = lambda self : None;
LJFullCut_swigregister = _sim3dlong.LJFullCut_swigregister
LJFullCut_swigregister(LJFullCut)

class spring(interactpair):
    """Proxy of C++ spring class"""
    __swig_setmethods__ = {}
    for _s in [interactpair]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, spring, name, value)
    __swig_getmethods__ = {}
    for _s in [interactpair]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, spring, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(spring self, flt const k, flt const x0) -> spring"""
        this = _sim3dlong.new_spring(*args)
        try: self.this.append(this)
        except: self.this = this
    def energy(self, *args) -> "flt" :
        """energy(spring self, VecL diff) -> flt"""
        return _sim3dlong.spring_energy(self, *args)

    def forces(self, *args) -> "Vec" :
        """forces(spring self, VecL diff) -> VecL"""
        return _sim3dlong.spring_forces(self, *args)

    __swig_destroy__ = _sim3dlong.delete_spring
    __del__ = lambda self : None;
spring_swigregister = _sim3dlong.spring_swigregister
spring_swigregister(spring)

class bondangle(_object):
    """Proxy of C++ bondangle class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, bondangle, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, bondangle, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(bondangle self, flt const k, flt const theta, bool const cosine=False) -> bondangle
        __init__(bondangle self, flt const k, flt const theta) -> bondangle
        """
        this = _sim3dlong.new_bondangle(*args)
        try: self.this.append(this)
        except: self.this = this
    def energy(self, *args) -> "flt" :
        """energy(bondangle self, VecL diff1, VecL diff2) -> flt"""
        return _sim3dlong.bondangle_energy(self, *args)

    def forces(self, *args) -> "Nvector< Vec,3 >" :
        """forces(bondangle self, VecL diff1, VecL diff2) -> Nvector< Vec,3 >"""
        return _sim3dlong.bondangle_forces(self, *args)

    __swig_destroy__ = _sim3dlong.delete_bondangle
    __del__ = lambda self : None;
bondangle_swigregister = _sim3dlong.bondangle_swigregister
bondangle_swigregister(bondangle)

class dihedral(_object):
    """Proxy of C++ dihedral class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, dihedral, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, dihedral, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(dihedral self, ldvector cosvals, ldvector sinvals=std::vector< flt >(), bool usepow=True) -> dihedral
        __init__(dihedral self, ldvector cosvals, ldvector sinvals=std::vector< flt >()) -> dihedral
        __init__(dihedral self, ldvector cosvals) -> dihedral
        """
        this = _sim3dlong.new_dihedral(*args)
        try: self.this.append(this)
        except: self.this = this
    def getcos(*args) -> "flt" :
        """getcos(VecL diff1, VecL diff2, VecL diff3) -> flt"""
        return _sim3dlong.dihedral_getcos(*args)

    if _newclass:getcos = staticmethod(getcos)
    __swig_getmethods__["getcos"] = lambda x: getcos
    def getang(*args) -> "flt" :
        """getang(VecL diff1, VecL diff2, VecL diff3) -> flt"""
        return _sim3dlong.dihedral_getang(*args)

    if _newclass:getang = staticmethod(getang)
    __swig_getmethods__["getang"] = lambda x: getang
    def dudcostheta(self, *args) -> "flt" :
        """dudcostheta(dihedral self, flt const theta) -> flt"""
        return _sim3dlong.dihedral_dudcostheta(self, *args)

    def energy(self, *args) -> "flt" :
        """
        energy(dihedral self, VecL diff1, VecL diff2, VecL diff3) -> flt
        energy(dihedral self, flt ang) -> flt
        """
        return _sim3dlong.dihedral_energy(self, *args)

    def forces(self, *args) -> "Nvector< Vec,4 >" :
        """forces(dihedral self, VecL diff1, VecL diff2, VecL diff3) -> Nvector< Vec,4 >"""
        return _sim3dlong.dihedral_forces(self, *args)

    __swig_destroy__ = _sim3dlong.delete_dihedral
    __del__ = lambda self : None;
dihedral_swigregister = _sim3dlong.dihedral_swigregister
dihedral_swigregister(dihedral)

def dihedral_getcos(*args) -> "flt" :
  """dihedral_getcos(VecL diff1, VecL diff2, VecL diff3) -> flt"""
  return _sim3dlong.dihedral_getcos(*args)

def dihedral_getang(*args) -> "flt" :
  """dihedral_getang(VecL diff1, VecL diff2, VecL diff3) -> flt"""
  return _sim3dlong.dihedral_getang(*args)

class electricScreened(interactpair):
    """Proxy of C++ electricScreened class"""
    __swig_setmethods__ = {}
    for _s in [interactpair]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, electricScreened, name, value)
    __swig_getmethods__ = {}
    for _s in [interactpair]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, electricScreened, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(electricScreened self, flt const screenLength, flt const q1, flt const q2, flt const cutoff) -> electricScreened"""
        this = _sim3dlong.new_electricScreened(*args)
        try: self.this.append(this)
        except: self.this = this
    def energy(*args) -> "flt" :
        """
        energy(VecL r) -> flt
        energy(flt const r, flt const qaqb, flt const screen, flt const cutoff=0) -> flt
        energy(flt const r, flt const qaqb, flt const screen) -> flt
        """
        return _sim3dlong.electricScreened_energy(*args)

    if _newclass:energy = staticmethod(energy)
    __swig_getmethods__["energy"] = lambda x: energy
    def forces(*args) -> "Vec" :
        """
        forces(VecL r) -> VecL
        forces(VecL r, flt const qaqb, flt const screen, flt const cutoff=0) -> VecL
        forces(VecL r, flt const qaqb, flt const screen) -> VecL
        """
        return _sim3dlong.electricScreened_forces(*args)

    if _newclass:forces = staticmethod(forces)
    __swig_getmethods__["forces"] = lambda x: forces
    __swig_destroy__ = _sim3dlong.delete_electricScreened
    __del__ = lambda self : None;
electricScreened_swigregister = _sim3dlong.electricScreened_swigregister
electricScreened_swigregister(electricScreened)

def electricScreened_energy(*args) -> "flt" :
  """
    energy(VecL r) -> flt
    energy(flt const r, flt const qaqb, flt const screen, flt const cutoff=0) -> flt
    electricScreened_energy(flt const r, flt const qaqb, flt const screen) -> flt
    """
  return _sim3dlong.electricScreened_energy(*args)

def electricScreened_forces(*args) -> "Vec" :
  """
    forces(VecL r) -> VecL
    forces(VecL r, flt const qaqb, flt const screen, flt const cutoff=0) -> VecL
    electricScreened_forces(VecL r, flt const qaqb, flt const screen) -> VecL
    """
  return _sim3dlong.electricScreened_forces(*args)

class fixedForceAtom(_object):
    """Proxy of C++ fixedForceAtom class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, fixedForceAtom, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, fixedForceAtom, name)
    __repr__ = _swig_repr
    __swig_setmethods__["F"] = _sim3dlong.fixedForceAtom_F_set
    __swig_getmethods__["F"] = _sim3dlong.fixedForceAtom_F_get
    if _newclass:F = _swig_property(_sim3dlong.fixedForceAtom_F_get, _sim3dlong.fixedForceAtom_F_set)
    __swig_setmethods__["a"] = _sim3dlong.fixedForceAtom_a_set
    __swig_getmethods__["a"] = _sim3dlong.fixedForceAtom_a_get
    if _newclass:a = _swig_property(_sim3dlong.fixedForceAtom_a_get, _sim3dlong.fixedForceAtom_a_set)
    def __init__(self, *args): 
        """__init__(fixedForceAtom self, VecL F, atom a) -> fixedForceAtom"""
        this = _sim3dlong.new_fixedForceAtom(*args)
        try: self.this.append(this)
        except: self.this = this
    def energy(self, *args) -> "flt" :
        """energy(fixedForceAtom self, Box box) -> flt"""
        return _sim3dlong.fixedForceAtom_energy(self, *args)

    def setForce(self, *args) -> "void" :
        """setForce(fixedForceAtom self, Box box)"""
        return _sim3dlong.fixedForceAtom_setForce(self, *args)

    __swig_destroy__ = _sim3dlong.delete_fixedForceAtom
    __del__ = lambda self : None;
fixedForceAtom_swigregister = _sim3dlong.fixedForceAtom_swigregister
fixedForceAtom_swigregister(fixedForceAtom)

class fixedForce(interaction):
    """Proxy of C++ fixedForce class"""
    __swig_setmethods__ = {}
    for _s in [interaction]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, fixedForce, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, fixedForce, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(fixedForce self, std::vector< fixedForceAtom > atoms=std::vector< fixedForceAtom >()) -> fixedForce
        __init__(fixedForce self) -> fixedForce
        """
        this = _sim3dlong.new_fixedForce(*args)
        try: self.this.append(this)
        except: self.this = this
    def add(self, *args) -> "void" :
        """
        add(fixedForce self, fixedForceAtom a)
        add(fixedForce self, VecL F, atom a)
        add(fixedForce self, flt x, flt y, flt z, atom a)
        """
        return _sim3dlong.fixedForce_add(self, *args)

    def size(self) -> "uint" :
        """size(fixedForce self) -> uint"""
        return _sim3dlong.fixedForce_size(self)

    def energy(self, *args) -> "flt" :
        """energy(fixedForce self, Box box) -> flt"""
        return _sim3dlong.fixedForce_energy(self, *args)

    def setForces(self, *args) -> "void" :
        """setForces(fixedForce self, Box box)"""
        return _sim3dlong.fixedForce_setForces(self, *args)

    def pressure(self, *args) -> "flt" :
        """pressure(fixedForce self, Box box) -> flt"""
        return _sim3dlong.fixedForce_pressure(self, *args)

    __swig_destroy__ = _sim3dlong.delete_fixedForce
    __del__ = lambda self : None;
fixedForce_swigregister = _sim3dlong.fixedForce_swigregister
fixedForce_swigregister(fixedForce)

class fixedSpringAtom(_object):
    """Proxy of C++ fixedSpringAtom class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, fixedSpringAtom, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, fixedSpringAtom, name)
    __repr__ = _swig_repr
    __swig_setmethods__["loc"] = _sim3dlong.fixedSpringAtom_loc_set
    __swig_getmethods__["loc"] = _sim3dlong.fixedSpringAtom_loc_get
    if _newclass:loc = _swig_property(_sim3dlong.fixedSpringAtom_loc_get, _sim3dlong.fixedSpringAtom_loc_set)
    __swig_setmethods__["k"] = _sim3dlong.fixedSpringAtom_k_set
    __swig_getmethods__["k"] = _sim3dlong.fixedSpringAtom_k_get
    if _newclass:k = _swig_property(_sim3dlong.fixedSpringAtom_k_get, _sim3dlong.fixedSpringAtom_k_set)
    __swig_setmethods__["usecoord"] = _sim3dlong.fixedSpringAtom_usecoord_set
    __swig_getmethods__["usecoord"] = _sim3dlong.fixedSpringAtom_usecoord_get
    if _newclass:usecoord = _swig_property(_sim3dlong.fixedSpringAtom_usecoord_get, _sim3dlong.fixedSpringAtom_usecoord_set)
    __swig_setmethods__["a"] = _sim3dlong.fixedSpringAtom_a_set
    __swig_getmethods__["a"] = _sim3dlong.fixedSpringAtom_a_get
    if _newclass:a = _swig_property(_sim3dlong.fixedSpringAtom_a_get, _sim3dlong.fixedSpringAtom_a_set)
    def __init__(self, *args): 
        """
        __init__(fixedSpringAtom self, atom a, VecL loc, flt k, bool usex=True, bool usey=True, bool usez=True) -> fixedSpringAtom
        __init__(fixedSpringAtom self, atom a, VecL loc, flt k, bool usex=True, bool usey=True) -> fixedSpringAtom
        __init__(fixedSpringAtom self, atom a, VecL loc, flt k, bool usex=True) -> fixedSpringAtom
        __init__(fixedSpringAtom self, atom a, VecL loc, flt k) -> fixedSpringAtom
        """
        this = _sim3dlong.new_fixedSpringAtom(*args)
        try: self.this.append(this)
        except: self.this = this
    def energy(self, *args) -> "flt" :
        """energy(fixedSpringAtom self, Box box) -> flt"""
        return _sim3dlong.fixedSpringAtom_energy(self, *args)

    def setForce(self, *args) -> "void" :
        """setForce(fixedSpringAtom self, Box box)"""
        return _sim3dlong.fixedSpringAtom_setForce(self, *args)

    __swig_destroy__ = _sim3dlong.delete_fixedSpringAtom
    __del__ = lambda self : None;
fixedSpringAtom_swigregister = _sim3dlong.fixedSpringAtom_swigregister
fixedSpringAtom_swigregister(fixedSpringAtom)

class fixedSpring(interaction):
    """Proxy of C++ fixedSpring class"""
    __swig_setmethods__ = {}
    for _s in [interaction]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, fixedSpring, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, fixedSpring, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(fixedSpring self, std::vector< fixedSpringAtom > atoms=std::vector< fixedSpringAtom >()) -> fixedSpring
        __init__(fixedSpring self) -> fixedSpring
        """
        this = _sim3dlong.new_fixedSpring(*args)
        try: self.this.append(this)
        except: self.this = this
    def add(self, *args) -> "void" :
        """
        add(fixedSpring self, fixedSpringAtom a)
        add(fixedSpring self, atom a, VecL loc, flt k, bool usex=True, bool usey=True, bool usez=True)
        add(fixedSpring self, atom a, VecL loc, flt k, bool usex=True, bool usey=True)
        add(fixedSpring self, atom a, VecL loc, flt k, bool usex=True)
        add(fixedSpring self, atom a, VecL loc, flt k)
        """
        return _sim3dlong.fixedSpring_add(self, *args)

    def size(self) -> "uint" :
        """size(fixedSpring self) -> uint"""
        return _sim3dlong.fixedSpring_size(self)

    def energy(self, *args) -> "flt" :
        """energy(fixedSpring self, Box box) -> flt"""
        return _sim3dlong.fixedSpring_energy(self, *args)

    def setForces(self, *args) -> "void" :
        """setForces(fixedSpring self, Box box)"""
        return _sim3dlong.fixedSpring_setForces(self, *args)

    def pressure(self, *args) -> "flt" :
        """pressure(fixedSpring self, Box box) -> flt"""
        return _sim3dlong.fixedSpring_pressure(self, *args)

    __swig_destroy__ = _sim3dlong.delete_fixedSpring
    __del__ = lambda self : None;
fixedSpring_swigregister = _sim3dlong.fixedSpring_swigregister
fixedSpring_swigregister(fixedSpring)

class COMSpring(interaction):
    """Proxy of C++ COMSpring class"""
    __swig_setmethods__ = {}
    for _s in [interaction]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, COMSpring, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, COMSpring, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(COMSpring self, atomgroup g1, atomgroup g2, flt k, flt x0=0) -> COMSpring
        __init__(COMSpring self, atomgroup g1, atomgroup g2, flt k) -> COMSpring
        """
        this = _sim3dlong.new_COMSpring(*args)
        try: self.this.append(this)
        except: self.this = this
    def energy(self, *args) -> "flt" :
        """energy(COMSpring self, Box box) -> flt"""
        return _sim3dlong.COMSpring_energy(self, *args)

    def setForces(self, *args) -> "void" :
        """setForces(COMSpring self, Box box)"""
        return _sim3dlong.COMSpring_setForces(self, *args)

    def pressure(self, *args) -> "flt" :
        """pressure(COMSpring self, Box box) -> flt"""
        return _sim3dlong.COMSpring_pressure(self, *args)

    __swig_destroy__ = _sim3dlong.delete_COMSpring
    __del__ = lambda self : None;
COMSpring_swigregister = _sim3dlong.COMSpring_swigregister
COMSpring_swigregister(COMSpring)

class bondgrouping(_object):
    """Proxy of C++ bondgrouping class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, bondgrouping, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, bondgrouping, name)
    __repr__ = _swig_repr
    __swig_setmethods__["k"] = _sim3dlong.bondgrouping_k_set
    __swig_getmethods__["k"] = _sim3dlong.bondgrouping_k_get
    if _newclass:k = _swig_property(_sim3dlong.bondgrouping_k_get, _sim3dlong.bondgrouping_k_set)
    __swig_setmethods__["x0"] = _sim3dlong.bondgrouping_x0_set
    __swig_getmethods__["x0"] = _sim3dlong.bondgrouping_x0_get
    if _newclass:x0 = _swig_property(_sim3dlong.bondgrouping_x0_get, _sim3dlong.bondgrouping_x0_set)
    __swig_setmethods__["a1"] = _sim3dlong.bondgrouping_a1_set
    __swig_getmethods__["a1"] = _sim3dlong.bondgrouping_a1_get
    if _newclass:a1 = _swig_property(_sim3dlong.bondgrouping_a1_get, _sim3dlong.bondgrouping_a1_set)
    __swig_setmethods__["a2"] = _sim3dlong.bondgrouping_a2_set
    __swig_getmethods__["a2"] = _sim3dlong.bondgrouping_a2_get
    if _newclass:a2 = _swig_property(_sim3dlong.bondgrouping_a2_get, _sim3dlong.bondgrouping_a2_set)
    def __init__(self, *args): 
        """__init__(bondgrouping self, flt k, flt x0, atom a1, atom a2) -> bondgrouping"""
        this = _sim3dlong.new_bondgrouping(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _sim3dlong.delete_bondgrouping
    __del__ = lambda self : None;
bondgrouping_swigregister = _sim3dlong.bondgrouping_swigregister
bondgrouping_swigregister(bondgrouping)

class bondpairs(interaction):
    """Proxy of C++ bondpairs class"""
    __swig_setmethods__ = {}
    for _s in [interaction]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, bondpairs, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, bondpairs, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(bondpairs self, std::vector< bondgrouping > pairs=std::vector< bondgrouping >()) -> bondpairs
        __init__(bondpairs self) -> bondpairs
        """
        this = _sim3dlong.new_bondpairs(*args)
        try: self.this.append(this)
        except: self.this = this
    def add(self, *args) -> "void" :
        """
        add(bondpairs self, bondgrouping b)
        add(bondpairs self, flt k, flt x0, atom a1, atom a2)
        """
        return _sim3dlong.bondpairs_add(self, *args)

    def size(self) -> "uint" :
        """size(bondpairs self) -> uint"""
        return _sim3dlong.bondpairs_size(self)

    def mean_dists(self) -> "flt" :
        """mean_dists(bondpairs self) -> flt"""
        return _sim3dlong.bondpairs_mean_dists(self)

    def std_dists(self) -> "flt" :
        """std_dists(bondpairs self) -> flt"""
        return _sim3dlong.bondpairs_std_dists(self)

    def energy(self, *args) -> "flt" :
        """energy(bondpairs self, Box box) -> flt"""
        return _sim3dlong.bondpairs_energy(self, *args)

    def setForces(self, *args) -> "void" :
        """setForces(bondpairs self, Box box)"""
        return _sim3dlong.bondpairs_setForces(self, *args)

    def pressure(self, *args) -> "flt" :
        """pressure(bondpairs self, Box box) -> flt"""
        return _sim3dlong.bondpairs_pressure(self, *args)

    __swig_destroy__ = _sim3dlong.delete_bondpairs
    __del__ = lambda self : None;
bondpairs_swigregister = _sim3dlong.bondpairs_swigregister
bondpairs_swigregister(bondpairs)

class anglegrouping(_object):
    """Proxy of C++ anglegrouping class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, anglegrouping, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, anglegrouping, name)
    __repr__ = _swig_repr
    __swig_setmethods__["k"] = _sim3dlong.anglegrouping_k_set
    __swig_getmethods__["k"] = _sim3dlong.anglegrouping_k_get
    if _newclass:k = _swig_property(_sim3dlong.anglegrouping_k_get, _sim3dlong.anglegrouping_k_set)
    __swig_setmethods__["x0"] = _sim3dlong.anglegrouping_x0_set
    __swig_getmethods__["x0"] = _sim3dlong.anglegrouping_x0_get
    if _newclass:x0 = _swig_property(_sim3dlong.anglegrouping_x0_get, _sim3dlong.anglegrouping_x0_set)
    __swig_setmethods__["a1"] = _sim3dlong.anglegrouping_a1_set
    __swig_getmethods__["a1"] = _sim3dlong.anglegrouping_a1_get
    if _newclass:a1 = _swig_property(_sim3dlong.anglegrouping_a1_get, _sim3dlong.anglegrouping_a1_set)
    __swig_setmethods__["a2"] = _sim3dlong.anglegrouping_a2_set
    __swig_getmethods__["a2"] = _sim3dlong.anglegrouping_a2_get
    if _newclass:a2 = _swig_property(_sim3dlong.anglegrouping_a2_get, _sim3dlong.anglegrouping_a2_set)
    __swig_setmethods__["a3"] = _sim3dlong.anglegrouping_a3_set
    __swig_getmethods__["a3"] = _sim3dlong.anglegrouping_a3_get
    if _newclass:a3 = _swig_property(_sim3dlong.anglegrouping_a3_get, _sim3dlong.anglegrouping_a3_set)
    def __init__(self, *args): 
        """__init__(anglegrouping self, flt k, flt x0, atom a1, atom a2, atom a3) -> anglegrouping"""
        this = _sim3dlong.new_anglegrouping(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _sim3dlong.delete_anglegrouping
    __del__ = lambda self : None;
anglegrouping_swigregister = _sim3dlong.anglegrouping_swigregister
anglegrouping_swigregister(anglegrouping)

class angletriples(interaction):
    """Proxy of C++ angletriples class"""
    __swig_setmethods__ = {}
    for _s in [interaction]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, angletriples, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, angletriples, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(angletriples self, std::vector< anglegrouping > triples=std::vector< anglegrouping >()) -> angletriples
        __init__(angletriples self) -> angletriples
        """
        this = _sim3dlong.new_angletriples(*args)
        try: self.this.append(this)
        except: self.this = this
    def add(self, *args) -> "void" :
        """
        add(angletriples self, anglegrouping b)
        add(angletriples self, flt k, flt x0, atom a1, atom a2, atom a3)
        """
        return _sim3dlong.angletriples_add(self, *args)

    def energy(self, *args) -> "flt" :
        """energy(angletriples self, Box box) -> flt"""
        return _sim3dlong.angletriples_energy(self, *args)

    def pressure(self, *args) -> "flt" :
        """pressure(angletriples self, Box box) -> flt"""
        return _sim3dlong.angletriples_pressure(self, *args)

    def setForces(self, *args) -> "void" :
        """setForces(angletriples self, Box box)"""
        return _sim3dlong.angletriples_setForces(self, *args)

    def size(self) -> "uint" :
        """size(angletriples self) -> uint"""
        return _sim3dlong.angletriples_size(self)

    def mean_dists(self) -> "flt" :
        """mean_dists(angletriples self) -> flt"""
        return _sim3dlong.angletriples_mean_dists(self)

    def std_dists(self) -> "flt" :
        """std_dists(angletriples self) -> flt"""
        return _sim3dlong.angletriples_std_dists(self)

    __swig_destroy__ = _sim3dlong.delete_angletriples
    __del__ = lambda self : None;
angletriples_swigregister = _sim3dlong.angletriples_swigregister
angletriples_swigregister(angletriples)

class dihedralgrouping(_object):
    """Proxy of C++ dihedralgrouping class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, dihedralgrouping, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, dihedralgrouping, name)
    __repr__ = _swig_repr
    def diff(*args) -> "Vec" :
        """diff(VecL r1, VecL r2) -> VecL"""
        return _sim3dlong.dihedralgrouping_diff(*args)

    if _newclass:diff = staticmethod(diff)
    __swig_getmethods__["diff"] = lambda x: diff
    __swig_setmethods__["dih"] = _sim3dlong.dihedralgrouping_dih_set
    __swig_getmethods__["dih"] = _sim3dlong.dihedralgrouping_dih_get
    if _newclass:dih = _swig_property(_sim3dlong.dihedralgrouping_dih_get, _sim3dlong.dihedralgrouping_dih_set)
    __swig_setmethods__["a1"] = _sim3dlong.dihedralgrouping_a1_set
    __swig_getmethods__["a1"] = _sim3dlong.dihedralgrouping_a1_get
    if _newclass:a1 = _swig_property(_sim3dlong.dihedralgrouping_a1_get, _sim3dlong.dihedralgrouping_a1_set)
    __swig_setmethods__["a2"] = _sim3dlong.dihedralgrouping_a2_set
    __swig_getmethods__["a2"] = _sim3dlong.dihedralgrouping_a2_get
    if _newclass:a2 = _swig_property(_sim3dlong.dihedralgrouping_a2_get, _sim3dlong.dihedralgrouping_a2_set)
    __swig_setmethods__["a3"] = _sim3dlong.dihedralgrouping_a3_set
    __swig_getmethods__["a3"] = _sim3dlong.dihedralgrouping_a3_get
    if _newclass:a3 = _swig_property(_sim3dlong.dihedralgrouping_a3_get, _sim3dlong.dihedralgrouping_a3_set)
    __swig_setmethods__["a4"] = _sim3dlong.dihedralgrouping_a4_set
    __swig_getmethods__["a4"] = _sim3dlong.dihedralgrouping_a4_get
    if _newclass:a4 = _swig_property(_sim3dlong.dihedralgrouping_a4_get, _sim3dlong.dihedralgrouping_a4_set)
    def __init__(self, *args): 
        """
        __init__(dihedralgrouping self, ldvector coscoeffs, ldvector sincoeffs, atom a1, atom a2, atom a3, atom a4, bool usepow=True) -> dihedralgrouping
        __init__(dihedralgrouping self, ldvector coscoeffs, ldvector sincoeffs, atom a1, atom a2, atom a3, atom a4) -> dihedralgrouping
        """
        this = _sim3dlong.new_dihedralgrouping(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _sim3dlong.delete_dihedralgrouping
    __del__ = lambda self : None;
dihedralgrouping_swigregister = _sim3dlong.dihedralgrouping_swigregister
dihedralgrouping_swigregister(dihedralgrouping)

def dihedralgrouping_diff(*args) -> "Vec" :
  """dihedralgrouping_diff(VecL r1, VecL r2) -> VecL"""
  return _sim3dlong.dihedralgrouping_diff(*args)

class dihedrals(interaction):
    """Proxy of C++ dihedrals class"""
    __swig_setmethods__ = {}
    for _s in [interaction]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, dihedrals, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, dihedrals, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(dihedrals self, std::vector< dihedralgrouping > pairs=std::vector< dihedralgrouping >()) -> dihedrals
        __init__(dihedrals self) -> dihedrals
        """
        this = _sim3dlong.new_dihedrals(*args)
        try: self.this.append(this)
        except: self.this = this
    def add(self, *args) -> "void" :
        """
        add(dihedrals self, dihedralgrouping b)
        add(dihedrals self, ldvector nums, atom a1, atom a2, atom a3, atom a4)
        add(dihedrals self, ldvector coscoeffs, ldvector sincoeffs, atom a1, atom a2, atom a3, atom a4, bool usepow=True)
        add(dihedrals self, ldvector coscoeffs, ldvector sincoeffs, atom a1, atom a2, atom a3, atom a4)
        """
        return _sim3dlong.dihedrals_add(self, *args)

    def size(self) -> "uint" :
        """size(dihedrals self) -> uint"""
        return _sim3dlong.dihedrals_size(self)

    def mean_dists(self) -> "flt" :
        """mean_dists(dihedrals self) -> flt"""
        return _sim3dlong.dihedrals_mean_dists(self)

    def energy(self, *args) -> "flt" :
        """energy(dihedrals self, Box box) -> flt"""
        return _sim3dlong.dihedrals_energy(self, *args)

    def setForces(self, *args) -> "void" :
        """setForces(dihedrals self, Box box)"""
        return _sim3dlong.dihedrals_setForces(self, *args)

    def pressure(self, *args) -> "flt" :
        """pressure(dihedrals self, Box box) -> flt"""
        return _sim3dlong.dihedrals_pressure(self, *args)

    __swig_destroy__ = _sim3dlong.delete_dihedrals
    __del__ = lambda self : None;
dihedrals_swigregister = _sim3dlong.dihedrals_swigregister
dihedrals_swigregister(dihedrals)

class forcepair(_object):
    """Proxy of C++ forcepair class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, forcepair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, forcepair, name)
    __repr__ = _swig_repr
    __swig_setmethods__["a1"] = _sim3dlong.forcepair_a1_set
    __swig_getmethods__["a1"] = _sim3dlong.forcepair_a1_get
    if _newclass:a1 = _swig_property(_sim3dlong.forcepair_a1_get, _sim3dlong.forcepair_a1_set)
    __swig_setmethods__["a2"] = _sim3dlong.forcepair_a2_set
    __swig_getmethods__["a2"] = _sim3dlong.forcepair_a2_get
    if _newclass:a2 = _swig_property(_sim3dlong.forcepair_a2_get, _sim3dlong.forcepair_a2_set)
    __swig_setmethods__["fij"] = _sim3dlong.forcepair_fij_set
    __swig_getmethods__["fij"] = _sim3dlong.forcepair_fij_get
    if _newclass:fij = _swig_property(_sim3dlong.forcepair_fij_get, _sim3dlong.forcepair_fij_set)
    def __init__(self): 
        """__init__(forcepair self) -> forcepair"""
        this = _sim3dlong.new_forcepair()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _sim3dlong.delete_forcepair
    __del__ = lambda self : None;
forcepair_swigregister = _sim3dlong.forcepair_swigregister
forcepair_swigregister(forcepair)

class forcepairx(_object):
    """Proxy of C++ forcepairx class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, forcepairx, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, forcepairx, name)
    __repr__ = _swig_repr
    __swig_setmethods__["a1"] = _sim3dlong.forcepairx_a1_set
    __swig_getmethods__["a1"] = _sim3dlong.forcepairx_a1_get
    if _newclass:a1 = _swig_property(_sim3dlong.forcepairx_a1_get, _sim3dlong.forcepairx_a1_set)
    __swig_setmethods__["a2"] = _sim3dlong.forcepairx_a2_set
    __swig_getmethods__["a2"] = _sim3dlong.forcepairx_a2_get
    if _newclass:a2 = _swig_property(_sim3dlong.forcepairx_a2_get, _sim3dlong.forcepairx_a2_set)
    __swig_setmethods__["xij"] = _sim3dlong.forcepairx_xij_set
    __swig_getmethods__["xij"] = _sim3dlong.forcepairx_xij_get
    if _newclass:xij = _swig_property(_sim3dlong.forcepairx_xij_get, _sim3dlong.forcepairx_xij_set)
    __swig_setmethods__["fij"] = _sim3dlong.forcepairx_fij_set
    __swig_getmethods__["fij"] = _sim3dlong.forcepairx_fij_get
    if _newclass:fij = _swig_property(_sim3dlong.forcepairx_fij_get, _sim3dlong.forcepairx_fij_set)
    def __init__(self): 
        """__init__(forcepairx self) -> forcepairx"""
        this = _sim3dlong.new_forcepairx()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _sim3dlong.delete_forcepairx
    __del__ = lambda self : None;
forcepairx_swigregister = _sim3dlong.forcepairx_swigregister
forcepairx_swigregister(forcepairx)

class fpairxFunct(_object):
    """Proxy of C++ fpairxFunct class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, fpairxFunct, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, fpairxFunct, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def run(self, *args) -> "void" :
        """run(fpairxFunct self, forcepairx arg2)"""
        return _sim3dlong.fpairxFunct_run(self, *args)

    __swig_destroy__ = _sim3dlong.delete_fpairxFunct
    __del__ = lambda self : None;
fpairxFunct_swigregister = _sim3dlong.fpairxFunct_swigregister
fpairxFunct_swigregister(fpairxFunct)

class interactionpairsx(interaction):
    """Proxy of C++ interactionpairsx class"""
    __swig_setmethods__ = {}
    for _s in [interaction]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, interactionpairsx, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, interactionpairsx, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def setForces(self, *args) -> "void" :
        """
        setForces(interactionpairsx self, Box box)
        setForces(interactionpairsx self, Box box, fpairxFunct arg3)
        """
        return _sim3dlong.interactionpairsx_setForces(self, *args)

    __swig_destroy__ = _sim3dlong.delete_interactionpairsx
    __del__ = lambda self : None;
interactionpairsx_swigregister = _sim3dlong.interactionpairsx_swigregister
interactionpairsx_swigregister(interactionpairsx)

class atompaircomp(_object):
    """Proxy of C++ atompaircomp class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, atompaircomp, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, atompaircomp, name)
    __repr__ = _swig_repr
    def __call__(self, *args) -> "bool" :
        """__call__(atompaircomp self, atompair lhs, atompair rhs) -> bool"""
        return _sim3dlong.atompaircomp___call__(self, *args)

    def __init__(self): 
        """__init__(atompaircomp self) -> atompaircomp"""
        this = _sim3dlong.new_atompaircomp()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _sim3dlong.delete_atompaircomp
    __del__ = lambda self : None;
atompaircomp_swigregister = _sim3dlong.atompaircomp_swigregister
atompaircomp_swigregister(atompaircomp)

class pairlist(_object):
    """Proxy of C++ pairlist class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, pairlist, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, pairlist, name)
    __repr__ = _swig_repr
    def __init__(self): 
        """__init__(pairlist self) -> pairlist"""
        this = _sim3dlong.new_pairlist()
        try: self.this.append(this)
        except: self.this = this
    def ensure(self, *args) -> "void" :
        """
        ensure(pairlist self, atomid a)
        ensure(pairlist self, std::vector< atomid > ps)
        ensure(pairlist self, atomgroup group)
        """
        return _sim3dlong.pairlist_ensure(self, *args)

    def has_pair(self, *args) -> "bool" :
        """has_pair(pairlist self, atomid a1, atomid a2) -> bool"""
        return _sim3dlong.pairlist_has_pair(self, *args)

    def add_pair(self, *args) -> "void" :
        """add_pair(pairlist self, atomid a1, atomid a2)"""
        return _sim3dlong.pairlist_add_pair(self, *args)

    def erase_pair(self, *args) -> "void" :
        """erase_pair(pairlist self, atomid a1, atomid a2)"""
        return _sim3dlong.pairlist_erase_pair(self, *args)

    def get_pairs(self, *args) -> "set< atomid >" :
        """get_pairs(pairlist self, atomid a) -> set< atomid >"""
        return _sim3dlong.pairlist_get_pairs(self, *args)

    def begin(self, *args) -> "set< atomid >::iterator" :
        """begin(pairlist self, atomid a) -> set< atomid >::iterator"""
        return _sim3dlong.pairlist_begin(self, *args)

    def end(self, *args) -> "set< atomid >::iterator" :
        """end(pairlist self, atomid a) -> set< atomid >::iterator"""
        return _sim3dlong.pairlist_end(self, *args)

    def size(self) -> "uint" :
        """size(pairlist self) -> uint"""
        return _sim3dlong.pairlist_size(self)

    def clear(self) -> "void" :
        """clear(pairlist self)"""
        return _sim3dlong.pairlist_clear(self)

    __swig_destroy__ = _sim3dlong.delete_pairlist
    __del__ = lambda self : None;
pairlist_swigregister = _sim3dlong.pairlist_swigregister
pairlist_swigregister(pairlist)

class neighborlist(statetracker):
    """Proxy of C++ neighborlist class"""
    __swig_setmethods__ = {}
    for _s in [statetracker]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, neighborlist, name, value)
    __swig_getmethods__ = {}
    for _s in [statetracker]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, neighborlist, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(neighborlist self, Box box, flt const innerradius, flt const outerradius) -> neighborlist
        __init__(neighborlist self, Box box, atomgroup vec, flt const innerradius, flt const outerradius, pairlist ignore=pairlist()) -> neighborlist
        __init__(neighborlist self, Box box, atomgroup vec, flt const innerradius, flt const outerradius) -> neighborlist
        """
        this = _sim3dlong.new_neighborlist(*args)
        try: self.this.append(this)
        except: self.this = this
    def update(self, *args) -> "void" :
        """update(neighborlist self, Box newbox)"""
        return _sim3dlong.neighborlist_update(self, *args)

    def update_list(self, force : 'bool'=True) -> "bool" :
        """
        update_list(neighborlist self, bool force=True) -> bool
        update_list(neighborlist self) -> bool
        """
        return _sim3dlong.neighborlist_update_list(self, force)

    def which(self) -> "uint" :
        """which(neighborlist self) -> uint"""
        return _sim3dlong.neighborlist_which(self)

    def numpairs(self) -> "uint" :
        """numpairs(neighborlist self) -> uint"""
        return _sim3dlong.neighborlist_numpairs(self)

    def ignore(self, *args) -> "void" :
        """
        ignore(neighborlist self, atomid a, atomid b)
        ignore(neighborlist self, atom arg2, atom arg3)
        """
        return _sim3dlong.neighborlist_ignore(self, *args)

    def add(self, *args) -> "atomid" :
        """add(neighborlist self, atom a) -> atomid"""
        return _sim3dlong.neighborlist_add(self, *args)

    def changesize(self, *args) -> "void" :
        """
        changesize(neighborlist self, flt inner, flt outer)
        changesize(neighborlist self, flt ratio)
        """
        return _sim3dlong.neighborlist_changesize(self, *args)

    def ignore_size(self) -> "uint" :
        """ignore_size(neighborlist self) -> uint"""
        return _sim3dlong.neighborlist_ignore_size(self)

    def size(self) -> "uint" :
        """size(neighborlist self) -> uint"""
        return _sim3dlong.neighborlist_size(self)

    def begin(self) -> "std::vector< idpair,std::allocator< idpair > >::iterator" :
        """begin(neighborlist self) -> std::vector< idpair,std::allocator< idpair > >::iterator"""
        return _sim3dlong.neighborlist_begin(self)

    def end(self) -> "std::vector< idpair,std::allocator< idpair > >::iterator" :
        """end(neighborlist self) -> std::vector< idpair,std::allocator< idpair > >::iterator"""
        return _sim3dlong.neighborlist_end(self)

    def get(self, *args) -> "idpair" :
        """get(neighborlist self, uint i) -> idpair"""
        return _sim3dlong.neighborlist_get(self, *args)

    __swig_destroy__ = _sim3dlong.delete_neighborlist
    __del__ = lambda self : None;
    def __getitem__(self, *args) -> "idpair" :
        """__getitem__(neighborlist self, size_t i) -> idpair"""
        return _sim3dlong.neighborlist___getitem__(self, *args)

    def __iter__(self):
        for i in range(self.numpairs()):
            yield self[i]

neighborlist_swigregister = _sim3dlong.neighborlist_swigregister
neighborlist_swigregister(neighborlist)


def neighborlistL(*args) -> "neighborlist *" :
  """neighborlistL(Box box, double const innerradius, double const outerradius) -> neighborlist"""
  return _sim3dlong.neighborlistL(*args)
class ContactTracker(statetracker):
    """Proxy of C++ ContactTracker class"""
    __swig_setmethods__ = {}
    for _s in [statetracker]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ContactTracker, name, value)
    __swig_getmethods__ = {}
    for _s in [statetracker]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ContactTracker, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(ContactTracker self, Box box, atomgroup atoms, ldvector dists) -> ContactTracker"""
        this = _sim3dlong.new_ContactTracker(*args)
        try: self.this.append(this)
        except: self.this = this
    def update(self, *args) -> "void" :
        """update(ContactTracker self, Box box)"""
        return _sim3dlong.ContactTracker_update(self, *args)

    def broken(self) -> "unsigned long long" :
        """broken(ContactTracker self) -> unsigned long long"""
        return _sim3dlong.ContactTracker_broken(self)

    def formed(self) -> "unsigned long long" :
        """formed(ContactTracker self) -> unsigned long long"""
        return _sim3dlong.ContactTracker_formed(self)

    def number(self) -> "unsigned long long" :
        """number(ContactTracker self) -> unsigned long long"""
        return _sim3dlong.ContactTracker_number(self)

    __swig_destroy__ = _sim3dlong.delete_ContactTracker
    __del__ = lambda self : None;
ContactTracker_swigregister = _sim3dlong.ContactTracker_swigregister
ContactTracker_swigregister(ContactTracker)


def ContactTrackerD(*args) -> "ContactTracker *" :
  """ContactTrackerD(Box box, atomgroup atoms, dvector dists) -> ContactTracker"""
  return _sim3dlong.ContactTrackerD(*args)
class EnergyTracker(statetracker):
    """Proxy of C++ EnergyTracker class"""
    __swig_setmethods__ = {}
    for _s in [statetracker]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, EnergyTracker, name, value)
    __swig_getmethods__ = {}
    for _s in [statetracker]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, EnergyTracker, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(EnergyTracker self, Box box, atomgroup atoms, ivector interactions, uint nskip=1) -> EnergyTracker
        __init__(EnergyTracker self, Box box, atomgroup atoms, ivector interactions) -> EnergyTracker
        """
        this = _sim3dlong.new_EnergyTracker(*args)
        try: self.this.append(this)
        except: self.this = this
    def update(self, *args) -> "void" :
        """update(EnergyTracker self, Box box)"""
        return _sim3dlong.EnergyTracker_update(self, *args)

    def reset(self) -> "void" :
        """reset(EnergyTracker self)"""
        return _sim3dlong.EnergyTracker_reset(self)

    def setU0(self, *args) -> "void" :
        """setU0(EnergyTracker self, flt newU0)"""
        return _sim3dlong.EnergyTracker_setU0(self, *args)

    def E(self) -> "flt" :
        """E(EnergyTracker self) -> flt"""
        return _sim3dlong.EnergyTracker_E(self)

    def U(self) -> "flt" :
        """U(EnergyTracker self) -> flt"""
        return _sim3dlong.EnergyTracker_U(self)

    def K(self) -> "flt" :
        """K(EnergyTracker self) -> flt"""
        return _sim3dlong.EnergyTracker_K(self)

    def n(self) -> "unsigned long long" :
        """n(EnergyTracker self) -> unsigned long long"""
        return _sim3dlong.EnergyTracker_n(self)

    __swig_destroy__ = _sim3dlong.delete_EnergyTracker
    __del__ = lambda self : None;
EnergyTracker_swigregister = _sim3dlong.EnergyTracker_swigregister
EnergyTracker_swigregister(EnergyTracker)

class Charged(atomid):
    """Proxy of C++ Charged class"""
    __swig_setmethods__ = {}
    for _s in [atomid]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Charged, name, value)
    __swig_getmethods__ = {}
    for _s in [atomid]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Charged, name)
    __repr__ = _swig_repr
    __swig_setmethods__["q"] = _sim3dlong.Charged_q_set
    __swig_getmethods__["q"] = _sim3dlong.Charged_q_get
    if _newclass:q = _swig_property(_sim3dlong.Charged_q_get, _sim3dlong.Charged_q_set)
    def __init__(self, *args): 
        """
        __init__(Charged self) -> Charged
        __init__(Charged self, flt q, atom a) -> Charged
        """
        this = _sim3dlong.new_Charged(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _sim3dlong.delete_Charged
    __del__ = lambda self : None;
Charged_swigregister = _sim3dlong.Charged_swigregister
Charged_swigregister(Charged)

class ChargePair(_object):
    """Proxy of C++ ChargePair class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ChargePair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ChargePair, name)
    __repr__ = _swig_repr
    __swig_setmethods__["q1q2"] = _sim3dlong.ChargePair_q1q2_set
    __swig_getmethods__["q1q2"] = _sim3dlong.ChargePair_q1q2_get
    if _newclass:q1q2 = _swig_property(_sim3dlong.ChargePair_q1q2_get, _sim3dlong.ChargePair_q1q2_set)
    __swig_setmethods__["atom1"] = _sim3dlong.ChargePair_atom1_set
    __swig_getmethods__["atom1"] = _sim3dlong.ChargePair_atom1_get
    if _newclass:atom1 = _swig_property(_sim3dlong.ChargePair_atom1_get, _sim3dlong.ChargePair_atom1_set)
    __swig_setmethods__["atom2"] = _sim3dlong.ChargePair_atom2_set
    __swig_getmethods__["atom2"] = _sim3dlong.ChargePair_atom2_get
    if _newclass:atom2 = _swig_property(_sim3dlong.ChargePair_atom2_get, _sim3dlong.ChargePair_atom2_set)
    def __init__(self, *args): 
        """__init__(ChargePair self, Charged a1, Charged a2) -> ChargePair"""
        this = _sim3dlong.new_ChargePair(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _sim3dlong.delete_ChargePair
    __del__ = lambda self : None;
ChargePair_swigregister = _sim3dlong.ChargePair_swigregister
ChargePair_swigregister(ChargePair)

class LJatom(atomid):
    """Proxy of C++ LJatom class"""
    __swig_setmethods__ = {}
    for _s in [atomid]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJatom, name, value)
    __swig_getmethods__ = {}
    for _s in [atomid]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LJatom, name)
    __repr__ = _swig_repr
    __swig_setmethods__["epsilon"] = _sim3dlong.LJatom_epsilon_set
    __swig_getmethods__["epsilon"] = _sim3dlong.LJatom_epsilon_get
    if _newclass:epsilon = _swig_property(_sim3dlong.LJatom_epsilon_get, _sim3dlong.LJatom_epsilon_set)
    __swig_setmethods__["sigma"] = _sim3dlong.LJatom_sigma_set
    __swig_getmethods__["sigma"] = _sim3dlong.LJatom_sigma_get
    if _newclass:sigma = _swig_property(_sim3dlong.LJatom_sigma_get, _sim3dlong.LJatom_sigma_set)
    def __init__(self, *args): 
        """
        __init__(LJatom self, flt epsilon, flt sigma, atom a) -> LJatom
        __init__(LJatom self, atomid a, LJatom other) -> LJatom
        """
        this = _sim3dlong.new_LJatom(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _sim3dlong.delete_LJatom
    __del__ = lambda self : None;
LJatom_swigregister = _sim3dlong.LJatom_swigregister
LJatom_swigregister(LJatom)

class LJpair(_object):
    """Proxy of C++ LJpair class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJpair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LJpair, name)
    __repr__ = _swig_repr
    __swig_setmethods__["epsilon"] = _sim3dlong.LJpair_epsilon_set
    __swig_getmethods__["epsilon"] = _sim3dlong.LJpair_epsilon_get
    if _newclass:epsilon = _swig_property(_sim3dlong.LJpair_epsilon_get, _sim3dlong.LJpair_epsilon_set)
    __swig_setmethods__["sigma"] = _sim3dlong.LJpair_sigma_set
    __swig_getmethods__["sigma"] = _sim3dlong.LJpair_sigma_get
    if _newclass:sigma = _swig_property(_sim3dlong.LJpair_sigma_get, _sim3dlong.LJpair_sigma_set)
    __swig_setmethods__["atom1"] = _sim3dlong.LJpair_atom1_set
    __swig_getmethods__["atom1"] = _sim3dlong.LJpair_atom1_get
    if _newclass:atom1 = _swig_property(_sim3dlong.LJpair_atom1_get, _sim3dlong.LJpair_atom1_set)
    __swig_setmethods__["atom2"] = _sim3dlong.LJpair_atom2_set
    __swig_getmethods__["atom2"] = _sim3dlong.LJpair_atom2_get
    if _newclass:atom2 = _swig_property(_sim3dlong.LJpair_atom2_get, _sim3dlong.LJpair_atom2_set)
    def __init__(self, *args): 
        """__init__(LJpair self, LJatom LJ1, LJatom LJ2) -> LJpair"""
        this = _sim3dlong.new_LJpair(*args)
        try: self.this.append(this)
        except: self.this = this
    def energy(self, *args) -> "flt" :
        """energy(LJpair self, Box box) -> flt"""
        return _sim3dlong.LJpair_energy(self, *args)

    def forces(self, *args) -> "Vec" :
        """forces(LJpair self, Box box) -> VecL"""
        return _sim3dlong.LJpair_forces(self, *args)

    __swig_destroy__ = _sim3dlong.delete_LJpair
    __del__ = lambda self : None;
LJpair_swigregister = _sim3dlong.LJpair_swigregister
LJpair_swigregister(LJpair)

class LJatomcut(LJatom):
    """Proxy of C++ LJatomcut class"""
    __swig_setmethods__ = {}
    for _s in [LJatom]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJatomcut, name, value)
    __swig_getmethods__ = {}
    for _s in [LJatom]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LJatomcut, name)
    __repr__ = _swig_repr
    __swig_setmethods__["sigcut"] = _sim3dlong.LJatomcut_sigcut_set
    __swig_getmethods__["sigcut"] = _sim3dlong.LJatomcut_sigcut_get
    if _newclass:sigcut = _swig_property(_sim3dlong.LJatomcut_sigcut_get, _sim3dlong.LJatomcut_sigcut_set)
    def __init__(self, *args): 
        """
        __init__(LJatomcut self, flt epsilon, flt sigma, atom a, flt cut) -> LJatomcut
        __init__(LJatomcut self, atomid a, LJatomcut other) -> LJatomcut
        """
        this = _sim3dlong.new_LJatomcut(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _sim3dlong.delete_LJatomcut
    __del__ = lambda self : None;
LJatomcut_swigregister = _sim3dlong.LJatomcut_swigregister
LJatomcut_swigregister(LJatomcut)

class LJAttractPair(_object):
    """Proxy of C++ LJAttractPair class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJAttractPair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LJAttractPair, name)
    __repr__ = _swig_repr
    __swig_setmethods__["inter"] = _sim3dlong.LJAttractPair_inter_set
    __swig_getmethods__["inter"] = _sim3dlong.LJAttractPair_inter_get
    if _newclass:inter = _swig_property(_sim3dlong.LJAttractPair_inter_get, _sim3dlong.LJAttractPair_inter_set)
    __swig_setmethods__["atom1"] = _sim3dlong.LJAttractPair_atom1_set
    __swig_getmethods__["atom1"] = _sim3dlong.LJAttractPair_atom1_get
    if _newclass:atom1 = _swig_property(_sim3dlong.LJAttractPair_atom1_get, _sim3dlong.LJAttractPair_atom1_set)
    __swig_setmethods__["atom2"] = _sim3dlong.LJAttractPair_atom2_set
    __swig_getmethods__["atom2"] = _sim3dlong.LJAttractPair_atom2_get
    if _newclass:atom2 = _swig_property(_sim3dlong.LJAttractPair_atom2_get, _sim3dlong.LJAttractPair_atom2_set)
    def __init__(self, *args): 
        """__init__(LJAttractPair self, LJatomcut a1, LJatomcut a2) -> LJAttractPair"""
        this = _sim3dlong.new_LJAttractPair(*args)
        try: self.this.append(this)
        except: self.this = this
    def energy(self, *args) -> "flt" :
        """energy(LJAttractPair self, Box box) -> flt"""
        return _sim3dlong.LJAttractPair_energy(self, *args)

    def forces(self, *args) -> "Vec" :
        """forces(LJAttractPair self, Box box) -> VecL"""
        return _sim3dlong.LJAttractPair_forces(self, *args)

    __swig_destroy__ = _sim3dlong.delete_LJAttractPair
    __del__ = lambda self : None;
LJAttractPair_swigregister = _sim3dlong.LJAttractPair_swigregister
LJAttractPair_swigregister(LJAttractPair)

class HydroAtom(atomid):
    """Proxy of C++ HydroAtom class"""
    __swig_setmethods__ = {}
    for _s in [atomid]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HydroAtom, name, value)
    __swig_getmethods__ = {}
    for _s in [atomid]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, HydroAtom, name)
    __repr__ = _swig_repr
    __swig_setmethods__["epsilons"] = _sim3dlong.HydroAtom_epsilons_set
    __swig_getmethods__["epsilons"] = _sim3dlong.HydroAtom_epsilons_get
    if _newclass:epsilons = _swig_property(_sim3dlong.HydroAtom_epsilons_get, _sim3dlong.HydroAtom_epsilons_set)
    __swig_setmethods__["indx"] = _sim3dlong.HydroAtom_indx_set
    __swig_getmethods__["indx"] = _sim3dlong.HydroAtom_indx_get
    if _newclass:indx = _swig_property(_sim3dlong.HydroAtom_indx_get, _sim3dlong.HydroAtom_indx_set)
    __swig_setmethods__["sigma"] = _sim3dlong.HydroAtom_sigma_set
    __swig_getmethods__["sigma"] = _sim3dlong.HydroAtom_sigma_get
    if _newclass:sigma = _swig_property(_sim3dlong.HydroAtom_sigma_get, _sim3dlong.HydroAtom_sigma_set)
    __swig_setmethods__["sigcut"] = _sim3dlong.HydroAtom_sigcut_set
    __swig_getmethods__["sigcut"] = _sim3dlong.HydroAtom_sigcut_get
    if _newclass:sigcut = _swig_property(_sim3dlong.HydroAtom_sigcut_get, _sim3dlong.HydroAtom_sigcut_set)
    def __init__(self, *args): 
        """
        __init__(HydroAtom self, ldvector epsilons, uint indx, flt sigma, atom a, flt cut) -> HydroAtom
        __init__(HydroAtom self, atomid a, HydroAtom other) -> HydroAtom
        """
        this = _sim3dlong.new_HydroAtom(*args)
        try: self.this.append(this)
        except: self.this = this
    def getEpsilon(self, *args) -> "flt" :
        """getEpsilon(HydroAtom self, HydroAtom other) -> flt"""
        return _sim3dlong.HydroAtom_getEpsilon(self, *args)

    __swig_destroy__ = _sim3dlong.delete_HydroAtom
    __del__ = lambda self : None;
HydroAtom_swigregister = _sim3dlong.HydroAtom_swigregister
HydroAtom_swigregister(HydroAtom)

class HydroPair(_object):
    """Proxy of C++ HydroPair class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, HydroPair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, HydroPair, name)
    __repr__ = _swig_repr
    __swig_setmethods__["inter"] = _sim3dlong.HydroPair_inter_set
    __swig_getmethods__["inter"] = _sim3dlong.HydroPair_inter_get
    if _newclass:inter = _swig_property(_sim3dlong.HydroPair_inter_get, _sim3dlong.HydroPair_inter_set)
    __swig_setmethods__["atom1"] = _sim3dlong.HydroPair_atom1_set
    __swig_getmethods__["atom1"] = _sim3dlong.HydroPair_atom1_get
    if _newclass:atom1 = _swig_property(_sim3dlong.HydroPair_atom1_get, _sim3dlong.HydroPair_atom1_set)
    __swig_setmethods__["atom2"] = _sim3dlong.HydroPair_atom2_set
    __swig_getmethods__["atom2"] = _sim3dlong.HydroPair_atom2_get
    if _newclass:atom2 = _swig_property(_sim3dlong.HydroPair_atom2_get, _sim3dlong.HydroPair_atom2_set)
    def __init__(self, *args): 
        """__init__(HydroPair self, HydroAtom a1, HydroAtom a2) -> HydroPair"""
        this = _sim3dlong.new_HydroPair(*args)
        try: self.this.append(this)
        except: self.this = this
    def energy(self, *args) -> "flt" :
        """energy(HydroPair self, Box box) -> flt"""
        return _sim3dlong.HydroPair_energy(self, *args)

    def forces(self, *args) -> "Vec" :
        """forces(HydroPair self, Box box) -> VecL"""
        return _sim3dlong.HydroPair_forces(self, *args)

    __swig_destroy__ = _sim3dlong.delete_HydroPair
    __del__ = lambda self : None;
HydroPair_swigregister = _sim3dlong.HydroPair_swigregister
HydroPair_swigregister(HydroPair)

class LJAtomIndexed(atomid):
    """Proxy of C++ LJAtomIndexed class"""
    __swig_setmethods__ = {}
    for _s in [atomid]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJAtomIndexed, name, value)
    __swig_getmethods__ = {}
    for _s in [atomid]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LJAtomIndexed, name)
    __repr__ = _swig_repr
    __swig_setmethods__["epsilons"] = _sim3dlong.LJAtomIndexed_epsilons_set
    __swig_getmethods__["epsilons"] = _sim3dlong.LJAtomIndexed_epsilons_get
    if _newclass:epsilons = _swig_property(_sim3dlong.LJAtomIndexed_epsilons_get, _sim3dlong.LJAtomIndexed_epsilons_set)
    __swig_setmethods__["sigmas"] = _sim3dlong.LJAtomIndexed_sigmas_set
    __swig_getmethods__["sigmas"] = _sim3dlong.LJAtomIndexed_sigmas_get
    if _newclass:sigmas = _swig_property(_sim3dlong.LJAtomIndexed_sigmas_get, _sim3dlong.LJAtomIndexed_sigmas_set)
    __swig_setmethods__["indx"] = _sim3dlong.LJAtomIndexed_indx_set
    __swig_getmethods__["indx"] = _sim3dlong.LJAtomIndexed_indx_get
    if _newclass:indx = _swig_property(_sim3dlong.LJAtomIndexed_indx_get, _sim3dlong.LJAtomIndexed_indx_set)
    __swig_setmethods__["sigcut"] = _sim3dlong.LJAtomIndexed_sigcut_set
    __swig_getmethods__["sigcut"] = _sim3dlong.LJAtomIndexed_sigcut_get
    if _newclass:sigcut = _swig_property(_sim3dlong.LJAtomIndexed_sigcut_get, _sim3dlong.LJAtomIndexed_sigcut_set)
    def __init__(self, *args): 
        """
        __init__(LJAtomIndexed self, ldvector epsilons, ldvector sigmas, uint indx, atom a, flt cut) -> LJAtomIndexed
        __init__(LJAtomIndexed self, atomid a, LJAtomIndexed other) -> LJAtomIndexed
        """
        this = _sim3dlong.new_LJAtomIndexed(*args)
        try: self.this.append(this)
        except: self.this = this
    def getEpsilon(self, *args) -> "flt" :
        """getEpsilon(LJAtomIndexed self, LJAtomIndexed other) -> flt"""
        return _sim3dlong.LJAtomIndexed_getEpsilon(self, *args)

    def getSigma(self, *args) -> "flt" :
        """getSigma(LJAtomIndexed self, LJAtomIndexed other) -> flt"""
        return _sim3dlong.LJAtomIndexed_getSigma(self, *args)

    __swig_destroy__ = _sim3dlong.delete_LJAtomIndexed
    __del__ = lambda self : None;
LJAtomIndexed_swigregister = _sim3dlong.LJAtomIndexed_swigregister
LJAtomIndexed_swigregister(LJAtomIndexed)

class LJFullPair(_object):
    """Proxy of C++ LJFullPair class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJFullPair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LJFullPair, name)
    __repr__ = _swig_repr
    __swig_setmethods__["inter"] = _sim3dlong.LJFullPair_inter_set
    __swig_getmethods__["inter"] = _sim3dlong.LJFullPair_inter_get
    if _newclass:inter = _swig_property(_sim3dlong.LJFullPair_inter_get, _sim3dlong.LJFullPair_inter_set)
    __swig_setmethods__["atom1"] = _sim3dlong.LJFullPair_atom1_set
    __swig_getmethods__["atom1"] = _sim3dlong.LJFullPair_atom1_get
    if _newclass:atom1 = _swig_property(_sim3dlong.LJFullPair_atom1_get, _sim3dlong.LJFullPair_atom1_set)
    __swig_setmethods__["atom2"] = _sim3dlong.LJFullPair_atom2_set
    __swig_getmethods__["atom2"] = _sim3dlong.LJFullPair_atom2_get
    if _newclass:atom2 = _swig_property(_sim3dlong.LJFullPair_atom2_get, _sim3dlong.LJFullPair_atom2_set)
    def __init__(self, *args): 
        """__init__(LJFullPair self, LJAtomIndexed a1, LJAtomIndexed a2) -> LJFullPair"""
        this = _sim3dlong.new_LJFullPair(*args)
        try: self.this.append(this)
        except: self.this = this
    def energy(self, *args) -> "flt" :
        """energy(LJFullPair self, Box box) -> flt"""
        return _sim3dlong.LJFullPair_energy(self, *args)

    def forces(self, *args) -> "Vec" :
        """forces(LJFullPair self, Box box) -> VecL"""
        return _sim3dlong.LJFullPair_forces(self, *args)

    __swig_destroy__ = _sim3dlong.delete_LJFullPair
    __del__ = lambda self : None;
LJFullPair_swigregister = _sim3dlong.LJFullPair_swigregister
LJFullPair_swigregister(LJFullPair)

class LJishAtom(atomid):
    """Proxy of C++ LJishAtom class"""
    __swig_setmethods__ = {}
    for _s in [atomid]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJishAtom, name, value)
    __swig_getmethods__ = {}
    for _s in [atomid]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LJishAtom, name)
    __repr__ = _swig_repr
    __swig_setmethods__["epsilons"] = _sim3dlong.LJishAtom_epsilons_set
    __swig_getmethods__["epsilons"] = _sim3dlong.LJishAtom_epsilons_get
    if _newclass:epsilons = _swig_property(_sim3dlong.LJishAtom_epsilons_get, _sim3dlong.LJishAtom_epsilons_set)
    __swig_setmethods__["repeps"] = _sim3dlong.LJishAtom_repeps_set
    __swig_getmethods__["repeps"] = _sim3dlong.LJishAtom_repeps_get
    if _newclass:repeps = _swig_property(_sim3dlong.LJishAtom_repeps_get, _sim3dlong.LJishAtom_repeps_set)
    __swig_setmethods__["sigma"] = _sim3dlong.LJishAtom_sigma_set
    __swig_getmethods__["sigma"] = _sim3dlong.LJishAtom_sigma_get
    if _newclass:sigma = _swig_property(_sim3dlong.LJishAtom_sigma_get, _sim3dlong.LJishAtom_sigma_set)
    __swig_setmethods__["exponent"] = _sim3dlong.LJishAtom_exponent_set
    __swig_getmethods__["exponent"] = _sim3dlong.LJishAtom_exponent_get
    if _newclass:exponent = _swig_property(_sim3dlong.LJishAtom_exponent_get, _sim3dlong.LJishAtom_exponent_set)
    __swig_setmethods__["indx"] = _sim3dlong.LJishAtom_indx_set
    __swig_getmethods__["indx"] = _sim3dlong.LJishAtom_indx_get
    if _newclass:indx = _swig_property(_sim3dlong.LJishAtom_indx_get, _sim3dlong.LJishAtom_indx_set)
    __swig_setmethods__["sigcut"] = _sim3dlong.LJishAtom_sigcut_set
    __swig_getmethods__["sigcut"] = _sim3dlong.LJishAtom_sigcut_get
    if _newclass:sigcut = _swig_property(_sim3dlong.LJishAtom_sigcut_get, _sim3dlong.LJishAtom_sigcut_set)
    def __init__(self, *args): 
        """
        __init__(LJishAtom self, atom a, ldvector epsilons, flt repeps, flt sigma, flt n, uint indx, flt cut) -> LJishAtom
        __init__(LJishAtom self, atomid a, LJishAtom other) -> LJishAtom
        """
        this = _sim3dlong.new_LJishAtom(*args)
        try: self.this.append(this)
        except: self.this = this
    def getEpsilon(self, *args) -> "flt" :
        """getEpsilon(LJishAtom self, LJishAtom other) -> flt"""
        return _sim3dlong.LJishAtom_getEpsilon(self, *args)

    def getSigma(self, *args) -> "flt" :
        """getSigma(LJishAtom self, LJishAtom other) -> flt"""
        return _sim3dlong.LJishAtom_getSigma(self, *args)

    __swig_destroy__ = _sim3dlong.delete_LJishAtom
    __del__ = lambda self : None;
LJishAtom_swigregister = _sim3dlong.LJishAtom_swigregister
LJishAtom_swigregister(LJishAtom)

class LJishPair(_object):
    """Proxy of C++ LJishPair class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJishPair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LJishPair, name)
    __repr__ = _swig_repr
    __swig_setmethods__["epsilon"] = _sim3dlong.LJishPair_epsilon_set
    __swig_getmethods__["epsilon"] = _sim3dlong.LJishPair_epsilon_get
    if _newclass:epsilon = _swig_property(_sim3dlong.LJishPair_epsilon_get, _sim3dlong.LJishPair_epsilon_set)
    __swig_setmethods__["repeps"] = _sim3dlong.LJishPair_repeps_set
    __swig_getmethods__["repeps"] = _sim3dlong.LJishPair_repeps_get
    if _newclass:repeps = _swig_property(_sim3dlong.LJishPair_repeps_get, _sim3dlong.LJishPair_repeps_set)
    __swig_setmethods__["sigma"] = _sim3dlong.LJishPair_sigma_set
    __swig_getmethods__["sigma"] = _sim3dlong.LJishPair_sigma_get
    if _newclass:sigma = _swig_property(_sim3dlong.LJishPair_sigma_get, _sim3dlong.LJishPair_sigma_set)
    __swig_setmethods__["n"] = _sim3dlong.LJishPair_n_set
    __swig_getmethods__["n"] = _sim3dlong.LJishPair_n_get
    if _newclass:n = _swig_property(_sim3dlong.LJishPair_n_get, _sim3dlong.LJishPair_n_set)
    __swig_setmethods__["cutR"] = _sim3dlong.LJishPair_cutR_set
    __swig_getmethods__["cutR"] = _sim3dlong.LJishPair_cutR_get
    if _newclass:cutR = _swig_property(_sim3dlong.LJishPair_cutR_get, _sim3dlong.LJishPair_cutR_set)
    __swig_setmethods__["cutE"] = _sim3dlong.LJishPair_cutE_set
    __swig_getmethods__["cutE"] = _sim3dlong.LJishPair_cutE_get
    if _newclass:cutE = _swig_property(_sim3dlong.LJishPair_cutE_get, _sim3dlong.LJishPair_cutE_set)
    __swig_setmethods__["atom1"] = _sim3dlong.LJishPair_atom1_set
    __swig_getmethods__["atom1"] = _sim3dlong.LJishPair_atom1_get
    if _newclass:atom1 = _swig_property(_sim3dlong.LJishPair_atom1_get, _sim3dlong.LJishPair_atom1_set)
    __swig_setmethods__["atom2"] = _sim3dlong.LJishPair_atom2_set
    __swig_getmethods__["atom2"] = _sim3dlong.LJishPair_atom2_get
    if _newclass:atom2 = _swig_property(_sim3dlong.LJishPair_atom2_get, _sim3dlong.LJishPair_atom2_set)
    def __init__(self, *args): 
        """__init__(LJishPair self, LJishAtom LJ1, LJishAtom LJ2) -> LJishPair"""
        this = _sim3dlong.new_LJishPair(*args)
        try: self.this.append(this)
        except: self.this = this
    def energy(self, *args) -> "flt" :
        """energy(LJishPair self, Box box) -> flt"""
        return _sim3dlong.LJishPair_energy(self, *args)

    def forces(self, *args) -> "Vec" :
        """forces(LJishPair self, Box box) -> VecL"""
        return _sim3dlong.LJishPair_forces(self, *args)

    __swig_destroy__ = _sim3dlong.delete_LJishPair
    __del__ = lambda self : None;
LJishPair_swigregister = _sim3dlong.LJishPair_swigregister
LJishPair_swigregister(LJishPair)

class LJAttractRepulseAtom(atomid):
    """Proxy of C++ LJAttractRepulseAtom class"""
    __swig_setmethods__ = {}
    for _s in [atomid]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJAttractRepulseAtom, name, value)
    __swig_getmethods__ = {}
    for _s in [atomid]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LJAttractRepulseAtom, name)
    __repr__ = _swig_repr
    __swig_setmethods__["epsilons"] = _sim3dlong.LJAttractRepulseAtom_epsilons_set
    __swig_getmethods__["epsilons"] = _sim3dlong.LJAttractRepulseAtom_epsilons_get
    if _newclass:epsilons = _swig_property(_sim3dlong.LJAttractRepulseAtom_epsilons_get, _sim3dlong.LJAttractRepulseAtom_epsilons_set)
    __swig_setmethods__["sig"] = _sim3dlong.LJAttractRepulseAtom_sig_set
    __swig_getmethods__["sig"] = _sim3dlong.LJAttractRepulseAtom_sig_get
    if _newclass:sig = _swig_property(_sim3dlong.LJAttractRepulseAtom_sig_get, _sim3dlong.LJAttractRepulseAtom_sig_set)
    __swig_setmethods__["indx"] = _sim3dlong.LJAttractRepulseAtom_indx_set
    __swig_getmethods__["indx"] = _sim3dlong.LJAttractRepulseAtom_indx_get
    if _newclass:indx = _swig_property(_sim3dlong.LJAttractRepulseAtom_indx_get, _sim3dlong.LJAttractRepulseAtom_indx_set)
    __swig_setmethods__["sigcut"] = _sim3dlong.LJAttractRepulseAtom_sigcut_set
    __swig_getmethods__["sigcut"] = _sim3dlong.LJAttractRepulseAtom_sigcut_get
    if _newclass:sigcut = _swig_property(_sim3dlong.LJAttractRepulseAtom_sigcut_get, _sim3dlong.LJAttractRepulseAtom_sigcut_set)
    def __init__(self, *args): 
        """
        __init__(LJAttractRepulseAtom self, atom a, ldvector epsilons, flt sigma, uint indx, flt cut) -> LJAttractRepulseAtom
        __init__(LJAttractRepulseAtom self, atomid a, LJAttractRepulseAtom other) -> LJAttractRepulseAtom
        """
        this = _sim3dlong.new_LJAttractRepulseAtom(*args)
        try: self.this.append(this)
        except: self.this = this
    def getEpsilon(self, *args) -> "flt" :
        """getEpsilon(LJAttractRepulseAtom self, LJAttractRepulseAtom other) -> flt"""
        return _sim3dlong.LJAttractRepulseAtom_getEpsilon(self, *args)

    __swig_destroy__ = _sim3dlong.delete_LJAttractRepulseAtom
    __del__ = lambda self : None;
LJAttractRepulseAtom_swigregister = _sim3dlong.LJAttractRepulseAtom_swigregister
LJAttractRepulseAtom_swigregister(LJAttractRepulseAtom)

class LJAttractRepulsePair(_object):
    """Proxy of C++ LJAttractRepulsePair class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJAttractRepulsePair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LJAttractRepulsePair, name)
    __repr__ = _swig_repr
    __swig_setmethods__["eps"] = _sim3dlong.LJAttractRepulsePair_eps_set
    __swig_getmethods__["eps"] = _sim3dlong.LJAttractRepulsePair_eps_get
    if _newclass:eps = _swig_property(_sim3dlong.LJAttractRepulsePair_eps_get, _sim3dlong.LJAttractRepulsePair_eps_set)
    __swig_setmethods__["sig"] = _sim3dlong.LJAttractRepulsePair_sig_set
    __swig_getmethods__["sig"] = _sim3dlong.LJAttractRepulsePair_sig_get
    if _newclass:sig = _swig_property(_sim3dlong.LJAttractRepulsePair_sig_get, _sim3dlong.LJAttractRepulsePair_sig_set)
    __swig_setmethods__["cutR"] = _sim3dlong.LJAttractRepulsePair_cutR_set
    __swig_getmethods__["cutR"] = _sim3dlong.LJAttractRepulsePair_cutR_get
    if _newclass:cutR = _swig_property(_sim3dlong.LJAttractRepulsePair_cutR_get, _sim3dlong.LJAttractRepulsePair_cutR_set)
    __swig_setmethods__["cutE"] = _sim3dlong.LJAttractRepulsePair_cutE_set
    __swig_getmethods__["cutE"] = _sim3dlong.LJAttractRepulsePair_cutE_get
    if _newclass:cutE = _swig_property(_sim3dlong.LJAttractRepulsePair_cutE_get, _sim3dlong.LJAttractRepulsePair_cutE_set)
    __swig_setmethods__["atom1"] = _sim3dlong.LJAttractRepulsePair_atom1_set
    __swig_getmethods__["atom1"] = _sim3dlong.LJAttractRepulsePair_atom1_get
    if _newclass:atom1 = _swig_property(_sim3dlong.LJAttractRepulsePair_atom1_get, _sim3dlong.LJAttractRepulsePair_atom1_set)
    __swig_setmethods__["atom2"] = _sim3dlong.LJAttractRepulsePair_atom2_set
    __swig_getmethods__["atom2"] = _sim3dlong.LJAttractRepulsePair_atom2_get
    if _newclass:atom2 = _swig_property(_sim3dlong.LJAttractRepulsePair_atom2_get, _sim3dlong.LJAttractRepulsePair_atom2_set)
    def __init__(self, *args): 
        """__init__(LJAttractRepulsePair self, LJAttractRepulseAtom a1, LJAttractRepulseAtom a2) -> LJAttractRepulsePair"""
        this = _sim3dlong.new_LJAttractRepulsePair(*args)
        try: self.this.append(this)
        except: self.this = this
    def energy(self, *args) -> "flt" :
        """energy(LJAttractRepulsePair self, Box box) -> flt"""
        return _sim3dlong.LJAttractRepulsePair_energy(self, *args)

    def forces(self, *args) -> "Vec" :
        """forces(LJAttractRepulsePair self, Box box) -> VecL"""
        return _sim3dlong.LJAttractRepulsePair_forces(self, *args)

    __swig_destroy__ = _sim3dlong.delete_LJAttractRepulsePair
    __del__ = lambda self : None;
LJAttractRepulsePair_swigregister = _sim3dlong.LJAttractRepulsePair_swigregister
LJAttractRepulsePair_swigregister(LJAttractRepulsePair)

class LJAttractFixedRepulseAtom(atomid):
    """Proxy of C++ LJAttractFixedRepulseAtom class"""
    __swig_setmethods__ = {}
    for _s in [atomid]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJAttractFixedRepulseAtom, name, value)
    __swig_getmethods__ = {}
    for _s in [atomid]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LJAttractFixedRepulseAtom, name)
    __repr__ = _swig_repr
    __swig_setmethods__["epsilons"] = _sim3dlong.LJAttractFixedRepulseAtom_epsilons_set
    __swig_getmethods__["epsilons"] = _sim3dlong.LJAttractFixedRepulseAtom_epsilons_get
    if _newclass:epsilons = _swig_property(_sim3dlong.LJAttractFixedRepulseAtom_epsilons_get, _sim3dlong.LJAttractFixedRepulseAtom_epsilons_set)
    __swig_setmethods__["repeps"] = _sim3dlong.LJAttractFixedRepulseAtom_repeps_set
    __swig_getmethods__["repeps"] = _sim3dlong.LJAttractFixedRepulseAtom_repeps_get
    if _newclass:repeps = _swig_property(_sim3dlong.LJAttractFixedRepulseAtom_repeps_get, _sim3dlong.LJAttractFixedRepulseAtom_repeps_set)
    __swig_setmethods__["sig"] = _sim3dlong.LJAttractFixedRepulseAtom_sig_set
    __swig_getmethods__["sig"] = _sim3dlong.LJAttractFixedRepulseAtom_sig_get
    if _newclass:sig = _swig_property(_sim3dlong.LJAttractFixedRepulseAtom_sig_get, _sim3dlong.LJAttractFixedRepulseAtom_sig_set)
    __swig_setmethods__["indx"] = _sim3dlong.LJAttractFixedRepulseAtom_indx_set
    __swig_getmethods__["indx"] = _sim3dlong.LJAttractFixedRepulseAtom_indx_get
    if _newclass:indx = _swig_property(_sim3dlong.LJAttractFixedRepulseAtom_indx_get, _sim3dlong.LJAttractFixedRepulseAtom_indx_set)
    __swig_setmethods__["sigcut"] = _sim3dlong.LJAttractFixedRepulseAtom_sigcut_set
    __swig_getmethods__["sigcut"] = _sim3dlong.LJAttractFixedRepulseAtom_sigcut_get
    if _newclass:sigcut = _swig_property(_sim3dlong.LJAttractFixedRepulseAtom_sigcut_get, _sim3dlong.LJAttractFixedRepulseAtom_sigcut_set)
    def __init__(self, *args): 
        """
        __init__(LJAttractFixedRepulseAtom self, atom a, ldvector epsilons, flt repeps, flt sigma, uint indx, flt cut) -> LJAttractFixedRepulseAtom
        __init__(LJAttractFixedRepulseAtom self, atomid a, LJAttractFixedRepulseAtom other) -> LJAttractFixedRepulseAtom
        """
        this = _sim3dlong.new_LJAttractFixedRepulseAtom(*args)
        try: self.this.append(this)
        except: self.this = this
    def getEpsilon(self, *args) -> "flt" :
        """getEpsilon(LJAttractFixedRepulseAtom self, LJAttractFixedRepulseAtom other) -> flt"""
        return _sim3dlong.LJAttractFixedRepulseAtom_getEpsilon(self, *args)

    __swig_destroy__ = _sim3dlong.delete_LJAttractFixedRepulseAtom
    __del__ = lambda self : None;
LJAttractFixedRepulseAtom_swigregister = _sim3dlong.LJAttractFixedRepulseAtom_swigregister
LJAttractFixedRepulseAtom_swigregister(LJAttractFixedRepulseAtom)

class LJAttractFixedRepulsePair(_object):
    """Proxy of C++ LJAttractFixedRepulsePair class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJAttractFixedRepulsePair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LJAttractFixedRepulsePair, name)
    __repr__ = _swig_repr
    __swig_setmethods__["eps"] = _sim3dlong.LJAttractFixedRepulsePair_eps_set
    __swig_getmethods__["eps"] = _sim3dlong.LJAttractFixedRepulsePair_eps_get
    if _newclass:eps = _swig_property(_sim3dlong.LJAttractFixedRepulsePair_eps_get, _sim3dlong.LJAttractFixedRepulsePair_eps_set)
    __swig_setmethods__["repeps"] = _sim3dlong.LJAttractFixedRepulsePair_repeps_set
    __swig_getmethods__["repeps"] = _sim3dlong.LJAttractFixedRepulsePair_repeps_get
    if _newclass:repeps = _swig_property(_sim3dlong.LJAttractFixedRepulsePair_repeps_get, _sim3dlong.LJAttractFixedRepulsePair_repeps_set)
    __swig_setmethods__["sig"] = _sim3dlong.LJAttractFixedRepulsePair_sig_set
    __swig_getmethods__["sig"] = _sim3dlong.LJAttractFixedRepulsePair_sig_get
    if _newclass:sig = _swig_property(_sim3dlong.LJAttractFixedRepulsePair_sig_get, _sim3dlong.LJAttractFixedRepulsePair_sig_set)
    __swig_setmethods__["cutR"] = _sim3dlong.LJAttractFixedRepulsePair_cutR_set
    __swig_getmethods__["cutR"] = _sim3dlong.LJAttractFixedRepulsePair_cutR_get
    if _newclass:cutR = _swig_property(_sim3dlong.LJAttractFixedRepulsePair_cutR_get, _sim3dlong.LJAttractFixedRepulsePair_cutR_set)
    __swig_setmethods__["cutE"] = _sim3dlong.LJAttractFixedRepulsePair_cutE_set
    __swig_getmethods__["cutE"] = _sim3dlong.LJAttractFixedRepulsePair_cutE_get
    if _newclass:cutE = _swig_property(_sim3dlong.LJAttractFixedRepulsePair_cutE_get, _sim3dlong.LJAttractFixedRepulsePair_cutE_set)
    __swig_setmethods__["attract"] = _sim3dlong.LJAttractFixedRepulsePair_attract_set
    __swig_getmethods__["attract"] = _sim3dlong.LJAttractFixedRepulsePair_attract_get
    if _newclass:attract = _swig_property(_sim3dlong.LJAttractFixedRepulsePair_attract_get, _sim3dlong.LJAttractFixedRepulsePair_attract_set)
    __swig_setmethods__["atom1"] = _sim3dlong.LJAttractFixedRepulsePair_atom1_set
    __swig_getmethods__["atom1"] = _sim3dlong.LJAttractFixedRepulsePair_atom1_get
    if _newclass:atom1 = _swig_property(_sim3dlong.LJAttractFixedRepulsePair_atom1_get, _sim3dlong.LJAttractFixedRepulsePair_atom1_set)
    __swig_setmethods__["atom2"] = _sim3dlong.LJAttractFixedRepulsePair_atom2_set
    __swig_getmethods__["atom2"] = _sim3dlong.LJAttractFixedRepulsePair_atom2_get
    if _newclass:atom2 = _swig_property(_sim3dlong.LJAttractFixedRepulsePair_atom2_get, _sim3dlong.LJAttractFixedRepulsePair_atom2_set)
    def __init__(self, *args): 
        """
        __init__(LJAttractFixedRepulsePair self) -> LJAttractFixedRepulsePair
        __init__(LJAttractFixedRepulsePair self, LJAttractFixedRepulseAtom a1, LJAttractFixedRepulseAtom a2) -> LJAttractFixedRepulsePair
        """
        this = _sim3dlong.new_LJAttractFixedRepulsePair(*args)
        try: self.this.append(this)
        except: self.this = this
    def energy(self, *args) -> "flt" :
        """energy(LJAttractFixedRepulsePair self, Box box) -> flt"""
        return _sim3dlong.LJAttractFixedRepulsePair_energy(self, *args)

    def forces(self, *args) -> "Vec" :
        """forces(LJAttractFixedRepulsePair self, Box box) -> VecL"""
        return _sim3dlong.LJAttractFixedRepulsePair_forces(self, *args)

    __swig_destroy__ = _sim3dlong.delete_LJAttractFixedRepulsePair
    __del__ = lambda self : None;
LJAttractFixedRepulsePair_swigregister = _sim3dlong.LJAttractFixedRepulsePair_swigregister
LJAttractFixedRepulsePair_swigregister(LJAttractFixedRepulsePair)

class LJDoubleAtom(LJatom):
    """Proxy of C++ LJDoubleAtom class"""
    __swig_setmethods__ = {}
    for _s in [LJatom]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJDoubleAtom, name, value)
    __swig_getmethods__ = {}
    for _s in [LJatom]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LJDoubleAtom, name)
    __repr__ = _swig_repr
    __swig_setmethods__["epsrep"] = _sim3dlong.LJDoubleAtom_epsrep_set
    __swig_getmethods__["epsrep"] = _sim3dlong.LJDoubleAtom_epsrep_get
    if _newclass:epsrep = _swig_property(_sim3dlong.LJDoubleAtom_epsrep_get, _sim3dlong.LJDoubleAtom_epsrep_set)
    __swig_setmethods__["sigcut"] = _sim3dlong.LJDoubleAtom_sigcut_set
    __swig_getmethods__["sigcut"] = _sim3dlong.LJDoubleAtom_sigcut_get
    if _newclass:sigcut = _swig_property(_sim3dlong.LJDoubleAtom_sigcut_get, _sim3dlong.LJDoubleAtom_sigcut_set)
    def __init__(self, *args): 
        """
        __init__(LJDoubleAtom self, flt epsilon, flt epsrep, flt sigma, atom a, flt cut) -> LJDoubleAtom
        __init__(LJDoubleAtom self, atomid a, LJDoubleAtom other) -> LJDoubleAtom
        """
        this = _sim3dlong.new_LJDoubleAtom(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _sim3dlong.delete_LJDoubleAtom
    __del__ = lambda self : None;
LJDoubleAtom_swigregister = _sim3dlong.LJDoubleAtom_swigregister
LJDoubleAtom_swigregister(LJDoubleAtom)

class LJDoublePair(LJAttractFixedRepulsePair):
    """Proxy of C++ LJDoublePair class"""
    __swig_setmethods__ = {}
    for _s in [LJAttractFixedRepulsePair]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJDoublePair, name, value)
    __swig_getmethods__ = {}
    for _s in [LJAttractFixedRepulsePair]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LJDoublePair, name)
    __repr__ = _swig_repr
    __swig_setmethods__["eps"] = _sim3dlong.LJDoublePair_eps_set
    __swig_getmethods__["eps"] = _sim3dlong.LJDoublePair_eps_get
    if _newclass:eps = _swig_property(_sim3dlong.LJDoublePair_eps_get, _sim3dlong.LJDoublePair_eps_set)
    __swig_setmethods__["repeps"] = _sim3dlong.LJDoublePair_repeps_set
    __swig_getmethods__["repeps"] = _sim3dlong.LJDoublePair_repeps_get
    if _newclass:repeps = _swig_property(_sim3dlong.LJDoublePair_repeps_get, _sim3dlong.LJDoublePair_repeps_set)
    __swig_setmethods__["sig"] = _sim3dlong.LJDoublePair_sig_set
    __swig_getmethods__["sig"] = _sim3dlong.LJDoublePair_sig_get
    if _newclass:sig = _swig_property(_sim3dlong.LJDoublePair_sig_get, _sim3dlong.LJDoublePair_sig_set)
    __swig_setmethods__["cutR"] = _sim3dlong.LJDoublePair_cutR_set
    __swig_getmethods__["cutR"] = _sim3dlong.LJDoublePair_cutR_get
    if _newclass:cutR = _swig_property(_sim3dlong.LJDoublePair_cutR_get, _sim3dlong.LJDoublePair_cutR_set)
    __swig_setmethods__["cutE"] = _sim3dlong.LJDoublePair_cutE_set
    __swig_getmethods__["cutE"] = _sim3dlong.LJDoublePair_cutE_get
    if _newclass:cutE = _swig_property(_sim3dlong.LJDoublePair_cutE_get, _sim3dlong.LJDoublePair_cutE_set)
    __swig_setmethods__["attract"] = _sim3dlong.LJDoublePair_attract_set
    __swig_getmethods__["attract"] = _sim3dlong.LJDoublePair_attract_get
    if _newclass:attract = _swig_property(_sim3dlong.LJDoublePair_attract_get, _sim3dlong.LJDoublePair_attract_set)
    __swig_setmethods__["atom1"] = _sim3dlong.LJDoublePair_atom1_set
    __swig_getmethods__["atom1"] = _sim3dlong.LJDoublePair_atom1_get
    if _newclass:atom1 = _swig_property(_sim3dlong.LJDoublePair_atom1_get, _sim3dlong.LJDoublePair_atom1_set)
    __swig_setmethods__["atom2"] = _sim3dlong.LJDoublePair_atom2_set
    __swig_getmethods__["atom2"] = _sim3dlong.LJDoublePair_atom2_get
    if _newclass:atom2 = _swig_property(_sim3dlong.LJDoublePair_atom2_get, _sim3dlong.LJDoublePair_atom2_set)
    def __init__(self, *args): 
        """__init__(LJDoublePair self, LJDoubleAtom a1, LJDoubleAtom a2) -> LJDoublePair"""
        this = _sim3dlong.new_LJDoublePair(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _sim3dlong.delete_LJDoublePair
    __del__ = lambda self : None;
LJDoublePair_swigregister = _sim3dlong.LJDoublePair_swigregister
LJDoublePair_swigregister(LJDoublePair)

class EisMclachlanAtom(atomid):
    """Proxy of C++ EisMclachlanAtom class"""
    __swig_setmethods__ = {}
    for _s in [atomid]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, EisMclachlanAtom, name, value)
    __swig_getmethods__ = {}
    for _s in [atomid]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, EisMclachlanAtom, name)
    __repr__ = _swig_repr
    __swig_setmethods__["dist"] = _sim3dlong.EisMclachlanAtom_dist_set
    __swig_getmethods__["dist"] = _sim3dlong.EisMclachlanAtom_dist_get
    if _newclass:dist = _swig_property(_sim3dlong.EisMclachlanAtom_dist_get, _sim3dlong.EisMclachlanAtom_dist_set)
    __swig_setmethods__["sigmai"] = _sim3dlong.EisMclachlanAtom_sigmai_set
    __swig_getmethods__["sigmai"] = _sim3dlong.EisMclachlanAtom_sigmai_get
    if _newclass:sigmai = _swig_property(_sim3dlong.EisMclachlanAtom_sigmai_get, _sim3dlong.EisMclachlanAtom_sigmai_set)
    def __init__(self, *args): 
        """
        __init__(EisMclachlanAtom self, flt dist, flt sigmai, atom a) -> EisMclachlanAtom
        __init__(EisMclachlanAtom self, atomid a, EisMclachlanAtom other) -> EisMclachlanAtom
        """
        this = _sim3dlong.new_EisMclachlanAtom(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _sim3dlong.delete_EisMclachlanAtom
    __del__ = lambda self : None;
EisMclachlanAtom_swigregister = _sim3dlong.EisMclachlanAtom_swigregister
EisMclachlanAtom_swigregister(EisMclachlanAtom)

class EisMclachlanPair(_object):
    """Proxy of C++ EisMclachlanPair class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, EisMclachlanPair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, EisMclachlanPair, name)
    __repr__ = _swig_repr
    __swig_setmethods__["c0"] = _sim3dlong.EisMclachlanPair_c0_set
    __swig_getmethods__["c0"] = _sim3dlong.EisMclachlanPair_c0_get
    if _newclass:c0 = _swig_property(_sim3dlong.EisMclachlanPair_c0_get, _sim3dlong.EisMclachlanPair_c0_set)
    __swig_setmethods__["c1"] = _sim3dlong.EisMclachlanPair_c1_set
    __swig_getmethods__["c1"] = _sim3dlong.EisMclachlanPair_c1_get
    if _newclass:c1 = _swig_property(_sim3dlong.EisMclachlanPair_c1_get, _sim3dlong.EisMclachlanPair_c1_set)
    __swig_setmethods__["c2"] = _sim3dlong.EisMclachlanPair_c2_set
    __swig_getmethods__["c2"] = _sim3dlong.EisMclachlanPair_c2_get
    if _newclass:c2 = _swig_property(_sim3dlong.EisMclachlanPair_c2_get, _sim3dlong.EisMclachlanPair_c2_set)
    __swig_setmethods__["cutoff"] = _sim3dlong.EisMclachlanPair_cutoff_set
    __swig_getmethods__["cutoff"] = _sim3dlong.EisMclachlanPair_cutoff_get
    if _newclass:cutoff = _swig_property(_sim3dlong.EisMclachlanPair_cutoff_get, _sim3dlong.EisMclachlanPair_cutoff_set)
    __swig_setmethods__["atom1"] = _sim3dlong.EisMclachlanPair_atom1_set
    __swig_getmethods__["atom1"] = _sim3dlong.EisMclachlanPair_atom1_get
    if _newclass:atom1 = _swig_property(_sim3dlong.EisMclachlanPair_atom1_get, _sim3dlong.EisMclachlanPair_atom1_set)
    __swig_setmethods__["atom2"] = _sim3dlong.EisMclachlanPair_atom2_set
    __swig_getmethods__["atom2"] = _sim3dlong.EisMclachlanPair_atom2_get
    if _newclass:atom2 = _swig_property(_sim3dlong.EisMclachlanPair_atom2_get, _sim3dlong.EisMclachlanPair_atom2_set)
    def __init__(self, *args): 
        """__init__(EisMclachlanPair self, EisMclachlanAtom a1, EisMclachlanAtom a2) -> EisMclachlanPair"""
        this = _sim3dlong.new_EisMclachlanPair(*args)
        try: self.this.append(this)
        except: self.this = this
    def energy(self, *args) -> "flt" :
        """energy(EisMclachlanPair self, Box box) -> flt"""
        return _sim3dlong.EisMclachlanPair_energy(self, *args)

    def forces(self, *args) -> "Vec" :
        """forces(EisMclachlanPair self, Box box) -> VecL"""
        return _sim3dlong.EisMclachlanPair_forces(self, *args)

    __swig_destroy__ = _sim3dlong.delete_EisMclachlanPair
    __del__ = lambda self : None;
EisMclachlanPair_swigregister = _sim3dlong.EisMclachlanPair_swigregister
EisMclachlanPair_swigregister(EisMclachlanPair)

class HertzianAtom(atomid):
    """Proxy of C++ HertzianAtom class"""
    __swig_setmethods__ = {}
    for _s in [atomid]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HertzianAtom, name, value)
    __swig_getmethods__ = {}
    for _s in [atomid]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, HertzianAtom, name)
    __repr__ = _swig_repr
    __swig_setmethods__["eps"] = _sim3dlong.HertzianAtom_eps_set
    __swig_getmethods__["eps"] = _sim3dlong.HertzianAtom_eps_get
    if _newclass:eps = _swig_property(_sim3dlong.HertzianAtom_eps_get, _sim3dlong.HertzianAtom_eps_set)
    __swig_setmethods__["sigma"] = _sim3dlong.HertzianAtom_sigma_set
    __swig_getmethods__["sigma"] = _sim3dlong.HertzianAtom_sigma_get
    if _newclass:sigma = _swig_property(_sim3dlong.HertzianAtom_sigma_get, _sim3dlong.HertzianAtom_sigma_set)
    __swig_setmethods__["exponent"] = _sim3dlong.HertzianAtom_exponent_set
    __swig_getmethods__["exponent"] = _sim3dlong.HertzianAtom_exponent_get
    if _newclass:exponent = _swig_property(_sim3dlong.HertzianAtom_exponent_get, _sim3dlong.HertzianAtom_exponent_set)
    def __init__(self, *args): 
        """
        __init__(HertzianAtom self, atom a, flt eps, flt sigma, flt exponent=2.5) -> HertzianAtom
        __init__(HertzianAtom self, atom a, flt eps, flt sigma) -> HertzianAtom
        __init__(HertzianAtom self, atomid a, HertzianAtom other) -> HertzianAtom
        """
        this = _sim3dlong.new_HertzianAtom(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _sim3dlong.delete_HertzianAtom
    __del__ = lambda self : None;
HertzianAtom_swigregister = _sim3dlong.HertzianAtom_swigregister
HertzianAtom_swigregister(HertzianAtom)


def hertzd(*args) -> "HertzianAtom" :
  """
    hertzd(atom a, double eps, double sigma, double exponent=2.5) -> HertzianAtom
    hertzd(atom a, double eps, double sigma) -> HertzianAtom
    """
  return _sim3dlong.hertzd(*args)
class EnergyForce(_object):
    """Proxy of C++ EnergyForce class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, EnergyForce, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, EnergyForce, name)
    __repr__ = _swig_repr
    __swig_setmethods__["f"] = _sim3dlong.EnergyForce_f_set
    __swig_getmethods__["f"] = _sim3dlong.EnergyForce_f_get
    if _newclass:f = _swig_property(_sim3dlong.EnergyForce_f_get, _sim3dlong.EnergyForce_f_set)
    __swig_setmethods__["E"] = _sim3dlong.EnergyForce_E_set
    __swig_getmethods__["E"] = _sim3dlong.EnergyForce_E_get
    if _newclass:E = _swig_property(_sim3dlong.EnergyForce_E_get, _sim3dlong.EnergyForce_E_set)
    def __init__(self, *args): 
        """__init__(EnergyForce self, VecL f, flt E) -> EnergyForce"""
        this = _sim3dlong.new_EnergyForce(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _sim3dlong.delete_EnergyForce
    __del__ = lambda self : None;
EnergyForce_swigregister = _sim3dlong.EnergyForce_swigregister
EnergyForce_swigregister(EnergyForce)

class HertzianPair(_object):
    """Proxy of C++ HertzianPair class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, HertzianPair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, HertzianPair, name)
    __repr__ = _swig_repr
    __swig_setmethods__["eps"] = _sim3dlong.HertzianPair_eps_set
    __swig_getmethods__["eps"] = _sim3dlong.HertzianPair_eps_get
    if _newclass:eps = _swig_property(_sim3dlong.HertzianPair_eps_get, _sim3dlong.HertzianPair_eps_set)
    __swig_setmethods__["sig"] = _sim3dlong.HertzianPair_sig_set
    __swig_getmethods__["sig"] = _sim3dlong.HertzianPair_sig_get
    if _newclass:sig = _swig_property(_sim3dlong.HertzianPair_sig_get, _sim3dlong.HertzianPair_sig_set)
    __swig_setmethods__["exponent"] = _sim3dlong.HertzianPair_exponent_set
    __swig_getmethods__["exponent"] = _sim3dlong.HertzianPair_exponent_get
    if _newclass:exponent = _swig_property(_sim3dlong.HertzianPair_exponent_get, _sim3dlong.HertzianPair_exponent_set)
    __swig_setmethods__["atom1"] = _sim3dlong.HertzianPair_atom1_set
    __swig_getmethods__["atom1"] = _sim3dlong.HertzianPair_atom1_get
    if _newclass:atom1 = _swig_property(_sim3dlong.HertzianPair_atom1_get, _sim3dlong.HertzianPair_atom1_set)
    __swig_setmethods__["atom2"] = _sim3dlong.HertzianPair_atom2_set
    __swig_getmethods__["atom2"] = _sim3dlong.HertzianPair_atom2_get
    if _newclass:atom2 = _swig_property(_sim3dlong.HertzianPair_atom2_get, _sim3dlong.HertzianPair_atom2_set)
    def __init__(self, *args): 
        """__init__(HertzianPair self, HertzianAtom a1, HertzianAtom a2) -> HertzianPair"""
        this = _sim3dlong.new_HertzianPair(*args)
        try: self.this.append(this)
        except: self.this = this
    def energy(self, *args) -> "flt" :
        """energy(HertzianPair self, Box box) -> flt"""
        return _sim3dlong.HertzianPair_energy(self, *args)

    def forces(self, *args) -> "Vec" :
        """forces(HertzianPair self, Box box) -> VecL"""
        return _sim3dlong.HertzianPair_forces(self, *args)

    def EnergyForces(self, *args) -> "EnergyForce" :
        """EnergyForces(HertzianPair self, Box box) -> EnergyForce"""
        return _sim3dlong.HertzianPair_EnergyForces(self, *args)

    def fill(self, *args) -> "void" :
        """fill(HertzianPair self, Box box, forcepairx fpair)"""
        return _sim3dlong.HertzianPair_fill(self, *args)

    __swig_destroy__ = _sim3dlong.delete_HertzianPair
    __del__ = lambda self : None;
HertzianPair_swigregister = _sim3dlong.HertzianPair_swigregister
HertzianPair_swigregister(HertzianPair)

class LoisOhernAtom(atomid):
    """Proxy of C++ LoisOhernAtom class"""
    __swig_setmethods__ = {}
    for _s in [atomid]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LoisOhernAtom, name, value)
    __swig_getmethods__ = {}
    for _s in [atomid]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LoisOhernAtom, name)
    __repr__ = _swig_repr
    __swig_setmethods__["eps"] = _sim3dlong.LoisOhernAtom_eps_set
    __swig_getmethods__["eps"] = _sim3dlong.LoisOhernAtom_eps_get
    if _newclass:eps = _swig_property(_sim3dlong.LoisOhernAtom_eps_get, _sim3dlong.LoisOhernAtom_eps_set)
    __swig_setmethods__["sigma"] = _sim3dlong.LoisOhernAtom_sigma_set
    __swig_getmethods__["sigma"] = _sim3dlong.LoisOhernAtom_sigma_get
    if _newclass:sigma = _swig_property(_sim3dlong.LoisOhernAtom_sigma_get, _sim3dlong.LoisOhernAtom_sigma_set)
    __swig_setmethods__["C"] = _sim3dlong.LoisOhernAtom_C_set
    __swig_getmethods__["C"] = _sim3dlong.LoisOhernAtom_C_get
    if _newclass:C = _swig_property(_sim3dlong.LoisOhernAtom_C_get, _sim3dlong.LoisOhernAtom_C_set)
    __swig_setmethods__["l"] = _sim3dlong.LoisOhernAtom_l_set
    __swig_getmethods__["l"] = _sim3dlong.LoisOhernAtom_l_get
    if _newclass:l = _swig_property(_sim3dlong.LoisOhernAtom_l_get, _sim3dlong.LoisOhernAtom_l_set)
    def __init__(self, *args): 
        """
        __init__(LoisOhernAtom self, atom a, flt eps, flt sigma, flt C, flt l) -> LoisOhernAtom
        __init__(LoisOhernAtom self, atomid a, LoisOhernAtom other) -> LoisOhernAtom
        """
        this = _sim3dlong.new_LoisOhernAtom(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _sim3dlong.delete_LoisOhernAtom
    __del__ = lambda self : None;
LoisOhernAtom_swigregister = _sim3dlong.LoisOhernAtom_swigregister
LoisOhernAtom_swigregister(LoisOhernAtom)

class LoisOhernPair(_object):
    """Proxy of C++ LoisOhernPair class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LoisOhernPair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LoisOhernPair, name)
    __repr__ = _swig_repr
    __swig_setmethods__["eps"] = _sim3dlong.LoisOhernPair_eps_set
    __swig_getmethods__["eps"] = _sim3dlong.LoisOhernPair_eps_get
    if _newclass:eps = _swig_property(_sim3dlong.LoisOhernPair_eps_get, _sim3dlong.LoisOhernPair_eps_set)
    __swig_setmethods__["sig"] = _sim3dlong.LoisOhernPair_sig_set
    __swig_getmethods__["sig"] = _sim3dlong.LoisOhernPair_sig_get
    if _newclass:sig = _swig_property(_sim3dlong.LoisOhernPair_sig_get, _sim3dlong.LoisOhernPair_sig_set)
    __swig_setmethods__["C"] = _sim3dlong.LoisOhernPair_C_set
    __swig_getmethods__["C"] = _sim3dlong.LoisOhernPair_C_get
    if _newclass:C = _swig_property(_sim3dlong.LoisOhernPair_C_get, _sim3dlong.LoisOhernPair_C_set)
    __swig_setmethods__["l"] = _sim3dlong.LoisOhernPair_l_set
    __swig_getmethods__["l"] = _sim3dlong.LoisOhernPair_l_get
    if _newclass:l = _swig_property(_sim3dlong.LoisOhernPair_l_get, _sim3dlong.LoisOhernPair_l_set)
    __swig_setmethods__["sigcut"] = _sim3dlong.LoisOhernPair_sigcut_set
    __swig_getmethods__["sigcut"] = _sim3dlong.LoisOhernPair_sigcut_get
    if _newclass:sigcut = _swig_property(_sim3dlong.LoisOhernPair_sigcut_get, _sim3dlong.LoisOhernPair_sigcut_set)
    __swig_setmethods__["atom1"] = _sim3dlong.LoisOhernPair_atom1_set
    __swig_getmethods__["atom1"] = _sim3dlong.LoisOhernPair_atom1_get
    if _newclass:atom1 = _swig_property(_sim3dlong.LoisOhernPair_atom1_get, _sim3dlong.LoisOhernPair_atom1_set)
    __swig_setmethods__["atom2"] = _sim3dlong.LoisOhernPair_atom2_set
    __swig_getmethods__["atom2"] = _sim3dlong.LoisOhernPair_atom2_get
    if _newclass:atom2 = _swig_property(_sim3dlong.LoisOhernPair_atom2_get, _sim3dlong.LoisOhernPair_atom2_set)
    def __init__(self, *args): 
        """__init__(LoisOhernPair self, LoisOhernAtom a1, LoisOhernAtom a2) -> LoisOhernPair"""
        this = _sim3dlong.new_LoisOhernPair(*args)
        try: self.this.append(this)
        except: self.this = this
    def energy(self, *args) -> "flt" :
        """energy(LoisOhernPair self, Box box) -> flt"""
        return _sim3dlong.LoisOhernPair_energy(self, *args)

    def forces(self, *args) -> "Vec" :
        """forces(LoisOhernPair self, Box box) -> VecL"""
        return _sim3dlong.LoisOhernPair_forces(self, *args)

    __swig_destroy__ = _sim3dlong.delete_LoisOhernPair
    __del__ = lambda self : None;
LoisOhernPair_swigregister = _sim3dlong.LoisOhernPair_swigregister
LoisOhernPair_swigregister(LoisOhernPair)

class LJsimple(interaction):
    """Proxy of C++ LJsimple class"""
    __swig_setmethods__ = {}
    for _s in [interaction]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJsimple, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LJsimple, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(LJsimple self, flt cutoffdist, std::vector< LJatom > atms=std::vector< LJatom >()) -> LJsimple
        __init__(LJsimple self, flt cutoffdist) -> LJsimple
        """
        this = _sim3dlong.new_LJsimple(*args)
        try: self.this.append(this)
        except: self.this = this
    def add(self, *args) -> "void" :
        """
        add(LJsimple self, LJatom a)
        add(LJsimple self, atom a, flt epsilon, flt sigma)
        """
        return _sim3dlong.LJsimple_add(self, *args)

    def ignore(self, *args) -> "void" :
        """
        ignore(LJsimple self, atomid a, atomid b)
        ignore(LJsimple self, atom a, atom b)
        """
        return _sim3dlong.LJsimple_ignore(self, *args)

    def ignore_size(self) -> "uint" :
        """ignore_size(LJsimple self) -> uint"""
        return _sim3dlong.LJsimple_ignore_size(self)

    def atoms_size(self) -> "uint" :
        """atoms_size(LJsimple self) -> uint"""
        return _sim3dlong.LJsimple_atoms_size(self)

    def energy(self, *args) -> "flt" :
        """energy(LJsimple self, Box box) -> flt"""
        return _sim3dlong.LJsimple_energy(self, *args)

    def pressure(self, *args) -> "flt" :
        """pressure(LJsimple self, Box box) -> flt"""
        return _sim3dlong.LJsimple_pressure(self, *args)

    def setForces(self, *args) -> "void" :
        """setForces(LJsimple self, Box box)"""
        return _sim3dlong.LJsimple_setForces(self, *args)

    __swig_destroy__ = _sim3dlong.delete_LJsimple
    __del__ = lambda self : None;
LJsimple_swigregister = _sim3dlong.LJsimple_swigregister
LJsimple_swigregister(LJsimple)

class Charges(interaction):
    """Proxy of C++ Charges class"""
    __swig_setmethods__ = {}
    for _s in [interaction]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Charges, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Charges, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(Charges self, flt screenlength, flt k=1, std::vector< Charged > atms=std::vector< Charged >()) -> Charges
        __init__(Charges self, flt screenlength, flt k=1) -> Charges
        __init__(Charges self, flt screenlength) -> Charges
        """
        this = _sim3dlong.new_Charges(*args)
        try: self.this.append(this)
        except: self.this = this
    def add(self, *args) -> "void" :
        """
        add(Charges self, Charged a)
        add(Charges self, atom a, flt q)
        """
        return _sim3dlong.Charges_add(self, *args)

    def ignore(self, *args) -> "void" :
        """
        ignore(Charges self, atomid a, atomid b)
        ignore(Charges self, atom a, atom b)
        """
        return _sim3dlong.Charges_ignore(self, *args)

    def ignore_size(self) -> "uint" :
        """ignore_size(Charges self) -> uint"""
        return _sim3dlong.Charges_ignore_size(self)

    def size(self) -> "uint" :
        """size(Charges self) -> uint"""
        return _sim3dlong.Charges_size(self)

    def energy(self, *args) -> "flt" :
        """energy(Charges self, Box box) -> flt"""
        return _sim3dlong.Charges_energy(self, *args)

    def pressure(self, *args) -> "flt" :
        """pressure(Charges self, Box box) -> flt"""
        return _sim3dlong.Charges_pressure(self, *args)

    def setForces(self, *args) -> "void" :
        """setForces(Charges self, Box box)"""
        return _sim3dlong.Charges_setForces(self, *args)

    __swig_destroy__ = _sim3dlong.delete_Charges
    __del__ = lambda self : None;
Charges_swigregister = _sim3dlong.Charges_swigregister
Charges_swigregister(Charges)


def toBuffer(*args) -> "bool" :
  """toBuffer(vecptrvectorL arr, double * buffer) -> bool"""
  return _sim3dlong.toBuffer(*args)
class jamminglist(_object):
    """Proxy of C++ jamminglist class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, jamminglist, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, jamminglist, name)
    __repr__ = _swig_repr
    __swig_setmethods__["assigned"] = _sim3dlong.jamminglist_assigned_set
    __swig_getmethods__["assigned"] = _sim3dlong.jamminglist_assigned_get
    if _newclass:assigned = _swig_property(_sim3dlong.jamminglist_assigned_get, _sim3dlong.jamminglist_assigned_set)
    __swig_setmethods__["distsq"] = _sim3dlong.jamminglist_distsq_set
    __swig_getmethods__["distsq"] = _sim3dlong.jamminglist_distsq_get
    if _newclass:distsq = _swig_property(_sim3dlong.jamminglist_distsq_get, _sim3dlong.jamminglist_distsq_set)
    def __init__(self, *args): 
        """
        __init__(jamminglist self) -> jamminglist
        __init__(jamminglist self, jamminglist other) -> jamminglist
        __init__(jamminglist self, jamminglist other, uint expand, flt addeddist) -> jamminglist
        """
        this = _sim3dlong.new_jamminglist(*args)
        try: self.this.append(this)
        except: self.this = this
    def size(self) -> "uint" :
        """size(jamminglist self) -> uint"""
        return _sim3dlong.jamminglist_size(self)

    def __lt__(self, *args) -> "bool" :
        """__lt__(jamminglist self, jamminglist other) -> bool"""
        return _sim3dlong.jamminglist___lt__(self, *args)

    __swig_destroy__ = _sim3dlong.delete_jamminglist
    __del__ = lambda self : None;
jamminglist_swigregister = _sim3dlong.jamminglist_swigregister
jamminglist_swigregister(jamminglist)

class jammingtree(_object):
    """Proxy of C++ jammingtree class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, jammingtree, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, jammingtree, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(jammingtree self, Box box, vecvectorL A, vecvectorL B) -> jammingtree"""
        this = _sim3dlong.new_jammingtree(*args)
        try: self.this.append(this)
        except: self.this = this
    def expand(self, *args) -> "bool" :
        """
        expand(jammingtree self) -> bool
        expand(jammingtree self, uint n) -> bool
        """
        return _sim3dlong.jammingtree_expand(self, *args)

    def mylist(self) -> "std::list< jamminglist > &" :
        """mylist(jammingtree self) -> std::list< jamminglist > &"""
        return _sim3dlong.jammingtree_mylist(self)

    def copylist(self) -> "std::list< jamminglist >" :
        """copylist(jammingtree self) -> std::list< jamminglist >"""
        return _sim3dlong.jammingtree_copylist(self)

    def curbest(self) -> "jamminglist" :
        """curbest(jammingtree self) -> jamminglist"""
        return _sim3dlong.jammingtree_curbest(self)

    def size(self) -> "uint" :
        """size(jammingtree self) -> uint"""
        return _sim3dlong.jammingtree_size(self)

    __swig_destroy__ = _sim3dlong.delete_jammingtree
    __del__ = lambda self : None;
jammingtree_swigregister = _sim3dlong.jammingtree_swigregister
jammingtree_swigregister(jammingtree)

class constraint(_object):
    """Proxy of C++ constraint class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, constraint, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, constraint, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def apply(self, *args) -> "void" :
        """apply(constraint self, Box box)"""
        return _sim3dlong.constraint_apply(self, *args)

    def ndof(self) -> "int" :
        """ndof(constraint self) -> int"""
        return _sim3dlong.constraint_ndof(self)

    __swig_destroy__ = _sim3dlong.delete_constraint
    __del__ = lambda self : None;
constraint_swigregister = _sim3dlong.constraint_swigregister
constraint_swigregister(constraint)

class coordConstraint(constraint):
    """Proxy of C++ coordConstraint class"""
    __swig_setmethods__ = {}
    for _s in [constraint]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, coordConstraint, name, value)
    __swig_getmethods__ = {}
    for _s in [constraint]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, coordConstraint, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(coordConstraint self, atom atm, bool fixx, bool fixy, bool fixz, VecL loc) -> coordConstraint
        __init__(coordConstraint self, atom atm, bool fixx, bool fixy, bool fixz) -> coordConstraint
        __init__(coordConstraint self, atom atm) -> coordConstraint
        """
        this = _sim3dlong.new_coordConstraint(*args)
        try: self.this.append(this)
        except: self.this = this
    def ndof(self) -> "int" :
        """ndof(coordConstraint self) -> int"""
        return _sim3dlong.coordConstraint_ndof(self)

    def apply(self, *args) -> "void" :
        """apply(coordConstraint self, Box box)"""
        return _sim3dlong.coordConstraint_apply(self, *args)

    __swig_destroy__ = _sim3dlong.delete_coordConstraint
    __del__ = lambda self : None;
coordConstraint_swigregister = _sim3dlong.coordConstraint_swigregister
coordConstraint_swigregister(coordConstraint)

class coordCOMConstraint(constraint):
    """Proxy of C++ coordCOMConstraint class"""
    __swig_setmethods__ = {}
    for _s in [constraint]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, coordCOMConstraint, name, value)
    __swig_getmethods__ = {}
    for _s in [constraint]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, coordCOMConstraint, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(coordCOMConstraint self, atomgroup atm, bool fixx, bool fixy, bool fixz, VecL loc) -> coordCOMConstraint
        __init__(coordCOMConstraint self, atomgroup atm, bool fixx, bool fixy, bool fixz) -> coordCOMConstraint
        __init__(coordCOMConstraint self, atomgroup atm) -> coordCOMConstraint
        """
        this = _sim3dlong.new_coordCOMConstraint(*args)
        try: self.this.append(this)
        except: self.this = this
    def ndof(self) -> "int" :
        """ndof(coordCOMConstraint self) -> int"""
        return _sim3dlong.coordCOMConstraint_ndof(self)

    def apply(self, *args) -> "void" :
        """apply(coordCOMConstraint self, Box box)"""
        return _sim3dlong.coordCOMConstraint_apply(self, *args)

    __swig_destroy__ = _sim3dlong.delete_coordCOMConstraint
    __del__ = lambda self : None;
coordCOMConstraint_swigregister = _sim3dlong.coordCOMConstraint_swigregister
coordCOMConstraint_swigregister(coordCOMConstraint)

class relativeConstraint(constraint):
    """Proxy of C++ relativeConstraint class"""
    __swig_setmethods__ = {}
    for _s in [constraint]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, relativeConstraint, name, value)
    __swig_getmethods__ = {}
    for _s in [constraint]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, relativeConstraint, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(relativeConstraint self, atom atm1, atom atm2, bool fixx, bool fixy, bool fixz, VecL loc) -> relativeConstraint
        __init__(relativeConstraint self, atom atm1, atom atm2, bool fixx, bool fixy, bool fixz) -> relativeConstraint
        __init__(relativeConstraint self, atom atm1, atom atm2) -> relativeConstraint
        """
        this = _sim3dlong.new_relativeConstraint(*args)
        try: self.this.append(this)
        except: self.this = this
    def ndof(self) -> "int" :
        """ndof(relativeConstraint self) -> int"""
        return _sim3dlong.relativeConstraint_ndof(self)

    def apply(self, *args) -> "void" :
        """apply(relativeConstraint self, Box box)"""
        return _sim3dlong.relativeConstraint_apply(self, *args)

    __swig_destroy__ = _sim3dlong.delete_relativeConstraint
    __del__ = lambda self : None;
relativeConstraint_swigregister = _sim3dlong.relativeConstraint_swigregister
relativeConstraint_swigregister(relativeConstraint)

class NPHGaussianConstraint(constraint):
    """Proxy of C++ NPHGaussianConstraint class"""
    __swig_setmethods__ = {}
    for _s in [constraint]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, NPHGaussianConstraint, name, value)
    __swig_getmethods__ = {}
    for _s in [constraint]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, NPHGaussianConstraint, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(NPHGaussianConstraint self, OriginBox box, avector groups) -> NPHGaussianConstraint"""
        this = _sim3dlong.new_NPHGaussianConstraint(*args)
        try: self.this.append(this)
        except: self.this = this
    def ndof(self) -> "int" :
        """ndof(NPHGaussianConstraint self) -> int"""
        return _sim3dlong.NPHGaussianConstraint_ndof(self)

    def apply(self, *args) -> "void" :
        """apply(NPHGaussianConstraint self, Box box2)"""
        return _sim3dlong.NPHGaussianConstraint_apply(self, *args)

    __swig_destroy__ = _sim3dlong.delete_NPHGaussianConstraint
    __del__ = lambda self : None;
NPHGaussianConstraint_swigregister = _sim3dlong.NPHGaussianConstraint_swigregister
NPHGaussianConstraint_swigregister(NPHGaussianConstraint)

class LJgroup(interaction):
    """Proxy of C++ NListed<(LJatom,LJpair)> class"""
    __swig_setmethods__ = {}
    for _s in [interaction]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJgroup, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LJgroup, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(NListed<(LJatom,LJpair)> self, neighborlist neighbors) -> LJgroup"""
        this = _sim3dlong.new_LJgroup(*args)
        try: self.this.append(this)
        except: self.this = this
    def add(self, *args) -> "void" :
        """add(LJgroup self, LJatom atm)"""
        return _sim3dlong.LJgroup_add(self, *args)

    def update_pairs(self) -> "void" :
        """update_pairs(LJgroup self)"""
        return _sim3dlong.LJgroup_update_pairs(self)

    def getpair(self, *args) -> "LJpair" :
        """getpair(LJgroup self, idpair pair) -> LJpair"""
        return _sim3dlong.LJgroup_getpair(self, *args)

    def energy(self, *args) -> "flt" :
        """
        energy(LJgroup self, Box box, idpair pair) -> flt
        energy(LJgroup self, Box box) -> flt
        """
        return _sim3dlong.LJgroup_energy(self, *args)

    def pressure(self, *args) -> "flt" :
        """pressure(LJgroup self, Box box) -> flt"""
        return _sim3dlong.LJgroup_pressure(self, *args)

    def size(self) -> "uint" :
        """size(LJgroup self) -> uint"""
        return _sim3dlong.LJgroup_size(self)

    def energy_pair(self, *args) -> "flt" :
        """energy_pair(LJgroup self, LJpair pair, Box box) -> flt"""
        return _sim3dlong.LJgroup_energy_pair(self, *args)

    def setForces(self, *args) -> "void" :
        """setForces(LJgroup self, Box box)"""
        return _sim3dlong.LJgroup_setForces(self, *args)

    def setForcesGetPressure(self, *args) -> "flt" :
        """setForcesGetPressure(LJgroup self, Box box) -> flt"""
        return _sim3dlong.LJgroup_setForcesGetPressure(self, *args)

    def forces_pair(self, *args) -> "Vec" :
        """forces_pair(LJgroup self, LJpair pair, Box box) -> VecL"""
        return _sim3dlong.LJgroup_forces_pair(self, *args)

    def atom_list(self) -> "std::vector< LJatom > &" :
        """atom_list(LJgroup self) -> std::vector< LJatom > &"""
        return _sim3dlong.LJgroup_atom_list(self)

    def nlist(self) -> "neighborlist *" :
        """nlist(LJgroup self) -> neighborlist"""
        return _sim3dlong.LJgroup_nlist(self)

    __swig_destroy__ = _sim3dlong.delete_LJgroup
    __del__ = lambda self : None;
    def add_atom(self, epsilon, sigma, a):
        self.add(LJatom(epsilon, sigma, a))

LJgroup_swigregister = _sim3dlong.LJgroup_swigregister
LJgroup_swigregister(LJgroup)

class LJfull(interaction):
    """Proxy of C++ NListed<(LJatomcut,LJAttractPair)> class"""
    __swig_setmethods__ = {}
    for _s in [interaction]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJfull, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LJfull, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(NListed<(LJatomcut,LJAttractPair)> self, neighborlist neighbors) -> LJfull"""
        this = _sim3dlong.new_LJfull(*args)
        try: self.this.append(this)
        except: self.this = this
    def add(self, *args) -> "void" :
        """add(LJfull self, LJatomcut atm)"""
        return _sim3dlong.LJfull_add(self, *args)

    def update_pairs(self) -> "void" :
        """update_pairs(LJfull self)"""
        return _sim3dlong.LJfull_update_pairs(self)

    def getpair(self, *args) -> "LJAttractPair" :
        """getpair(LJfull self, idpair pair) -> LJAttractPair"""
        return _sim3dlong.LJfull_getpair(self, *args)

    def energy(self, *args) -> "flt" :
        """
        energy(LJfull self, Box box, idpair pair) -> flt
        energy(LJfull self, Box box) -> flt
        """
        return _sim3dlong.LJfull_energy(self, *args)

    def pressure(self, *args) -> "flt" :
        """pressure(LJfull self, Box box) -> flt"""
        return _sim3dlong.LJfull_pressure(self, *args)

    def size(self) -> "uint" :
        """size(LJfull self) -> uint"""
        return _sim3dlong.LJfull_size(self)

    def energy_pair(self, *args) -> "flt" :
        """energy_pair(LJfull self, LJAttractPair pair, Box box) -> flt"""
        return _sim3dlong.LJfull_energy_pair(self, *args)

    def setForces(self, *args) -> "void" :
        """setForces(LJfull self, Box box)"""
        return _sim3dlong.LJfull_setForces(self, *args)

    def setForcesGetPressure(self, *args) -> "flt" :
        """setForcesGetPressure(LJfull self, Box box) -> flt"""
        return _sim3dlong.LJfull_setForcesGetPressure(self, *args)

    def forces_pair(self, *args) -> "Vec" :
        """forces_pair(LJfull self, LJAttractPair pair, Box box) -> VecL"""
        return _sim3dlong.LJfull_forces_pair(self, *args)

    def atom_list(self) -> "std::vector< LJatomcut > &" :
        """atom_list(LJfull self) -> std::vector< LJatomcut > &"""
        return _sim3dlong.LJfull_atom_list(self)

    def nlist(self) -> "neighborlist *" :
        """nlist(LJfull self) -> neighborlist"""
        return _sim3dlong.LJfull_nlist(self)

    __swig_destroy__ = _sim3dlong.delete_LJfull
    __del__ = lambda self : None;
    def add_atom(self, epsilon, sigma, a, cut):
        self.add(LJatomcut(epsilon, sigma, a, cut))

LJfull_swigregister = _sim3dlong.LJfull_swigregister
LJfull_swigregister(LJfull)

class Hydrophobicity(interaction):
    """Proxy of C++ NListed<(HydroAtom,HydroPair)> class"""
    __swig_setmethods__ = {}
    for _s in [interaction]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Hydrophobicity, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Hydrophobicity, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(NListed<(HydroAtom,HydroPair)> self, neighborlist neighbors) -> Hydrophobicity"""
        this = _sim3dlong.new_Hydrophobicity(*args)
        try: self.this.append(this)
        except: self.this = this
    def add(self, *args) -> "void" :
        """add(Hydrophobicity self, HydroAtom atm)"""
        return _sim3dlong.Hydrophobicity_add(self, *args)

    def update_pairs(self) -> "void" :
        """update_pairs(Hydrophobicity self)"""
        return _sim3dlong.Hydrophobicity_update_pairs(self)

    def getpair(self, *args) -> "HydroPair" :
        """getpair(Hydrophobicity self, idpair pair) -> HydroPair"""
        return _sim3dlong.Hydrophobicity_getpair(self, *args)

    def energy(self, *args) -> "flt" :
        """
        energy(Hydrophobicity self, Box box, idpair pair) -> flt
        energy(Hydrophobicity self, Box box) -> flt
        """
        return _sim3dlong.Hydrophobicity_energy(self, *args)

    def pressure(self, *args) -> "flt" :
        """pressure(Hydrophobicity self, Box box) -> flt"""
        return _sim3dlong.Hydrophobicity_pressure(self, *args)

    def size(self) -> "uint" :
        """size(Hydrophobicity self) -> uint"""
        return _sim3dlong.Hydrophobicity_size(self)

    def energy_pair(self, *args) -> "flt" :
        """energy_pair(Hydrophobicity self, HydroPair pair, Box box) -> flt"""
        return _sim3dlong.Hydrophobicity_energy_pair(self, *args)

    def setForces(self, *args) -> "void" :
        """setForces(Hydrophobicity self, Box box)"""
        return _sim3dlong.Hydrophobicity_setForces(self, *args)

    def setForcesGetPressure(self, *args) -> "flt" :
        """setForcesGetPressure(Hydrophobicity self, Box box) -> flt"""
        return _sim3dlong.Hydrophobicity_setForcesGetPressure(self, *args)

    def forces_pair(self, *args) -> "Vec" :
        """forces_pair(Hydrophobicity self, HydroPair pair, Box box) -> VecL"""
        return _sim3dlong.Hydrophobicity_forces_pair(self, *args)

    def atom_list(self) -> "std::vector< HydroAtom > &" :
        """atom_list(Hydrophobicity self) -> std::vector< HydroAtom > &"""
        return _sim3dlong.Hydrophobicity_atom_list(self)

    def nlist(self) -> "neighborlist *" :
        """nlist(Hydrophobicity self) -> neighborlist"""
        return _sim3dlong.Hydrophobicity_nlist(self)

    __swig_destroy__ = _sim3dlong.delete_Hydrophobicity
    __del__ = lambda self : None;
Hydrophobicity_swigregister = _sim3dlong.Hydrophobicity_swigregister
Hydrophobicity_swigregister(Hydrophobicity)

class LJdetailed(interaction):
    """Proxy of C++ NListed<(LJAtomIndexed,LJFullPair)> class"""
    __swig_setmethods__ = {}
    for _s in [interaction]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJdetailed, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LJdetailed, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(NListed<(LJAtomIndexed,LJFullPair)> self, neighborlist neighbors) -> LJdetailed"""
        this = _sim3dlong.new_LJdetailed(*args)
        try: self.this.append(this)
        except: self.this = this
    def add(self, *args) -> "void" :
        """add(LJdetailed self, LJAtomIndexed atm)"""
        return _sim3dlong.LJdetailed_add(self, *args)

    def update_pairs(self) -> "void" :
        """update_pairs(LJdetailed self)"""
        return _sim3dlong.LJdetailed_update_pairs(self)

    def getpair(self, *args) -> "LJFullPair" :
        """getpair(LJdetailed self, idpair pair) -> LJFullPair"""
        return _sim3dlong.LJdetailed_getpair(self, *args)

    def energy(self, *args) -> "flt" :
        """
        energy(LJdetailed self, Box box, idpair pair) -> flt
        energy(LJdetailed self, Box box) -> flt
        """
        return _sim3dlong.LJdetailed_energy(self, *args)

    def pressure(self, *args) -> "flt" :
        """pressure(LJdetailed self, Box box) -> flt"""
        return _sim3dlong.LJdetailed_pressure(self, *args)

    def size(self) -> "uint" :
        """size(LJdetailed self) -> uint"""
        return _sim3dlong.LJdetailed_size(self)

    def energy_pair(self, *args) -> "flt" :
        """energy_pair(LJdetailed self, LJFullPair pair, Box box) -> flt"""
        return _sim3dlong.LJdetailed_energy_pair(self, *args)

    def setForces(self, *args) -> "void" :
        """setForces(LJdetailed self, Box box)"""
        return _sim3dlong.LJdetailed_setForces(self, *args)

    def setForcesGetPressure(self, *args) -> "flt" :
        """setForcesGetPressure(LJdetailed self, Box box) -> flt"""
        return _sim3dlong.LJdetailed_setForcesGetPressure(self, *args)

    def forces_pair(self, *args) -> "Vec" :
        """forces_pair(LJdetailed self, LJFullPair pair, Box box) -> VecL"""
        return _sim3dlong.LJdetailed_forces_pair(self, *args)

    def atom_list(self) -> "std::vector< LJAtomIndexed > &" :
        """atom_list(LJdetailed self) -> std::vector< LJAtomIndexed > &"""
        return _sim3dlong.LJdetailed_atom_list(self)

    def nlist(self) -> "neighborlist *" :
        """nlist(LJdetailed self) -> neighborlist"""
        return _sim3dlong.LJdetailed_nlist(self)

    __swig_destroy__ = _sim3dlong.delete_LJdetailed
    __del__ = lambda self : None;
LJdetailed_swigregister = _sim3dlong.LJdetailed_swigregister
LJdetailed_swigregister(LJdetailed)

class LJAttractRepulse(interaction):
    """Proxy of C++ NListed<(LJAttractRepulseAtom,LJAttractRepulsePair)> class"""
    __swig_setmethods__ = {}
    for _s in [interaction]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJAttractRepulse, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LJAttractRepulse, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(NListed<(LJAttractRepulseAtom,LJAttractRepulsePair)> self, neighborlist neighbors) -> LJAttractRepulse"""
        this = _sim3dlong.new_LJAttractRepulse(*args)
        try: self.this.append(this)
        except: self.this = this
    def add(self, *args) -> "void" :
        """add(LJAttractRepulse self, LJAttractRepulseAtom atm)"""
        return _sim3dlong.LJAttractRepulse_add(self, *args)

    def update_pairs(self) -> "void" :
        """update_pairs(LJAttractRepulse self)"""
        return _sim3dlong.LJAttractRepulse_update_pairs(self)

    def getpair(self, *args) -> "LJAttractRepulsePair" :
        """getpair(LJAttractRepulse self, idpair pair) -> LJAttractRepulsePair"""
        return _sim3dlong.LJAttractRepulse_getpair(self, *args)

    def energy(self, *args) -> "flt" :
        """
        energy(LJAttractRepulse self, Box box, idpair pair) -> flt
        energy(LJAttractRepulse self, Box box) -> flt
        """
        return _sim3dlong.LJAttractRepulse_energy(self, *args)

    def pressure(self, *args) -> "flt" :
        """pressure(LJAttractRepulse self, Box box) -> flt"""
        return _sim3dlong.LJAttractRepulse_pressure(self, *args)

    def size(self) -> "uint" :
        """size(LJAttractRepulse self) -> uint"""
        return _sim3dlong.LJAttractRepulse_size(self)

    def energy_pair(self, *args) -> "flt" :
        """energy_pair(LJAttractRepulse self, LJAttractRepulsePair pair, Box box) -> flt"""
        return _sim3dlong.LJAttractRepulse_energy_pair(self, *args)

    def setForces(self, *args) -> "void" :
        """setForces(LJAttractRepulse self, Box box)"""
        return _sim3dlong.LJAttractRepulse_setForces(self, *args)

    def setForcesGetPressure(self, *args) -> "flt" :
        """setForcesGetPressure(LJAttractRepulse self, Box box) -> flt"""
        return _sim3dlong.LJAttractRepulse_setForcesGetPressure(self, *args)

    def forces_pair(self, *args) -> "Vec" :
        """forces_pair(LJAttractRepulse self, LJAttractRepulsePair pair, Box box) -> VecL"""
        return _sim3dlong.LJAttractRepulse_forces_pair(self, *args)

    def atom_list(self) -> "std::vector< LJAttractRepulseAtom > &" :
        """atom_list(LJAttractRepulse self) -> std::vector< LJAttractRepulseAtom > &"""
        return _sim3dlong.LJAttractRepulse_atom_list(self)

    def nlist(self) -> "neighborlist *" :
        """nlist(LJAttractRepulse self) -> neighborlist"""
        return _sim3dlong.LJAttractRepulse_nlist(self)

    __swig_destroy__ = _sim3dlong.delete_LJAttractRepulse
    __del__ = lambda self : None;
LJAttractRepulse_swigregister = _sim3dlong.LJAttractRepulse_swigregister
LJAttractRepulse_swigregister(LJAttractRepulse)

class LJAttractFixedRepulse(interaction):
    """Proxy of C++ NListed<(LJAttractFixedRepulseAtom,LJAttractFixedRepulsePair)> class"""
    __swig_setmethods__ = {}
    for _s in [interaction]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJAttractFixedRepulse, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LJAttractFixedRepulse, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(NListed<(LJAttractFixedRepulseAtom,LJAttractFixedRepulsePair)> self, neighborlist neighbors) -> LJAttractFixedRepulse"""
        this = _sim3dlong.new_LJAttractFixedRepulse(*args)
        try: self.this.append(this)
        except: self.this = this
    def add(self, *args) -> "void" :
        """add(LJAttractFixedRepulse self, LJAttractFixedRepulseAtom atm)"""
        return _sim3dlong.LJAttractFixedRepulse_add(self, *args)

    def update_pairs(self) -> "void" :
        """update_pairs(LJAttractFixedRepulse self)"""
        return _sim3dlong.LJAttractFixedRepulse_update_pairs(self)

    def getpair(self, *args) -> "LJAttractFixedRepulsePair" :
        """getpair(LJAttractFixedRepulse self, idpair pair) -> LJAttractFixedRepulsePair"""
        return _sim3dlong.LJAttractFixedRepulse_getpair(self, *args)

    def energy(self, *args) -> "flt" :
        """
        energy(LJAttractFixedRepulse self, Box box, idpair pair) -> flt
        energy(LJAttractFixedRepulse self, Box box) -> flt
        """
        return _sim3dlong.LJAttractFixedRepulse_energy(self, *args)

    def pressure(self, *args) -> "flt" :
        """pressure(LJAttractFixedRepulse self, Box box) -> flt"""
        return _sim3dlong.LJAttractFixedRepulse_pressure(self, *args)

    def size(self) -> "uint" :
        """size(LJAttractFixedRepulse self) -> uint"""
        return _sim3dlong.LJAttractFixedRepulse_size(self)

    def energy_pair(self, *args) -> "flt" :
        """energy_pair(LJAttractFixedRepulse self, LJAttractFixedRepulsePair pair, Box box) -> flt"""
        return _sim3dlong.LJAttractFixedRepulse_energy_pair(self, *args)

    def setForces(self, *args) -> "void" :
        """setForces(LJAttractFixedRepulse self, Box box)"""
        return _sim3dlong.LJAttractFixedRepulse_setForces(self, *args)

    def setForcesGetPressure(self, *args) -> "flt" :
        """setForcesGetPressure(LJAttractFixedRepulse self, Box box) -> flt"""
        return _sim3dlong.LJAttractFixedRepulse_setForcesGetPressure(self, *args)

    def forces_pair(self, *args) -> "Vec" :
        """forces_pair(LJAttractFixedRepulse self, LJAttractFixedRepulsePair pair, Box box) -> VecL"""
        return _sim3dlong.LJAttractFixedRepulse_forces_pair(self, *args)

    def atom_list(self) -> "std::vector< LJAttractFixedRepulseAtom > &" :
        """atom_list(LJAttractFixedRepulse self) -> std::vector< LJAttractFixedRepulseAtom > &"""
        return _sim3dlong.LJAttractFixedRepulse_atom_list(self)

    def nlist(self) -> "neighborlist *" :
        """nlist(LJAttractFixedRepulse self) -> neighborlist"""
        return _sim3dlong.LJAttractFixedRepulse_nlist(self)

    __swig_destroy__ = _sim3dlong.delete_LJAttractFixedRepulse
    __del__ = lambda self : None;
LJAttractFixedRepulse_swigregister = _sim3dlong.LJAttractFixedRepulse_swigregister
LJAttractFixedRepulse_swigregister(LJAttractFixedRepulse)

class LJDouble(interaction):
    """Proxy of C++ NListed<(LJDoubleAtom,LJDoublePair)> class"""
    __swig_setmethods__ = {}
    for _s in [interaction]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJDouble, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LJDouble, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(NListed<(LJDoubleAtom,LJDoublePair)> self, neighborlist neighbors) -> LJDouble"""
        this = _sim3dlong.new_LJDouble(*args)
        try: self.this.append(this)
        except: self.this = this
    def add(self, *args) -> "void" :
        """add(LJDouble self, LJDoubleAtom atm)"""
        return _sim3dlong.LJDouble_add(self, *args)

    def update_pairs(self) -> "void" :
        """update_pairs(LJDouble self)"""
        return _sim3dlong.LJDouble_update_pairs(self)

    def getpair(self, *args) -> "LJDoublePair" :
        """getpair(LJDouble self, idpair pair) -> LJDoublePair"""
        return _sim3dlong.LJDouble_getpair(self, *args)

    def energy(self, *args) -> "flt" :
        """
        energy(LJDouble self, Box box, idpair pair) -> flt
        energy(LJDouble self, Box box) -> flt
        """
        return _sim3dlong.LJDouble_energy(self, *args)

    def pressure(self, *args) -> "flt" :
        """pressure(LJDouble self, Box box) -> flt"""
        return _sim3dlong.LJDouble_pressure(self, *args)

    def size(self) -> "uint" :
        """size(LJDouble self) -> uint"""
        return _sim3dlong.LJDouble_size(self)

    def energy_pair(self, *args) -> "flt" :
        """energy_pair(LJDouble self, LJDoublePair pair, Box box) -> flt"""
        return _sim3dlong.LJDouble_energy_pair(self, *args)

    def setForces(self, *args) -> "void" :
        """setForces(LJDouble self, Box box)"""
        return _sim3dlong.LJDouble_setForces(self, *args)

    def setForcesGetPressure(self, *args) -> "flt" :
        """setForcesGetPressure(LJDouble self, Box box) -> flt"""
        return _sim3dlong.LJDouble_setForcesGetPressure(self, *args)

    def forces_pair(self, *args) -> "Vec" :
        """forces_pair(LJDouble self, LJDoublePair pair, Box box) -> VecL"""
        return _sim3dlong.LJDouble_forces_pair(self, *args)

    def atom_list(self) -> "std::vector< LJDoubleAtom > &" :
        """atom_list(LJDouble self) -> std::vector< LJDoubleAtom > &"""
        return _sim3dlong.LJDouble_atom_list(self)

    def nlist(self) -> "neighborlist *" :
        """nlist(LJDouble self) -> neighborlist"""
        return _sim3dlong.LJDouble_nlist(self)

    __swig_destroy__ = _sim3dlong.delete_LJDouble
    __del__ = lambda self : None;
LJDouble_swigregister = _sim3dlong.LJDouble_swigregister
LJDouble_swigregister(LJDouble)

class EisMclachlan(interaction):
    """Proxy of C++ NListed<(EisMclachlanAtom,EisMclachlanPair)> class"""
    __swig_setmethods__ = {}
    for _s in [interaction]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, EisMclachlan, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, EisMclachlan, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(NListed<(EisMclachlanAtom,EisMclachlanPair)> self, neighborlist neighbors) -> EisMclachlan"""
        this = _sim3dlong.new_EisMclachlan(*args)
        try: self.this.append(this)
        except: self.this = this
    def add(self, *args) -> "void" :
        """add(EisMclachlan self, EisMclachlanAtom atm)"""
        return _sim3dlong.EisMclachlan_add(self, *args)

    def update_pairs(self) -> "void" :
        """update_pairs(EisMclachlan self)"""
        return _sim3dlong.EisMclachlan_update_pairs(self)

    def getpair(self, *args) -> "EisMclachlanPair" :
        """getpair(EisMclachlan self, idpair pair) -> EisMclachlanPair"""
        return _sim3dlong.EisMclachlan_getpair(self, *args)

    def energy(self, *args) -> "flt" :
        """
        energy(EisMclachlan self, Box box, idpair pair) -> flt
        energy(EisMclachlan self, Box box) -> flt
        """
        return _sim3dlong.EisMclachlan_energy(self, *args)

    def pressure(self, *args) -> "flt" :
        """pressure(EisMclachlan self, Box box) -> flt"""
        return _sim3dlong.EisMclachlan_pressure(self, *args)

    def size(self) -> "uint" :
        """size(EisMclachlan self) -> uint"""
        return _sim3dlong.EisMclachlan_size(self)

    def energy_pair(self, *args) -> "flt" :
        """energy_pair(EisMclachlan self, EisMclachlanPair pair, Box box) -> flt"""
        return _sim3dlong.EisMclachlan_energy_pair(self, *args)

    def setForces(self, *args) -> "void" :
        """setForces(EisMclachlan self, Box box)"""
        return _sim3dlong.EisMclachlan_setForces(self, *args)

    def setForcesGetPressure(self, *args) -> "flt" :
        """setForcesGetPressure(EisMclachlan self, Box box) -> flt"""
        return _sim3dlong.EisMclachlan_setForcesGetPressure(self, *args)

    def forces_pair(self, *args) -> "Vec" :
        """forces_pair(EisMclachlan self, EisMclachlanPair pair, Box box) -> VecL"""
        return _sim3dlong.EisMclachlan_forces_pair(self, *args)

    def atom_list(self) -> "std::vector< EisMclachlanAtom > &" :
        """atom_list(EisMclachlan self) -> std::vector< EisMclachlanAtom > &"""
        return _sim3dlong.EisMclachlan_atom_list(self)

    def nlist(self) -> "neighborlist *" :
        """nlist(EisMclachlan self) -> neighborlist"""
        return _sim3dlong.EisMclachlan_nlist(self)

    __swig_destroy__ = _sim3dlong.delete_EisMclachlan
    __del__ = lambda self : None;
EisMclachlan_swigregister = _sim3dlong.EisMclachlan_swigregister
EisMclachlan_swigregister(EisMclachlan)

class LJish(interaction):
    """Proxy of C++ NListed<(LJishAtom,LJishPair)> class"""
    __swig_setmethods__ = {}
    for _s in [interaction]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJish, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LJish, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(NListed<(LJishAtom,LJishPair)> self, neighborlist neighbors) -> LJish"""
        this = _sim3dlong.new_LJish(*args)
        try: self.this.append(this)
        except: self.this = this
    def add(self, *args) -> "void" :
        """add(LJish self, LJishAtom atm)"""
        return _sim3dlong.LJish_add(self, *args)

    def update_pairs(self) -> "void" :
        """update_pairs(LJish self)"""
        return _sim3dlong.LJish_update_pairs(self)

    def getpair(self, *args) -> "LJishPair" :
        """getpair(LJish self, idpair pair) -> LJishPair"""
        return _sim3dlong.LJish_getpair(self, *args)

    def energy(self, *args) -> "flt" :
        """
        energy(LJish self, Box box, idpair pair) -> flt
        energy(LJish self, Box box) -> flt
        """
        return _sim3dlong.LJish_energy(self, *args)

    def pressure(self, *args) -> "flt" :
        """pressure(LJish self, Box box) -> flt"""
        return _sim3dlong.LJish_pressure(self, *args)

    def size(self) -> "uint" :
        """size(LJish self) -> uint"""
        return _sim3dlong.LJish_size(self)

    def energy_pair(self, *args) -> "flt" :
        """energy_pair(LJish self, LJishPair pair, Box box) -> flt"""
        return _sim3dlong.LJish_energy_pair(self, *args)

    def setForces(self, *args) -> "void" :
        """setForces(LJish self, Box box)"""
        return _sim3dlong.LJish_setForces(self, *args)

    def setForcesGetPressure(self, *args) -> "flt" :
        """setForcesGetPressure(LJish self, Box box) -> flt"""
        return _sim3dlong.LJish_setForcesGetPressure(self, *args)

    def forces_pair(self, *args) -> "Vec" :
        """forces_pair(LJish self, LJishPair pair, Box box) -> VecL"""
        return _sim3dlong.LJish_forces_pair(self, *args)

    def atom_list(self) -> "std::vector< LJishAtom > &" :
        """atom_list(LJish self) -> std::vector< LJishAtom > &"""
        return _sim3dlong.LJish_atom_list(self)

    def nlist(self) -> "neighborlist *" :
        """nlist(LJish self) -> neighborlist"""
        return _sim3dlong.LJish_nlist(self)

    __swig_destroy__ = _sim3dlong.delete_LJish
    __del__ = lambda self : None;
LJish_swigregister = _sim3dlong.LJish_swigregister
LJish_swigregister(LJish)

class HertzianSimple(interaction):
    """Proxy of C++ SimpleListed<(HertzianAtom,HertzianPair)> class"""
    __swig_setmethods__ = {}
    for _s in [interaction]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HertzianSimple, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, HertzianSimple, name)
    __repr__ = _swig_repr
    def __init__(self): 
        """__init__(SimpleListed<(HertzianAtom,HertzianPair)> self) -> HertzianSimple"""
        this = _sim3dlong.new_HertzianSimple()
        try: self.this.append(this)
        except: self.this = this
    def add(self, *args) -> "void" :
        """add(HertzianSimple self, HertzianAtom atm)"""
        return _sim3dlong.HertzianSimple_add(self, *args)

    def energy(self, *args) -> "flt" :
        """energy(HertzianSimple self, Box box) -> flt"""
        return _sim3dlong.HertzianSimple_energy(self, *args)

    def pressure(self, *args) -> "flt" :
        """pressure(HertzianSimple self, Box box) -> flt"""
        return _sim3dlong.HertzianSimple_pressure(self, *args)

    def size(self) -> "uint" :
        """size(HertzianSimple self) -> uint"""
        return _sim3dlong.HertzianSimple_size(self)

    def setForces(self, *args) -> "void" :
        """setForces(HertzianSimple self, Box box)"""
        return _sim3dlong.HertzianSimple_setForces(self, *args)

    def setForcesGetPressure(self, *args) -> "flt" :
        """setForcesGetPressure(HertzianSimple self, Box box) -> flt"""
        return _sim3dlong.HertzianSimple_setForcesGetPressure(self, *args)

    def atom_list(self) -> "std::vector< HertzianAtom > &" :
        """atom_list(HertzianSimple self) -> std::vector< HertzianAtom > &"""
        return _sim3dlong.HertzianSimple_atom_list(self)

    __swig_destroy__ = _sim3dlong.delete_HertzianSimple
    __del__ = lambda self : None;
HertzianSimple_swigregister = _sim3dlong.HertzianSimple_swigregister
HertzianSimple_swigregister(HertzianSimple)

class HertzianPlain(interaction):
    """Proxy of C++ NListed<(HertzianAtom,HertzianPair)> class"""
    __swig_setmethods__ = {}
    for _s in [interaction]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HertzianPlain, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, HertzianPlain, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(NListed<(HertzianAtom,HertzianPair)> self, neighborlist neighbors) -> HertzianPlain"""
        this = _sim3dlong.new_HertzianPlain(*args)
        try: self.this.append(this)
        except: self.this = this
    def add(self, *args) -> "void" :
        """add(HertzianPlain self, HertzianAtom atm)"""
        return _sim3dlong.HertzianPlain_add(self, *args)

    def update_pairs(self) -> "void" :
        """update_pairs(HertzianPlain self)"""
        return _sim3dlong.HertzianPlain_update_pairs(self)

    def getpair(self, *args) -> "HertzianPair" :
        """getpair(HertzianPlain self, idpair pair) -> HertzianPair"""
        return _sim3dlong.HertzianPlain_getpair(self, *args)

    def energy(self, *args) -> "flt" :
        """
        energy(HertzianPlain self, Box box, idpair pair) -> flt
        energy(HertzianPlain self, Box box) -> flt
        """
        return _sim3dlong.HertzianPlain_energy(self, *args)

    def pressure(self, *args) -> "flt" :
        """pressure(HertzianPlain self, Box box) -> flt"""
        return _sim3dlong.HertzianPlain_pressure(self, *args)

    def size(self) -> "uint" :
        """size(HertzianPlain self) -> uint"""
        return _sim3dlong.HertzianPlain_size(self)

    def energy_pair(self, *args) -> "flt" :
        """energy_pair(HertzianPlain self, HertzianPair pair, Box box) -> flt"""
        return _sim3dlong.HertzianPlain_energy_pair(self, *args)

    def setForces(self, *args) -> "void" :
        """setForces(HertzianPlain self, Box box)"""
        return _sim3dlong.HertzianPlain_setForces(self, *args)

    def setForcesGetPressure(self, *args) -> "flt" :
        """setForcesGetPressure(HertzianPlain self, Box box) -> flt"""
        return _sim3dlong.HertzianPlain_setForcesGetPressure(self, *args)

    def forces_pair(self, *args) -> "Vec" :
        """forces_pair(HertzianPlain self, HertzianPair pair, Box box) -> VecL"""
        return _sim3dlong.HertzianPlain_forces_pair(self, *args)

    def atom_list(self) -> "std::vector< HertzianAtom > &" :
        """atom_list(HertzianPlain self) -> std::vector< HertzianAtom > &"""
        return _sim3dlong.HertzianPlain_atom_list(self)

    def nlist(self) -> "neighborlist *" :
        """nlist(HertzianPlain self) -> neighborlist"""
        return _sim3dlong.HertzianPlain_nlist(self)

    __swig_destroy__ = _sim3dlong.delete_HertzianPlain
    __del__ = lambda self : None;
HertzianPlain_swigregister = _sim3dlong.HertzianPlain_swigregister
HertzianPlain_swigregister(HertzianPlain)

class Hertzian(interactionpairsx,HertzianPlain):
    """Proxy of C++ NListedVirial<(HertzianAtom,HertzianPair)> class"""
    __swig_setmethods__ = {}
    for _s in [interactionpairsx,HertzianPlain]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Hertzian, name, value)
    __swig_getmethods__ = {}
    for _s in [interactionpairsx,HertzianPlain]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Hertzian, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(NListedVirial<(HertzianAtom,HertzianPair)> self, neighborlist neighbors) -> Hertzian"""
        this = _sim3dlong.new_Hertzian(*args)
        try: self.this.append(this)
        except: self.this = this
    def setForces(self, *args) -> "void" :
        """
        setForces(Hertzian self, Box box)
        setForces(Hertzian self, Box box, fpairxFunct arg3)
        """
        return _sim3dlong.Hertzian_setForces(self, *args)

    def setForcesGetPressure(self, *args) -> "flt" :
        """setForcesGetPressure(Hertzian self, Box box) -> flt"""
        return _sim3dlong.Hertzian_setForcesGetPressure(self, *args)

    def setForcesGetEnergy(self, *args) -> "flt" :
        """setForcesGetEnergy(Hertzian self, Box box) -> flt"""
        return _sim3dlong.Hertzian_setForcesGetEnergy(self, *args)

    def energy(self, *args) -> "flt" :
        """energy(Hertzian self, Box box) -> flt"""
        return _sim3dlong.Hertzian_energy(self, *args)

    def pressure(self, *args) -> "flt" :
        """pressure(Hertzian self, Box box) -> flt"""
        return _sim3dlong.Hertzian_pressure(self, *args)

    __swig_destroy__ = _sim3dlong.delete_Hertzian
    __del__ = lambda self : None;
Hertzian_swigregister = _sim3dlong.Hertzian_swigregister
Hertzian_swigregister(Hertzian)

class LoisOhern(interaction):
    """Proxy of C++ NListed<(LoisOhernAtom,LoisOhernPair)> class"""
    __swig_setmethods__ = {}
    for _s in [interaction]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LoisOhern, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LoisOhern, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(NListed<(LoisOhernAtom,LoisOhernPair)> self, neighborlist neighbors) -> LoisOhern"""
        this = _sim3dlong.new_LoisOhern(*args)
        try: self.this.append(this)
        except: self.this = this
    def add(self, *args) -> "void" :
        """add(LoisOhern self, LoisOhernAtom atm)"""
        return _sim3dlong.LoisOhern_add(self, *args)

    def update_pairs(self) -> "void" :
        """update_pairs(LoisOhern self)"""
        return _sim3dlong.LoisOhern_update_pairs(self)

    def getpair(self, *args) -> "LoisOhernPair" :
        """getpair(LoisOhern self, idpair pair) -> LoisOhernPair"""
        return _sim3dlong.LoisOhern_getpair(self, *args)

    def energy(self, *args) -> "flt" :
        """
        energy(LoisOhern self, Box box, idpair pair) -> flt
        energy(LoisOhern self, Box box) -> flt
        """
        return _sim3dlong.LoisOhern_energy(self, *args)

    def pressure(self, *args) -> "flt" :
        """pressure(LoisOhern self, Box box) -> flt"""
        return _sim3dlong.LoisOhern_pressure(self, *args)

    def size(self) -> "uint" :
        """size(LoisOhern self) -> uint"""
        return _sim3dlong.LoisOhern_size(self)

    def energy_pair(self, *args) -> "flt" :
        """energy_pair(LoisOhern self, LoisOhernPair pair, Box box) -> flt"""
        return _sim3dlong.LoisOhern_energy_pair(self, *args)

    def setForces(self, *args) -> "void" :
        """setForces(LoisOhern self, Box box)"""
        return _sim3dlong.LoisOhern_setForces(self, *args)

    def setForcesGetPressure(self, *args) -> "flt" :
        """setForcesGetPressure(LoisOhern self, Box box) -> flt"""
        return _sim3dlong.LoisOhern_setForcesGetPressure(self, *args)

    def forces_pair(self, *args) -> "Vec" :
        """forces_pair(LoisOhern self, LoisOhernPair pair, Box box) -> VecL"""
        return _sim3dlong.LoisOhern_forces_pair(self, *args)

    def atom_list(self) -> "std::vector< LoisOhernAtom > &" :
        """atom_list(LoisOhern self) -> std::vector< LoisOhernAtom > &"""
        return _sim3dlong.LoisOhern_atom_list(self)

    def nlist(self) -> "neighborlist *" :
        """nlist(LoisOhern self) -> neighborlist"""
        return _sim3dlong.LoisOhern_nlist(self)

    __swig_destroy__ = _sim3dlong.delete_LoisOhern
    __del__ = lambda self : None;
LoisOhern_swigregister = _sim3dlong.LoisOhern_swigregister
LoisOhern_swigregister(LoisOhern)

class collection(_object):
    """Proxy of C++ collection class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, collection, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, collection, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def setForces(self, seta : 'bool'=True) -> "void" :
        """
        setForces(collection self, bool seta=True)
        setForces(collection self)
        """
        return _sim3dlong.collection_setForces(self, seta)

    def timestep(self) -> "void" :
        """timestep(collection self)"""
        return _sim3dlong.collection_timestep(self)

    def dof(self) -> "flt" :
        """dof(collection self) -> flt"""
        return _sim3dlong.collection_dof(self)

    def potentialenergy(self) -> "flt" :
        """potentialenergy(collection self) -> flt"""
        return _sim3dlong.collection_potentialenergy(self)

    def energy(self) -> "flt" :
        """energy(collection self) -> flt"""
        return _sim3dlong.collection_energy(self)

    def temp(self, minuscomv : 'bool'=True) -> "flt" :
        """
        temp(collection self, bool minuscomv=True) -> flt
        temp(collection self) -> flt
        """
        return _sim3dlong.collection_temp(self, minuscomv)

    def kinetic(self) -> "flt" :
        """kinetic(collection self) -> flt"""
        return _sim3dlong.collection_kinetic(self)

    def virial(self) -> "flt" :
        """virial(collection self) -> flt"""
        return _sim3dlong.collection_virial(self)

    def pressure(self) -> "flt" :
        """pressure(collection self) -> flt"""
        return _sim3dlong.collection_pressure(self)

    def getbox(self) -> "Box *" :
        """getbox(collection self) -> Box"""
        return _sim3dlong.collection_getbox(self)

    def com(self) -> "Vec" :
        """com(collection self) -> VecL"""
        return _sim3dlong.collection_com(self)

    def comv(self) -> "Vec" :
        """comv(collection self) -> VecL"""
        return _sim3dlong.collection_comv(self)

    def angmomentum(self, *args) -> "Vec" :
        """
        angmomentum(collection self, VecL loc) -> VecL
        angmomentum(collection self) -> VecL
        """
        return _sim3dlong.collection_angmomentum(self, *args)

    def gyradius(self) -> "flt" :
        """gyradius(collection self) -> flt"""
        return _sim3dlong.collection_gyradius(self)

    __swig_destroy__ = _sim3dlong.delete_collection
    __del__ = lambda self : None;
    def resetcomv(self) -> "void" :
        """resetcomv(collection self)"""
        return _sim3dlong.collection_resetcomv(self)

    def resetL(self) -> "void" :
        """resetL(collection self)"""
        return _sim3dlong.collection_resetL(self)

    def scaleVs(self, *args) -> "void" :
        """scaleVs(collection self, flt scaleby)"""
        return _sim3dlong.collection_scaleVs(self, *args)

    def scaleVelocitiesT(self, *args) -> "void" :
        """scaleVelocitiesT(collection self, flt T)"""
        return _sim3dlong.collection_scaleVelocitiesT(self, *args)

    def scaleVelocitiesE(self, *args) -> "void" :
        """scaleVelocitiesE(collection self, flt E)"""
        return _sim3dlong.collection_scaleVelocitiesE(self, *args)

    def addInteraction(self, *args) -> "void" :
        """addInteraction(collection self, interaction inter)"""
        return _sim3dlong.collection_addInteraction(self, *args)

    def addTracker(self, *args) -> "void" :
        """addTracker(collection self, statetracker track)"""
        return _sim3dlong.collection_addTracker(self, *args)

    def getInteractions(self) -> "std::vector< interaction * >" :
        """getInteractions(collection self) -> ivector"""
        return _sim3dlong.collection_getInteractions(self)

    def numInteraction(self) -> "uint" :
        """numInteraction(collection self) -> uint"""
        return _sim3dlong.collection_numInteraction(self)

    def setE0(self, *args) -> "void" :
        """setE0(collection self, flt newE0)"""
        return _sim3dlong.collection_setE0(self, *args)

collection_swigregister = _sim3dlong.collection_swigregister
collection_swigregister(collection)

class StaticCollec(collection):
    """Proxy of C++ StaticCollec class"""
    __swig_setmethods__ = {}
    for _s in [collection]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, StaticCollec, name, value)
    __swig_getmethods__ = {}
    for _s in [collection]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, StaticCollec, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(StaticCollec self, Box box, avector groups, ivector interactions=std::vector< interaction * >(), tvector trackers=std::vector< statetracker * >(), 
            constraintvector constraints=std::vector< constraint * >()) -> StaticCollec
        __init__(StaticCollec self, Box box, avector groups, ivector interactions=std::vector< interaction * >(), tvector trackers=std::vector< statetracker * >()) -> StaticCollec
        __init__(StaticCollec self, Box box, avector groups, ivector interactions=std::vector< interaction * >()) -> StaticCollec
        __init__(StaticCollec self, Box box, avector groups) -> StaticCollec
        """
        this = _sim3dlong.new_StaticCollec(*args)
        try: self.this.append(this)
        except: self.this = this
    def timestep(self) -> "void" :
        """timestep(StaticCollec self)"""
        return _sim3dlong.StaticCollec_timestep(self)

    def update(self) -> "void" :
        """update(StaticCollec self)"""
        return _sim3dlong.StaticCollec_update(self)

    __swig_destroy__ = _sim3dlong.delete_StaticCollec
    __del__ = lambda self : None;
StaticCollec_swigregister = _sim3dlong.StaticCollec_swigregister
StaticCollec_swigregister(StaticCollec)

class collectionSol(collection):
    """Proxy of C++ collectionSol class"""
    __swig_setmethods__ = {}
    for _s in [collection]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, collectionSol, name, value)
    __swig_getmethods__ = {}
    for _s in [collection]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, collectionSol, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(collectionSol self, Box box, flt const dt, flt const damping, flt const desiredT, avector groups=std::vector< atomgroup * >(), 
            ivector interactions=std::vector< interaction * >(), 
            tvector trackers=std::vector< statetracker * >(), constraintvector constraints=std::vector< constraint * >()) -> collectionSol
        __init__(collectionSol self, Box box, flt const dt, flt const damping, flt const desiredT, avector groups=std::vector< atomgroup * >(), 
            ivector interactions=std::vector< interaction * >(), 
            tvector trackers=std::vector< statetracker * >()) -> collectionSol
        __init__(collectionSol self, Box box, flt const dt, flt const damping, flt const desiredT, avector groups=std::vector< atomgroup * >(), 
            ivector interactions=std::vector< interaction * >()) -> collectionSol
        __init__(collectionSol self, Box box, flt const dt, flt const damping, flt const desiredT, avector groups=std::vector< atomgroup * >()) -> collectionSol
        __init__(collectionSol self, Box box, flt const dt, flt const damping, flt const desiredT) -> collectionSol
        """
        this = _sim3dlong.new_collectionSol(*args)
        try: self.this.append(this)
        except: self.this = this
    def changeT(self, *args) -> "void" :
        """changeT(collectionSol self, flt const newdt, flt const damp, flt const desiredT)"""
        return _sim3dlong.collectionSol_changeT(self, *args)

    def timestep(self) -> "void" :
        """timestep(collectionSol self)"""
        return _sim3dlong.collectionSol_timestep(self)

    __swig_destroy__ = _sim3dlong.delete_collectionSol
    __del__ = lambda self : None;
collectionSol_swigregister = _sim3dlong.collectionSol_swigregister
collectionSol_swigregister(collectionSol)

class collectionSolHT(collection):
    """Proxy of C++ collectionSolHT class"""
    __swig_setmethods__ = {}
    for _s in [collection]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, collectionSolHT, name, value)
    __swig_getmethods__ = {}
    for _s in [collection]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, collectionSolHT, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(collectionSolHT self, Box box, flt const dt, flt const damping, flt const desiredT, avector groups=std::vector< atomgroup * >(), 
            ivector interactions=std::vector< interaction * >(), 
            tvector trackers=std::vector< statetracker * >(), constraintvector constraints=std::vector< constraint * >()) -> collectionSolHT
        __init__(collectionSolHT self, Box box, flt const dt, flt const damping, flt const desiredT, avector groups=std::vector< atomgroup * >(), 
            ivector interactions=std::vector< interaction * >(), 
            tvector trackers=std::vector< statetracker * >()) -> collectionSolHT
        __init__(collectionSolHT self, Box box, flt const dt, flt const damping, flt const desiredT, avector groups=std::vector< atomgroup * >(), 
            ivector interactions=std::vector< interaction * >()) -> collectionSolHT
        __init__(collectionSolHT self, Box box, flt const dt, flt const damping, flt const desiredT, avector groups=std::vector< atomgroup * >()) -> collectionSolHT
        __init__(collectionSolHT self, Box box, flt const dt, flt const damping, flt const desiredT) -> collectionSolHT
        """
        this = _sim3dlong.new_collectionSolHT(*args)
        try: self.this.append(this)
        except: self.this = this
    def changeT(self, *args) -> "void" :
        """changeT(collectionSolHT self, flt const newdt, flt const damp, flt const desiredT)"""
        return _sim3dlong.collectionSolHT_changeT(self, *args)

    def timestep(self) -> "void" :
        """timestep(collectionSolHT self)"""
        return _sim3dlong.collectionSolHT_timestep(self)

    __swig_destroy__ = _sim3dlong.delete_collectionSolHT
    __del__ = lambda self : None;
collectionSolHT_swigregister = _sim3dlong.collectionSolHT_swigregister
collectionSolHT_swigregister(collectionSolHT)

class collectionVerlet(collection):
    """Proxy of C++ collectionVerlet class"""
    __swig_setmethods__ = {}
    for _s in [collection]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, collectionVerlet, name, value)
    __swig_getmethods__ = {}
    for _s in [collection]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, collectionVerlet, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(collectionVerlet self, Box box, flt const dt, avector groups=std::vector< atomgroup * >(), ivector interactions=std::vector< interaction * >(), 
            tvector trackers=std::vector< statetracker * >(), 
            constraintvector constraints=std::vector< constraint * >()) -> collectionVerlet
        __init__(collectionVerlet self, Box box, flt const dt, avector groups=std::vector< atomgroup * >(), ivector interactions=std::vector< interaction * >(), 
            tvector trackers=std::vector< statetracker * >()) -> collectionVerlet
        __init__(collectionVerlet self, Box box, flt const dt, avector groups=std::vector< atomgroup * >(), ivector interactions=std::vector< interaction * >()) -> collectionVerlet
        __init__(collectionVerlet self, Box box, flt const dt, avector groups=std::vector< atomgroup * >()) -> collectionVerlet
        __init__(collectionVerlet self, Box box, flt const dt) -> collectionVerlet
        """
        this = _sim3dlong.new_collectionVerlet(*args)
        try: self.this.append(this)
        except: self.this = this
    def timestep(self) -> "void" :
        """timestep(collectionVerlet self)"""
        return _sim3dlong.collectionVerlet_timestep(self)

    def setdt(self, *args) -> "void" :
        """setdt(collectionVerlet self, flt newdt)"""
        return _sim3dlong.collectionVerlet_setdt(self, *args)

    __swig_destroy__ = _sim3dlong.delete_collectionVerlet
    __del__ = lambda self : None;
collectionVerlet_swigregister = _sim3dlong.collectionVerlet_swigregister
collectionVerlet_swigregister(collectionVerlet)

class collectionOverdamped(collection):
    """Proxy of C++ collectionOverdamped class"""
    __swig_setmethods__ = {}
    for _s in [collection]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, collectionOverdamped, name, value)
    __swig_getmethods__ = {}
    for _s in [collection]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, collectionOverdamped, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(collectionOverdamped self, Box box, flt const dt, float const gamma, avector groups=std::vector< atomgroup * >(), 
            ivector interactions=std::vector< interaction * >(), tvector trackers=std::vector< statetracker * >(), 
            constraintvector constraints=std::vector< constraint * >()) -> collectionOverdamped
        __init__(collectionOverdamped self, Box box, flt const dt, float const gamma, avector groups=std::vector< atomgroup * >(), 
            ivector interactions=std::vector< interaction * >(), tvector trackers=std::vector< statetracker * >()) -> collectionOverdamped
        __init__(collectionOverdamped self, Box box, flt const dt, float const gamma, avector groups=std::vector< atomgroup * >(), 
            ivector interactions=std::vector< interaction * >()) -> collectionOverdamped
        __init__(collectionOverdamped self, Box box, flt const dt, float const gamma, avector groups=std::vector< atomgroup * >()) -> collectionOverdamped
        __init__(collectionOverdamped self, Box box, flt const dt, float const gamma) -> collectionOverdamped
        """
        this = _sim3dlong.new_collectionOverdamped(*args)
        try: self.this.append(this)
        except: self.this = this
    def timestep(self) -> "void" :
        """timestep(collectionOverdamped self)"""
        return _sim3dlong.collectionOverdamped_timestep(self)

    def setdt(self, *args) -> "void" :
        """setdt(collectionOverdamped self, flt newdt)"""
        return _sim3dlong.collectionOverdamped_setdt(self, *args)

    __swig_destroy__ = _sim3dlong.delete_collectionOverdamped
    __del__ = lambda self : None;
collectionOverdamped_swigregister = _sim3dlong.collectionOverdamped_swigregister
collectionOverdamped_swigregister(collectionOverdamped)

class collectionConjGradient(collection):
    """Proxy of C++ collectionConjGradient class"""
    __swig_setmethods__ = {}
    for _s in [collection]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, collectionConjGradient, name, value)
    __swig_getmethods__ = {}
    for _s in [collection]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, collectionConjGradient, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(collectionConjGradient self, Box box, flt const dt, avector groups=std::vector< atomgroup * >(), ivector interactions=std::vector< interaction * >(), 
            tvector trackers=std::vector< statetracker * >(), 
            constraintvector constraints=std::vector< constraint * >()) -> collectionConjGradient
        __init__(collectionConjGradient self, Box box, flt const dt, avector groups=std::vector< atomgroup * >(), ivector interactions=std::vector< interaction * >(), 
            tvector trackers=std::vector< statetracker * >()) -> collectionConjGradient
        __init__(collectionConjGradient self, Box box, flt const dt, avector groups=std::vector< atomgroup * >(), ivector interactions=std::vector< interaction * >()) -> collectionConjGradient
        __init__(collectionConjGradient self, Box box, flt const dt, avector groups=std::vector< atomgroup * >()) -> collectionConjGradient
        __init__(collectionConjGradient self, Box box, flt const dt) -> collectionConjGradient
        """
        this = _sim3dlong.new_collectionConjGradient(*args)
        try: self.this.append(this)
        except: self.this = this
    def timestep(self) -> "void" :
        """timestep(collectionConjGradient self)"""
        return _sim3dlong.collectionConjGradient_timestep(self)

    def timestepNewton(self) -> "void" :
        """timestepNewton(collectionConjGradient self)"""
        return _sim3dlong.collectionConjGradient_timestepNewton(self)

    def reset(self) -> "void" :
        """reset(collectionConjGradient self)"""
        return _sim3dlong.collectionConjGradient_reset(self)

    def setdt(self, *args) -> "void" :
        """setdt(collectionConjGradient self, flt newdt)"""
        return _sim3dlong.collectionConjGradient_setdt(self, *args)

    __swig_destroy__ = _sim3dlong.delete_collectionConjGradient
    __del__ = lambda self : None;
collectionConjGradient_swigregister = _sim3dlong.collectionConjGradient_swigregister
collectionConjGradient_swigregister(collectionConjGradient)

class collectionConjGradientBox(collection):
    """Proxy of C++ collectionConjGradientBox class"""
    __swig_setmethods__ = {}
    for _s in [collection]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, collectionConjGradientBox, name, value)
    __swig_getmethods__ = {}
    for _s in [collection]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, collectionConjGradientBox, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(collectionConjGradientBox self, OriginBox box, flt const dt, flt const P0, flt const kappaV=1, avector groups=std::vector< atomgroup * >(), 
            ivector interactions=std::vector< interaction * >(), 
            tvector trackers=std::vector< statetracker * >(), constraintvector constraints=std::vector< constraint * >()) -> collectionConjGradientBox
        __init__(collectionConjGradientBox self, OriginBox box, flt const dt, flt const P0, flt const kappaV=1, avector groups=std::vector< atomgroup * >(), 
            ivector interactions=std::vector< interaction * >(), 
            tvector trackers=std::vector< statetracker * >()) -> collectionConjGradientBox
        __init__(collectionConjGradientBox self, OriginBox box, flt const dt, flt const P0, flt const kappaV=1, avector groups=std::vector< atomgroup * >(), 
            ivector interactions=std::vector< interaction * >()) -> collectionConjGradientBox
        __init__(collectionConjGradientBox self, OriginBox box, flt const dt, flt const P0, flt const kappaV=1, avector groups=std::vector< atomgroup * >()) -> collectionConjGradientBox
        __init__(collectionConjGradientBox self, OriginBox box, flt const dt, flt const P0, flt const kappaV=1) -> collectionConjGradientBox
        __init__(collectionConjGradientBox self, OriginBox box, flt const dt, flt const P0) -> collectionConjGradientBox
        """
        this = _sim3dlong.new_collectionConjGradientBox(*args)
        try: self.this.append(this)
        except: self.this = this
    def kinetic(self) -> "flt" :
        """kinetic(collectionConjGradientBox self) -> flt"""
        return _sim3dlong.collectionConjGradientBox_kinetic(self)

    def timestep(self) -> "void" :
        """timestep(collectionConjGradientBox self)"""
        return _sim3dlong.collectionConjGradientBox_timestep(self)

    def timestepBox(self) -> "void" :
        """timestepBox(collectionConjGradientBox self)"""
        return _sim3dlong.collectionConjGradientBox_timestepBox(self)

    def timestepAtoms(self) -> "void" :
        """timestepAtoms(collectionConjGradientBox self)"""
        return _sim3dlong.collectionConjGradientBox_timestepAtoms(self)

    def reset(self) -> "void" :
        """reset(collectionConjGradientBox self)"""
        return _sim3dlong.collectionConjGradientBox_reset(self)

    def resize(self, *args) -> "void" :
        """resize(collectionConjGradientBox self, flt V)"""
        return _sim3dlong.collectionConjGradientBox_resize(self, *args)

    def setdt(self, *args) -> "void" :
        """setdt(collectionConjGradientBox self, flt newdt)"""
        return _sim3dlong.collectionConjGradientBox_setdt(self, *args)

    def setP(self, *args) -> "void" :
        """setP(collectionConjGradientBox self, flt P)"""
        return _sim3dlong.collectionConjGradientBox_setP(self, *args)

    def setMaxdV(self, *args) -> "void" :
        """setMaxdV(collectionConjGradientBox self, flt diff)"""
        return _sim3dlong.collectionConjGradientBox_setMaxdV(self, *args)

    __swig_destroy__ = _sim3dlong.delete_collectionConjGradientBox
    __del__ = lambda self : None;
collectionConjGradientBox_swigregister = _sim3dlong.collectionConjGradientBox_swigregister
collectionConjGradientBox_swigregister(collectionConjGradientBox)

class collectionNLCG(collection):
    """Proxy of C++ collectionNLCG class"""
    __swig_setmethods__ = {}
    for _s in [collection]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, collectionNLCG, name, value)
    __swig_getmethods__ = {}
    for _s in [collection]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, collectionNLCG, name)
    __repr__ = _swig_repr
    __swig_setmethods__["dt"] = _sim3dlong.collectionNLCG_dt_set
    __swig_getmethods__["dt"] = _sim3dlong.collectionNLCG_dt_get
    if _newclass:dt = _swig_property(_sim3dlong.collectionNLCG_dt_get, _sim3dlong.collectionNLCG_dt_set)
    __swig_setmethods__["secmax"] = _sim3dlong.collectionNLCG_secmax_set
    __swig_getmethods__["secmax"] = _sim3dlong.collectionNLCG_secmax_get
    if _newclass:secmax = _swig_property(_sim3dlong.collectionNLCG_secmax_get, _sim3dlong.collectionNLCG_secmax_set)
    __swig_setmethods__["seceps"] = _sim3dlong.collectionNLCG_seceps_set
    __swig_getmethods__["seceps"] = _sim3dlong.collectionNLCG_seceps_get
    if _newclass:seceps = _swig_property(_sim3dlong.collectionNLCG_seceps_get, _sim3dlong.collectionNLCG_seceps_set)
    __swig_setmethods__["alphamax"] = _sim3dlong.collectionNLCG_alphamax_set
    __swig_getmethods__["alphamax"] = _sim3dlong.collectionNLCG_alphamax_get
    if _newclass:alphamax = _swig_property(_sim3dlong.collectionNLCG_alphamax_get, _sim3dlong.collectionNLCG_alphamax_set)
    __swig_setmethods__["dxmax"] = _sim3dlong.collectionNLCG_dxmax_set
    __swig_getmethods__["dxmax"] = _sim3dlong.collectionNLCG_dxmax_get
    if _newclass:dxmax = _swig_property(_sim3dlong.collectionNLCG_dxmax_get, _sim3dlong.collectionNLCG_dxmax_set)
    __swig_setmethods__["kappa"] = _sim3dlong.collectionNLCG_kappa_set
    __swig_getmethods__["kappa"] = _sim3dlong.collectionNLCG_kappa_get
    if _newclass:kappa = _swig_property(_sim3dlong.collectionNLCG_kappa_get, _sim3dlong.collectionNLCG_kappa_set)
    __swig_setmethods__["kmax"] = _sim3dlong.collectionNLCG_kmax_set
    __swig_getmethods__["kmax"] = _sim3dlong.collectionNLCG_kmax_get
    if _newclass:kmax = _swig_property(_sim3dlong.collectionNLCG_kmax_get, _sim3dlong.collectionNLCG_kmax_set)
    __swig_setmethods__["P0"] = _sim3dlong.collectionNLCG_P0_set
    __swig_getmethods__["P0"] = _sim3dlong.collectionNLCG_P0_get
    if _newclass:P0 = _swig_property(_sim3dlong.collectionNLCG_P0_get, _sim3dlong.collectionNLCG_P0_set)
    __swig_setmethods__["Knew"] = _sim3dlong.collectionNLCG_Knew_set
    __swig_getmethods__["Knew"] = _sim3dlong.collectionNLCG_Knew_get
    if _newclass:Knew = _swig_property(_sim3dlong.collectionNLCG_Knew_get, _sim3dlong.collectionNLCG_Knew_set)
    __swig_setmethods__["k"] = _sim3dlong.collectionNLCG_k_set
    __swig_getmethods__["k"] = _sim3dlong.collectionNLCG_k_get
    if _newclass:k = _swig_property(_sim3dlong.collectionNLCG_k_get, _sim3dlong.collectionNLCG_k_set)
    __swig_setmethods__["vl"] = _sim3dlong.collectionNLCG_vl_set
    __swig_getmethods__["vl"] = _sim3dlong.collectionNLCG_vl_get
    if _newclass:vl = _swig_property(_sim3dlong.collectionNLCG_vl_get, _sim3dlong.collectionNLCG_vl_set)
    __swig_setmethods__["fl"] = _sim3dlong.collectionNLCG_fl_set
    __swig_getmethods__["fl"] = _sim3dlong.collectionNLCG_fl_get
    if _newclass:fl = _swig_property(_sim3dlong.collectionNLCG_fl_get, _sim3dlong.collectionNLCG_fl_set)
    __swig_setmethods__["al"] = _sim3dlong.collectionNLCG_al_set
    __swig_getmethods__["al"] = _sim3dlong.collectionNLCG_al_get
    if _newclass:al = _swig_property(_sim3dlong.collectionNLCG_al_get, _sim3dlong.collectionNLCG_al_set)
    __swig_setmethods__["alpha"] = _sim3dlong.collectionNLCG_alpha_set
    __swig_getmethods__["alpha"] = _sim3dlong.collectionNLCG_alpha_get
    if _newclass:alpha = _swig_property(_sim3dlong.collectionNLCG_alpha_get, _sim3dlong.collectionNLCG_alpha_set)
    __swig_setmethods__["dxsum"] = _sim3dlong.collectionNLCG_dxsum_set
    __swig_getmethods__["dxsum"] = _sim3dlong.collectionNLCG_dxsum_get
    if _newclass:dxsum = _swig_property(_sim3dlong.collectionNLCG_dxsum_get, _sim3dlong.collectionNLCG_dxsum_set)
    __swig_setmethods__["alphavmax"] = _sim3dlong.collectionNLCG_alphavmax_set
    __swig_getmethods__["alphavmax"] = _sim3dlong.collectionNLCG_alphavmax_get
    if _newclass:alphavmax = _swig_property(_sim3dlong.collectionNLCG_alphavmax_get, _sim3dlong.collectionNLCG_alphavmax_set)
    __swig_setmethods__["maxdV"] = _sim3dlong.collectionNLCG_maxdV_set
    __swig_getmethods__["maxdV"] = _sim3dlong.collectionNLCG_maxdV_get
    if _newclass:maxdV = _swig_property(_sim3dlong.collectionNLCG_maxdV_get, _sim3dlong.collectionNLCG_maxdV_set)
    __swig_setmethods__["sec"] = _sim3dlong.collectionNLCG_sec_set
    __swig_getmethods__["sec"] = _sim3dlong.collectionNLCG_sec_get
    if _newclass:sec = _swig_property(_sim3dlong.collectionNLCG_sec_get, _sim3dlong.collectionNLCG_sec_set)
    def stepx(self, *args) -> "void" :
        """stepx(collectionNLCG self, flt dx)"""
        return _sim3dlong.collectionNLCG_stepx(self, *args)

    def getLsq(self) -> "flt" :
        """getLsq(collectionNLCG self) -> flt"""
        return _sim3dlong.collectionNLCG_getLsq(self)

    def fdota(self) -> "flt" :
        """fdota(collectionNLCG self) -> flt"""
        return _sim3dlong.collectionNLCG_fdota(self)

    def fdotf(self) -> "flt" :
        """fdotf(collectionNLCG self) -> flt"""
        return _sim3dlong.collectionNLCG_fdotf(self)

    def fdotv(self) -> "flt" :
        """fdotv(collectionNLCG self) -> flt"""
        return _sim3dlong.collectionNLCG_fdotv(self)

    def vdotv(self) -> "flt" :
        """vdotv(collectionNLCG self) -> flt"""
        return _sim3dlong.collectionNLCG_vdotv(self)

    def __init__(self, *args): 
        """
        __init__(collectionNLCG self, OriginBox box, flt const dt, flt const P0, avector groups=std::vector< atomgroup * >(), 
            ivector interactions=std::vector< interaction * >(), tvector trackers=std::vector< statetracker * >(), 
            constraintvector constraints=std::vector< constraint * >(), 
            flt const kappa=0, flt const kmax=1000, flt const secmax=10, 
            flt const seceps=0.0001) -> collectionNLCG
        __init__(collectionNLCG self, OriginBox box, flt const dt, flt const P0, avector groups=std::vector< atomgroup * >(), 
            ivector interactions=std::vector< interaction * >(), tvector trackers=std::vector< statetracker * >(), 
            constraintvector constraints=std::vector< constraint * >(), 
            flt const kappa=0, flt const kmax=1000, flt const secmax=10) -> collectionNLCG
        __init__(collectionNLCG self, OriginBox box, flt const dt, flt const P0, avector groups=std::vector< atomgroup * >(), 
            ivector interactions=std::vector< interaction * >(), tvector trackers=std::vector< statetracker * >(), 
            constraintvector constraints=std::vector< constraint * >(), 
            flt const kappa=0, flt const kmax=1000) -> collectionNLCG
        __init__(collectionNLCG self, OriginBox box, flt const dt, flt const P0, avector groups=std::vector< atomgroup * >(), 
            ivector interactions=std::vector< interaction * >(), tvector trackers=std::vector< statetracker * >(), 
            constraintvector constraints=std::vector< constraint * >(), 
            flt const kappa=0) -> collectionNLCG
        __init__(collectionNLCG self, OriginBox box, flt const dt, flt const P0, avector groups=std::vector< atomgroup * >(), 
            ivector interactions=std::vector< interaction * >(), tvector trackers=std::vector< statetracker * >(), 
            constraintvector constraints=std::vector< constraint * >()) -> collectionNLCG
        __init__(collectionNLCG self, OriginBox box, flt const dt, flt const P0, avector groups=std::vector< atomgroup * >(), 
            ivector interactions=std::vector< interaction * >(), tvector trackers=std::vector< statetracker * >()) -> collectionNLCG
        __init__(collectionNLCG self, OriginBox box, flt const dt, flt const P0, avector groups=std::vector< atomgroup * >(), 
            ivector interactions=std::vector< interaction * >()) -> collectionNLCG
        __init__(collectionNLCG self, OriginBox box, flt const dt, flt const P0, avector groups=std::vector< atomgroup * >()) -> collectionNLCG
        __init__(collectionNLCG self, OriginBox box, flt const dt, flt const P0) -> collectionNLCG
        """
        this = _sim3dlong.new_collectionNLCG(*args)
        try: self.this.append(this)
        except: self.this = this
    def kinetic(self) -> "flt" :
        """kinetic(collectionNLCG self) -> flt"""
        return _sim3dlong.collectionNLCG_kinetic(self)

    def pressure(self) -> "flt" :
        """pressure(collectionNLCG self) -> flt"""
        return _sim3dlong.collectionNLCG_pressure(self)

    def Hamiltonian(self) -> "flt" :
        """Hamiltonian(collectionNLCG self) -> flt"""
        return _sim3dlong.collectionNLCG_Hamiltonian(self)

    def setForces(self, *args) -> "void" :
        """
        setForces(collectionNLCG self, bool seta=True)
        setForces(collectionNLCG self)
        setForces(collectionNLCG self, bool seta, bool setV)
        """
        return _sim3dlong.collectionNLCG_setForces(self, *args)

    def timestep(self) -> "void" :
        """timestep(collectionNLCG self)"""
        return _sim3dlong.collectionNLCG_timestep(self)

    def descend(self) -> "void" :
        """descend(collectionNLCG self)"""
        return _sim3dlong.collectionNLCG_descend(self)

    def reset(self) -> "void" :
        """reset(collectionNLCG self)"""
        return _sim3dlong.collectionNLCG_reset(self)

    def resize(self, *args) -> "void" :
        """resize(collectionNLCG self, flt V)"""
        return _sim3dlong.collectionNLCG_resize(self, *args)

    def setdt(self, *args) -> "void" :
        """setdt(collectionNLCG self, flt newdt)"""
        return _sim3dlong.collectionNLCG_setdt(self, *args)

    def setP(self, *args) -> "void" :
        """setP(collectionNLCG self, flt P)"""
        return _sim3dlong.collectionNLCG_setP(self, *args)

    def setkappa(self, *args) -> "void" :
        """setkappa(collectionNLCG self, flt k)"""
        return _sim3dlong.collectionNLCG_setkappa(self, *args)

    def setamax(self, *args) -> "void" :
        """setamax(collectionNLCG self, flt a)"""
        return _sim3dlong.collectionNLCG_setamax(self, *args)

    def setdxmax(self, *args) -> "void" :
        """setdxmax(collectionNLCG self, flt d)"""
        return _sim3dlong.collectionNLCG_setdxmax(self, *args)

    def setmaxdV(self, *args) -> "void" :
        """setmaxdV(collectionNLCG self, flt d)"""
        return _sim3dlong.collectionNLCG_setmaxdV(self, *args)

    __swig_destroy__ = _sim3dlong.delete_collectionNLCG
    __del__ = lambda self : None;
collectionNLCG_swigregister = _sim3dlong.collectionNLCG_swigregister
collectionNLCG_swigregister(collectionNLCG)

class collectionNLCGV(collection):
    """Proxy of C++ collectionNLCGV class"""
    __swig_setmethods__ = {}
    for _s in [collection]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, collectionNLCGV, name, value)
    __swig_getmethods__ = {}
    for _s in [collection]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, collectionNLCGV, name)
    __repr__ = _swig_repr
    __swig_setmethods__["dt"] = _sim3dlong.collectionNLCGV_dt_set
    __swig_getmethods__["dt"] = _sim3dlong.collectionNLCGV_dt_get
    if _newclass:dt = _swig_property(_sim3dlong.collectionNLCGV_dt_get, _sim3dlong.collectionNLCGV_dt_set)
    __swig_setmethods__["secmax"] = _sim3dlong.collectionNLCGV_secmax_set
    __swig_getmethods__["secmax"] = _sim3dlong.collectionNLCGV_secmax_get
    if _newclass:secmax = _swig_property(_sim3dlong.collectionNLCGV_secmax_get, _sim3dlong.collectionNLCGV_secmax_set)
    __swig_setmethods__["seceps"] = _sim3dlong.collectionNLCGV_seceps_set
    __swig_getmethods__["seceps"] = _sim3dlong.collectionNLCGV_seceps_get
    if _newclass:seceps = _swig_property(_sim3dlong.collectionNLCGV_seceps_get, _sim3dlong.collectionNLCGV_seceps_set)
    __swig_setmethods__["alphamax"] = _sim3dlong.collectionNLCGV_alphamax_set
    __swig_getmethods__["alphamax"] = _sim3dlong.collectionNLCGV_alphamax_get
    if _newclass:alphamax = _swig_property(_sim3dlong.collectionNLCGV_alphamax_get, _sim3dlong.collectionNLCGV_alphamax_set)
    __swig_setmethods__["afrac"] = _sim3dlong.collectionNLCGV_afrac_set
    __swig_getmethods__["afrac"] = _sim3dlong.collectionNLCGV_afrac_get
    if _newclass:afrac = _swig_property(_sim3dlong.collectionNLCGV_afrac_get, _sim3dlong.collectionNLCGV_afrac_set)
    __swig_setmethods__["dxmax"] = _sim3dlong.collectionNLCGV_dxmax_set
    __swig_getmethods__["dxmax"] = _sim3dlong.collectionNLCGV_dxmax_get
    if _newclass:dxmax = _swig_property(_sim3dlong.collectionNLCGV_dxmax_get, _sim3dlong.collectionNLCGV_dxmax_set)
    __swig_setmethods__["stepmax"] = _sim3dlong.collectionNLCGV_stepmax_set
    __swig_getmethods__["stepmax"] = _sim3dlong.collectionNLCGV_stepmax_get
    if _newclass:stepmax = _swig_property(_sim3dlong.collectionNLCGV_stepmax_get, _sim3dlong.collectionNLCGV_stepmax_set)
    __swig_setmethods__["kmax"] = _sim3dlong.collectionNLCGV_kmax_set
    __swig_getmethods__["kmax"] = _sim3dlong.collectionNLCGV_kmax_get
    if _newclass:kmax = _swig_property(_sim3dlong.collectionNLCGV_kmax_get, _sim3dlong.collectionNLCGV_kmax_set)
    __swig_setmethods__["Knew"] = _sim3dlong.collectionNLCGV_Knew_set
    __swig_getmethods__["Knew"] = _sim3dlong.collectionNLCGV_Knew_get
    if _newclass:Knew = _swig_property(_sim3dlong.collectionNLCGV_Knew_get, _sim3dlong.collectionNLCGV_Knew_set)
    __swig_setmethods__["k"] = _sim3dlong.collectionNLCGV_k_set
    __swig_getmethods__["k"] = _sim3dlong.collectionNLCGV_k_get
    if _newclass:k = _swig_property(_sim3dlong.collectionNLCGV_k_get, _sim3dlong.collectionNLCGV_k_set)
    __swig_setmethods__["vl"] = _sim3dlong.collectionNLCGV_vl_set
    __swig_getmethods__["vl"] = _sim3dlong.collectionNLCGV_vl_get
    if _newclass:vl = _swig_property(_sim3dlong.collectionNLCGV_vl_get, _sim3dlong.collectionNLCGV_vl_set)
    __swig_setmethods__["fl"] = _sim3dlong.collectionNLCGV_fl_set
    __swig_getmethods__["fl"] = _sim3dlong.collectionNLCGV_fl_get
    if _newclass:fl = _swig_property(_sim3dlong.collectionNLCGV_fl_get, _sim3dlong.collectionNLCGV_fl_set)
    __swig_setmethods__["al"] = _sim3dlong.collectionNLCGV_al_set
    __swig_getmethods__["al"] = _sim3dlong.collectionNLCGV_al_get
    if _newclass:al = _swig_property(_sim3dlong.collectionNLCGV_al_get, _sim3dlong.collectionNLCGV_al_set)
    __swig_setmethods__["alpha"] = _sim3dlong.collectionNLCGV_alpha_set
    __swig_getmethods__["alpha"] = _sim3dlong.collectionNLCGV_alpha_get
    if _newclass:alpha = _swig_property(_sim3dlong.collectionNLCGV_alpha_get, _sim3dlong.collectionNLCGV_alpha_set)
    __swig_setmethods__["beta"] = _sim3dlong.collectionNLCGV_beta_set
    __swig_getmethods__["beta"] = _sim3dlong.collectionNLCGV_beta_get
    if _newclass:beta = _swig_property(_sim3dlong.collectionNLCGV_beta_get, _sim3dlong.collectionNLCGV_beta_set)
    __swig_setmethods__["betaused"] = _sim3dlong.collectionNLCGV_betaused_set
    __swig_getmethods__["betaused"] = _sim3dlong.collectionNLCGV_betaused_get
    if _newclass:betaused = _swig_property(_sim3dlong.collectionNLCGV_betaused_get, _sim3dlong.collectionNLCGV_betaused_set)
    __swig_setmethods__["dxsum"] = _sim3dlong.collectionNLCGV_dxsum_set
    __swig_getmethods__["dxsum"] = _sim3dlong.collectionNLCGV_dxsum_get
    if _newclass:dxsum = _swig_property(_sim3dlong.collectionNLCGV_dxsum_get, _sim3dlong.collectionNLCGV_dxsum_set)
    __swig_setmethods__["alphavmax"] = _sim3dlong.collectionNLCGV_alphavmax_set
    __swig_getmethods__["alphavmax"] = _sim3dlong.collectionNLCGV_alphavmax_get
    if _newclass:alphavmax = _swig_property(_sim3dlong.collectionNLCGV_alphavmax_get, _sim3dlong.collectionNLCGV_alphavmax_set)
    __swig_setmethods__["sec"] = _sim3dlong.collectionNLCGV_sec_set
    __swig_getmethods__["sec"] = _sim3dlong.collectionNLCGV_sec_get
    if _newclass:sec = _swig_property(_sim3dlong.collectionNLCGV_sec_get, _sim3dlong.collectionNLCGV_sec_set)
    def stepx(self, *args) -> "void" :
        """stepx(collectionNLCGV self, flt dx)"""
        return _sim3dlong.collectionNLCGV_stepx(self, *args)

    def fdota(self) -> "flt" :
        """fdota(collectionNLCGV self) -> flt"""
        return _sim3dlong.collectionNLCGV_fdota(self)

    def fdotf(self) -> "flt" :
        """fdotf(collectionNLCGV self) -> flt"""
        return _sim3dlong.collectionNLCGV_fdotf(self)

    def fdotv(self) -> "flt" :
        """fdotv(collectionNLCGV self) -> flt"""
        return _sim3dlong.collectionNLCGV_fdotv(self)

    def vdotv(self) -> "flt" :
        """vdotv(collectionNLCGV self) -> flt"""
        return _sim3dlong.collectionNLCGV_vdotv(self)

    def __init__(self, *args): 
        """
        __init__(collectionNLCGV self, Box box, flt const dt, avector groups=std::vector< atomgroup * >(), ivector interactions=std::vector< interaction * >(), 
            tvector trackers=std::vector< statetracker * >(), 
            constraintvector constraints=std::vector< constraint * >(), 
            flt const kmax=1000, flt const secmax=10, flt const seceps=1e-4) -> collectionNLCGV
        __init__(collectionNLCGV self, Box box, flt const dt, avector groups=std::vector< atomgroup * >(), ivector interactions=std::vector< interaction * >(), 
            tvector trackers=std::vector< statetracker * >(), 
            constraintvector constraints=std::vector< constraint * >(), 
            flt const kmax=1000, flt const secmax=10) -> collectionNLCGV
        __init__(collectionNLCGV self, Box box, flt const dt, avector groups=std::vector< atomgroup * >(), ivector interactions=std::vector< interaction * >(), 
            tvector trackers=std::vector< statetracker * >(), 
            constraintvector constraints=std::vector< constraint * >(), 
            flt const kmax=1000) -> collectionNLCGV
        __init__(collectionNLCGV self, Box box, flt const dt, avector groups=std::vector< atomgroup * >(), ivector interactions=std::vector< interaction * >(), 
            tvector trackers=std::vector< statetracker * >(), 
            constraintvector constraints=std::vector< constraint * >()) -> collectionNLCGV
        __init__(collectionNLCGV self, Box box, flt const dt, avector groups=std::vector< atomgroup * >(), ivector interactions=std::vector< interaction * >(), 
            tvector trackers=std::vector< statetracker * >()) -> collectionNLCGV
        __init__(collectionNLCGV self, Box box, flt const dt, avector groups=std::vector< atomgroup * >(), ivector interactions=std::vector< interaction * >()) -> collectionNLCGV
        __init__(collectionNLCGV self, Box box, flt const dt, avector groups=std::vector< atomgroup * >()) -> collectionNLCGV
        __init__(collectionNLCGV self, Box box, flt const dt) -> collectionNLCGV
        """
        this = _sim3dlong.new_collectionNLCGV(*args)
        try: self.this.append(this)
        except: self.this = this
    def pressure(self) -> "flt" :
        """pressure(collectionNLCGV self) -> flt"""
        return _sim3dlong.collectionNLCGV_pressure(self)

    def reset(self) -> "void" :
        """reset(collectionNLCGV self)"""
        return _sim3dlong.collectionNLCGV_reset(self)

    def descend(self) -> "void" :
        """descend(collectionNLCGV self)"""
        return _sim3dlong.collectionNLCGV_descend(self)

    def timestep(self) -> "void" :
        """timestep(collectionNLCGV self)"""
        return _sim3dlong.collectionNLCGV_timestep(self)

    def setdt(self, *args) -> "void" :
        """setdt(collectionNLCGV self, flt newdt)"""
        return _sim3dlong.collectionNLCGV_setdt(self, *args)

    def setamax(self, *args) -> "void" :
        """setamax(collectionNLCGV self, flt a)"""
        return _sim3dlong.collectionNLCGV_setamax(self, *args)

    def setafrac(self, *args) -> "void" :
        """setafrac(collectionNLCGV self, flt a)"""
        return _sim3dlong.collectionNLCGV_setafrac(self, *args)

    def setdxmax(self, *args) -> "void" :
        """setdxmax(collectionNLCGV self, flt d)"""
        return _sim3dlong.collectionNLCGV_setdxmax(self, *args)

    def setstepmax(self, *args) -> "void" :
        """setstepmax(collectionNLCGV self, flt m)"""
        return _sim3dlong.collectionNLCGV_setstepmax(self, *args)

    __swig_destroy__ = _sim3dlong.delete_collectionNLCGV
    __del__ = lambda self : None;
collectionNLCGV_swigregister = _sim3dlong.collectionNLCGV_swigregister
collectionNLCGV_swigregister(collectionNLCGV)


def solveCubic1(*args) -> "flt" :
  """solveCubic1(flt b, flt c, flt d) -> flt"""
  return _sim3dlong.solveCubic1(*args)

def solveCubic(*args) -> "flt" :
  """
    solveCubic(flt a1, flt a2, flt a3, flt closeto=0) -> flt
    solveCubic(flt a1, flt a2, flt a3) -> flt
    """
  return _sim3dlong.solveCubic(*args)
class collectionNoseHoover(collection):
    """Proxy of C++ collectionNoseHoover class"""
    __swig_setmethods__ = {}
    for _s in [collection]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, collectionNoseHoover, name, value)
    __swig_getmethods__ = {}
    for _s in [collection]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, collectionNoseHoover, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(collectionNoseHoover self, Box box, flt const dt, flt const Q, flt const T, avector groups=std::vector< atomgroup * >(), 
            ivector interactions=std::vector< interaction * >(), tvector trackers=std::vector< statetracker * >(), 
            constraintvector constraints=std::vector< constraint * >()) -> collectionNoseHoover
        __init__(collectionNoseHoover self, Box box, flt const dt, flt const Q, flt const T, avector groups=std::vector< atomgroup * >(), 
            ivector interactions=std::vector< interaction * >(), tvector trackers=std::vector< statetracker * >()) -> collectionNoseHoover
        __init__(collectionNoseHoover self, Box box, flt const dt, flt const Q, flt const T, avector groups=std::vector< atomgroup * >(), 
            ivector interactions=std::vector< interaction * >()) -> collectionNoseHoover
        __init__(collectionNoseHoover self, Box box, flt const dt, flt const Q, flt const T, avector groups=std::vector< atomgroup * >()) -> collectionNoseHoover
        __init__(collectionNoseHoover self, Box box, flt const dt, flt const Q, flt const T) -> collectionNoseHoover
        """
        this = _sim3dlong.new_collectionNoseHoover(*args)
        try: self.this.append(this)
        except: self.this = this
    def setdt(self, *args) -> "void" :
        """setdt(collectionNoseHoover self, flt newdt)"""
        return _sim3dlong.collectionNoseHoover_setdt(self, *args)

    def setQ(self, *args) -> "void" :
        """setQ(collectionNoseHoover self, flt newQ)"""
        return _sim3dlong.collectionNoseHoover_setQ(self, *args)

    def resetBath(self) -> "void" :
        """resetBath(collectionNoseHoover self)"""
        return _sim3dlong.collectionNoseHoover_resetBath(self)

    def timestep(self) -> "void" :
        """timestep(collectionNoseHoover self)"""
        return _sim3dlong.collectionNoseHoover_timestep(self)

    def Hamiltonian(self) -> "flt" :
        """Hamiltonian(collectionNoseHoover self) -> flt"""
        return _sim3dlong.collectionNoseHoover_Hamiltonian(self)

    def getxi(self) -> "flt" :
        """getxi(collectionNoseHoover self) -> flt"""
        return _sim3dlong.collectionNoseHoover_getxi(self)

    def getlns(self) -> "flt" :
        """getlns(collectionNoseHoover self) -> flt"""
        return _sim3dlong.collectionNoseHoover_getlns(self)

    __swig_destroy__ = _sim3dlong.delete_collectionNoseHoover
    __del__ = lambda self : None;
collectionNoseHoover_swigregister = _sim3dlong.collectionNoseHoover_swigregister
collectionNoseHoover_swigregister(collectionNoseHoover)

class collectionGaussianT(collection):
    """Proxy of C++ collectionGaussianT class"""
    __swig_setmethods__ = {}
    for _s in [collection]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, collectionGaussianT, name, value)
    __swig_getmethods__ = {}
    for _s in [collection]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, collectionGaussianT, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(collectionGaussianT self, Box box, flt const dt, flt const Q, avector groups=std::vector< atomgroup * >(), 
            ivector interactions=std::vector< interaction * >(), tvector trackers=std::vector< statetracker * >(), 
            constraintvector constraints=std::vector< constraint * >()) -> collectionGaussianT
        __init__(collectionGaussianT self, Box box, flt const dt, flt const Q, avector groups=std::vector< atomgroup * >(), 
            ivector interactions=std::vector< interaction * >(), tvector trackers=std::vector< statetracker * >()) -> collectionGaussianT
        __init__(collectionGaussianT self, Box box, flt const dt, flt const Q, avector groups=std::vector< atomgroup * >(), 
            ivector interactions=std::vector< interaction * >()) -> collectionGaussianT
        __init__(collectionGaussianT self, Box box, flt const dt, flt const Q, avector groups=std::vector< atomgroup * >()) -> collectionGaussianT
        __init__(collectionGaussianT self, Box box, flt const dt, flt const Q) -> collectionGaussianT
        """
        this = _sim3dlong.new_collectionGaussianT(*args)
        try: self.this.append(this)
        except: self.this = this
    def setdt(self, *args) -> "void" :
        """setdt(collectionGaussianT self, flt newdt)"""
        return _sim3dlong.collectionGaussianT_setdt(self, *args)

    def setQ(self, *args) -> "void" :
        """setQ(collectionGaussianT self, flt newQ)"""
        return _sim3dlong.collectionGaussianT_setQ(self, *args)

    def setForces(self, *args) -> "void" :
        """
        setForces(collectionGaussianT self, bool seta=True)
        setForces(collectionGaussianT self)
        setForces(collectionGaussianT self, bool seta, bool setxi)
        """
        return _sim3dlong.collectionGaussianT_setForces(self, *args)

    def timestep(self) -> "void" :
        """timestep(collectionGaussianT self)"""
        return _sim3dlong.collectionGaussianT_timestep(self)

    __swig_destroy__ = _sim3dlong.delete_collectionGaussianT
    __del__ = lambda self : None;
collectionGaussianT_swigregister = _sim3dlong.collectionGaussianT_swigregister
collectionGaussianT_swigregister(collectionGaussianT)

class collectionGear3A(collection):
    """Proxy of C++ collectionGear3A class"""
    __swig_setmethods__ = {}
    for _s in [collection]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, collectionGear3A, name, value)
    __swig_getmethods__ = {}
    for _s in [collection]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, collectionGear3A, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(collectionGear3A self, Box box, flt const dt, avector groups=std::vector< atomgroup * >(), ivector interactions=std::vector< interaction * >(), 
            tvector trackers=std::vector< statetracker * >(), 
            constraintvector constraints=std::vector< constraint * >()) -> collectionGear3A
        __init__(collectionGear3A self, Box box, flt const dt, avector groups=std::vector< atomgroup * >(), ivector interactions=std::vector< interaction * >(), 
            tvector trackers=std::vector< statetracker * >()) -> collectionGear3A
        __init__(collectionGear3A self, Box box, flt const dt, avector groups=std::vector< atomgroup * >(), ivector interactions=std::vector< interaction * >()) -> collectionGear3A
        __init__(collectionGear3A self, Box box, flt const dt, avector groups=std::vector< atomgroup * >()) -> collectionGear3A
        __init__(collectionGear3A self, Box box, flt const dt) -> collectionGear3A
        """
        this = _sim3dlong.new_collectionGear3A(*args)
        try: self.this.append(this)
        except: self.this = this
    def timestep(self) -> "void" :
        """timestep(collectionGear3A self)"""
        return _sim3dlong.collectionGear3A_timestep(self)

    def setdt(self, *args) -> "void" :
        """setdt(collectionGear3A self, flt newdt)"""
        return _sim3dlong.collectionGear3A_setdt(self, *args)

    __swig_destroy__ = _sim3dlong.delete_collectionGear3A
    __del__ = lambda self : None;
collectionGear3A_swigregister = _sim3dlong.collectionGear3A_swigregister
collectionGear3A_swigregister(collectionGear3A)

class collectionGear4A(collection):
    """Proxy of C++ collectionGear4A class"""
    __swig_setmethods__ = {}
    for _s in [collection]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, collectionGear4A, name, value)
    __swig_getmethods__ = {}
    for _s in [collection]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, collectionGear4A, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(collectionGear4A self, Box box, flt const dt, uint ncorrectionsteps, avector groups=std::vector< atomgroup * >(), 
            ivector interactions=std::vector< interaction * >(), tvector trackers=std::vector< statetracker * >(), 
            constraintvector constraints=std::vector< constraint * >()) -> collectionGear4A
        __init__(collectionGear4A self, Box box, flt const dt, uint ncorrectionsteps, avector groups=std::vector< atomgroup * >(), 
            ivector interactions=std::vector< interaction * >(), tvector trackers=std::vector< statetracker * >()) -> collectionGear4A
        __init__(collectionGear4A self, Box box, flt const dt, uint ncorrectionsteps, avector groups=std::vector< atomgroup * >(), 
            ivector interactions=std::vector< interaction * >()) -> collectionGear4A
        __init__(collectionGear4A self, Box box, flt const dt, uint ncorrectionsteps, avector groups=std::vector< atomgroup * >()) -> collectionGear4A
        __init__(collectionGear4A self, Box box, flt const dt, uint ncorrectionsteps) -> collectionGear4A
        __init__(collectionGear4A self, Box box, flt const dt, avector groups=std::vector< atomgroup * >(), ivector interactions=std::vector< interaction * >(), 
            tvector trackers=std::vector< statetracker * >(), 
            constraintvector constraints=std::vector< constraint * >()) -> collectionGear4A
        __init__(collectionGear4A self, Box box, flt const dt, avector groups=std::vector< atomgroup * >(), ivector interactions=std::vector< interaction * >(), 
            tvector trackers=std::vector< statetracker * >()) -> collectionGear4A
        __init__(collectionGear4A self, Box box, flt const dt, avector groups=std::vector< atomgroup * >(), ivector interactions=std::vector< interaction * >()) -> collectionGear4A
        __init__(collectionGear4A self, Box box, flt const dt, avector groups=std::vector< atomgroup * >()) -> collectionGear4A
        __init__(collectionGear4A self, Box box, flt const dt) -> collectionGear4A
        """
        this = _sim3dlong.new_collectionGear4A(*args)
        try: self.this.append(this)
        except: self.this = this
    def timestep(self) -> "void" :
        """timestep(collectionGear4A self)"""
        return _sim3dlong.collectionGear4A_timestep(self)

    def setdt(self, *args) -> "void" :
        """setdt(collectionGear4A self, flt newdt)"""
        return _sim3dlong.collectionGear4A_setdt(self, *args)

    __swig_destroy__ = _sim3dlong.delete_collectionGear4A
    __del__ = lambda self : None;
collectionGear4A_swigregister = _sim3dlong.collectionGear4A_swigregister
collectionGear4A_swigregister(collectionGear4A)

class collectionGear5A(collection):
    """Proxy of C++ collectionGear5A class"""
    __swig_setmethods__ = {}
    for _s in [collection]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, collectionGear5A, name, value)
    __swig_getmethods__ = {}
    for _s in [collection]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, collectionGear5A, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(collectionGear5A self, Box box, flt const dt, uint ncorrectionsteps, avector groups=std::vector< atomgroup * >(), 
            ivector interactions=std::vector< interaction * >(), tvector trackers=std::vector< statetracker * >(), 
            constraintvector constraints=std::vector< constraint * >()) -> collectionGear5A
        __init__(collectionGear5A self, Box box, flt const dt, uint ncorrectionsteps, avector groups=std::vector< atomgroup * >(), 
            ivector interactions=std::vector< interaction * >(), tvector trackers=std::vector< statetracker * >()) -> collectionGear5A
        __init__(collectionGear5A self, Box box, flt const dt, uint ncorrectionsteps, avector groups=std::vector< atomgroup * >(), 
            ivector interactions=std::vector< interaction * >()) -> collectionGear5A
        __init__(collectionGear5A self, Box box, flt const dt, uint ncorrectionsteps, avector groups=std::vector< atomgroup * >()) -> collectionGear5A
        __init__(collectionGear5A self, Box box, flt const dt, uint ncorrectionsteps) -> collectionGear5A
        __init__(collectionGear5A self, Box box, flt const dt, avector groups=std::vector< atomgroup * >(), ivector interactions=std::vector< interaction * >(), 
            tvector trackers=std::vector< statetracker * >(), 
            constraintvector constraints=std::vector< constraint * >()) -> collectionGear5A
        __init__(collectionGear5A self, Box box, flt const dt, avector groups=std::vector< atomgroup * >(), ivector interactions=std::vector< interaction * >(), 
            tvector trackers=std::vector< statetracker * >()) -> collectionGear5A
        __init__(collectionGear5A self, Box box, flt const dt, avector groups=std::vector< atomgroup * >(), ivector interactions=std::vector< interaction * >()) -> collectionGear5A
        __init__(collectionGear5A self, Box box, flt const dt, avector groups=std::vector< atomgroup * >()) -> collectionGear5A
        __init__(collectionGear5A self, Box box, flt const dt) -> collectionGear5A
        """
        this = _sim3dlong.new_collectionGear5A(*args)
        try: self.this.append(this)
        except: self.this = this
    def timestep(self) -> "void" :
        """timestep(collectionGear5A self)"""
        return _sim3dlong.collectionGear5A_timestep(self)

    def setdt(self, *args) -> "void" :
        """setdt(collectionGear5A self, flt newdt)"""
        return _sim3dlong.collectionGear5A_setdt(self, *args)

    __swig_destroy__ = _sim3dlong.delete_collectionGear5A
    __del__ = lambda self : None;
collectionGear5A_swigregister = _sim3dlong.collectionGear5A_swigregister
collectionGear5A_swigregister(collectionGear5A)

class collectionGear6A(collection):
    """Proxy of C++ collectionGear6A class"""
    __swig_setmethods__ = {}
    for _s in [collection]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, collectionGear6A, name, value)
    __swig_getmethods__ = {}
    for _s in [collection]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, collectionGear6A, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(collectionGear6A self, Box box, flt const dt, uint ncorrectionsteps, avector groups=std::vector< atomgroup * >(), 
            ivector interactions=std::vector< interaction * >(), tvector trackers=std::vector< statetracker * >(), 
            constraintvector constraints=std::vector< constraint * >()) -> collectionGear6A
        __init__(collectionGear6A self, Box box, flt const dt, uint ncorrectionsteps, avector groups=std::vector< atomgroup * >(), 
            ivector interactions=std::vector< interaction * >(), tvector trackers=std::vector< statetracker * >()) -> collectionGear6A
        __init__(collectionGear6A self, Box box, flt const dt, uint ncorrectionsteps, avector groups=std::vector< atomgroup * >(), 
            ivector interactions=std::vector< interaction * >()) -> collectionGear6A
        __init__(collectionGear6A self, Box box, flt const dt, uint ncorrectionsteps, avector groups=std::vector< atomgroup * >()) -> collectionGear6A
        __init__(collectionGear6A self, Box box, flt const dt, uint ncorrectionsteps) -> collectionGear6A
        __init__(collectionGear6A self, Box box, flt const dt, avector groups=std::vector< atomgroup * >(), ivector interactions=std::vector< interaction * >(), 
            tvector trackers=std::vector< statetracker * >(), 
            constraintvector constraints=std::vector< constraint * >()) -> collectionGear6A
        __init__(collectionGear6A self, Box box, flt const dt, avector groups=std::vector< atomgroup * >(), ivector interactions=std::vector< interaction * >(), 
            tvector trackers=std::vector< statetracker * >()) -> collectionGear6A
        __init__(collectionGear6A self, Box box, flt const dt, avector groups=std::vector< atomgroup * >(), ivector interactions=std::vector< interaction * >()) -> collectionGear6A
        __init__(collectionGear6A self, Box box, flt const dt, avector groups=std::vector< atomgroup * >()) -> collectionGear6A
        __init__(collectionGear6A self, Box box, flt const dt) -> collectionGear6A
        """
        this = _sim3dlong.new_collectionGear6A(*args)
        try: self.this.append(this)
        except: self.this = this
    def timestep(self) -> "void" :
        """timestep(collectionGear6A self)"""
        return _sim3dlong.collectionGear6A_timestep(self)

    def setdt(self, *args) -> "void" :
        """setdt(collectionGear6A self, flt newdt)"""
        return _sim3dlong.collectionGear6A_setdt(self, *args)

    __swig_destroy__ = _sim3dlong.delete_collectionGear6A
    __del__ = lambda self : None;
collectionGear6A_swigregister = _sim3dlong.collectionGear6A_swigregister
collectionGear6A_swigregister(collectionGear6A)

class atomRK4(atom):
    """Proxy of C++ atomRK4 class"""
    __swig_setmethods__ = {}
    for _s in [atom]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, atomRK4, name, value)
    __swig_getmethods__ = {}
    for _s in [atom]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, atomRK4, name)
    __repr__ = _swig_repr
    __swig_setmethods__["Kxa"] = _sim3dlong.atomRK4_Kxa_set
    __swig_getmethods__["Kxa"] = _sim3dlong.atomRK4_Kxa_get
    if _newclass:Kxa = _swig_property(_sim3dlong.atomRK4_Kxa_get, _sim3dlong.atomRK4_Kxa_set)
    __swig_setmethods__["Kxb"] = _sim3dlong.atomRK4_Kxb_set
    __swig_getmethods__["Kxb"] = _sim3dlong.atomRK4_Kxb_get
    if _newclass:Kxb = _swig_property(_sim3dlong.atomRK4_Kxb_get, _sim3dlong.atomRK4_Kxb_set)
    __swig_setmethods__["Kxc"] = _sim3dlong.atomRK4_Kxc_set
    __swig_getmethods__["Kxc"] = _sim3dlong.atomRK4_Kxc_get
    if _newclass:Kxc = _swig_property(_sim3dlong.atomRK4_Kxc_get, _sim3dlong.atomRK4_Kxc_set)
    __swig_setmethods__["Kxd"] = _sim3dlong.atomRK4_Kxd_set
    __swig_getmethods__["Kxd"] = _sim3dlong.atomRK4_Kxd_get
    if _newclass:Kxd = _swig_property(_sim3dlong.atomRK4_Kxd_get, _sim3dlong.atomRK4_Kxd_set)
    __swig_setmethods__["Kva"] = _sim3dlong.atomRK4_Kva_set
    __swig_getmethods__["Kva"] = _sim3dlong.atomRK4_Kva_get
    if _newclass:Kva = _swig_property(_sim3dlong.atomRK4_Kva_get, _sim3dlong.atomRK4_Kva_set)
    __swig_setmethods__["Kvb"] = _sim3dlong.atomRK4_Kvb_set
    __swig_getmethods__["Kvb"] = _sim3dlong.atomRK4_Kvb_get
    if _newclass:Kvb = _swig_property(_sim3dlong.atomRK4_Kvb_get, _sim3dlong.atomRK4_Kvb_set)
    __swig_setmethods__["Kvc"] = _sim3dlong.atomRK4_Kvc_set
    __swig_getmethods__["Kvc"] = _sim3dlong.atomRK4_Kvc_get
    if _newclass:Kvc = _swig_property(_sim3dlong.atomRK4_Kvc_get, _sim3dlong.atomRK4_Kvc_set)
    __swig_setmethods__["Kvd"] = _sim3dlong.atomRK4_Kvd_set
    __swig_getmethods__["Kvd"] = _sim3dlong.atomRK4_Kvd_get
    if _newclass:Kvd = _swig_property(_sim3dlong.atomRK4_Kvd_get, _sim3dlong.atomRK4_Kvd_set)
    def __init__(self): 
        """__init__(atomRK4 self) -> atomRK4"""
        this = _sim3dlong.new_atomRK4()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _sim3dlong.delete_atomRK4
    __del__ = lambda self : None;
atomRK4_swigregister = _sim3dlong.atomRK4_swigregister
atomRK4_swigregister(atomRK4)

class atomvecRK4(atomgroup):
    """Proxy of C++ atomvecRK4 class"""
    __swig_setmethods__ = {}
    for _s in [atomgroup]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, atomvecRK4, name, value)
    __swig_getmethods__ = {}
    for _s in [atomgroup]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, atomvecRK4, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(atomvecRK4 self, ldvector masses) -> atomvecRK4
        __init__(atomvecRK4 self, atomgroup g) -> atomvecRK4
        """
        this = _sim3dlong.new_atomvecRK4(*args)
        try: self.this.append(this)
        except: self.this = this
    def get(self, *args) -> "atom *" :
        """get(atomvecRK4 self, cuint n) -> atom"""
        return _sim3dlong.atomvecRK4_get(self, *args)

    def getRK4(self, *args) -> "atomRK4 *" :
        """getRK4(atomvecRK4 self, cuint n) -> atomRK4"""
        return _sim3dlong.atomvecRK4_getRK4(self, *args)

    def get_id(self, *args) -> "atomid" :
        """
        get_id(atomvecRK4 self, atom a) -> atomid
        get_id(atomvecRK4 self, uint n) -> atomid
        """
        return _sim3dlong.atomvecRK4_get_id(self, *args)

    def size(self) -> "uint" :
        """size(atomvecRK4 self) -> uint"""
        return _sim3dlong.atomvecRK4_size(self)

    __swig_destroy__ = _sim3dlong.delete_atomvecRK4
    __del__ = lambda self : None;
atomvecRK4_swigregister = _sim3dlong.atomvecRK4_swigregister
atomvecRK4_swigregister(atomvecRK4)

class collectionRK4(collection):
    """Proxy of C++ collectionRK4 class"""
    __swig_setmethods__ = {}
    for _s in [collection]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, collectionRK4, name, value)
    __swig_getmethods__ = {}
    for _s in [collection]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, collectionRK4, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(collectionRK4 self, Box box, flt const dt, aRK4vector rgroups=std::vector< atomvecRK4 * >(), ivector interactions=std::vector< interaction * >(), 
            tvector trackers=std::vector< statetracker * >(), 
            constraintvector constraints=std::vector< constraint * >()) -> collectionRK4
        __init__(collectionRK4 self, Box box, flt const dt, aRK4vector rgroups=std::vector< atomvecRK4 * >(), ivector interactions=std::vector< interaction * >(), 
            tvector trackers=std::vector< statetracker * >()) -> collectionRK4
        __init__(collectionRK4 self, Box box, flt const dt, aRK4vector rgroups=std::vector< atomvecRK4 * >(), ivector interactions=std::vector< interaction * >()) -> collectionRK4
        __init__(collectionRK4 self, Box box, flt const dt, aRK4vector rgroups=std::vector< atomvecRK4 * >()) -> collectionRK4
        __init__(collectionRK4 self, Box box, flt const dt) -> collectionRK4
        """
        this = _sim3dlong.new_collectionRK4(*args)
        try: self.this.append(this)
        except: self.this = this
    def timestep(self) -> "void" :
        """timestep(collectionRK4 self)"""
        return _sim3dlong.collectionRK4_timestep(self)

    def setdt(self, *args) -> "void" :
        """setdt(collectionRK4 self, flt newdt)"""
        return _sim3dlong.collectionRK4_setdt(self, *args)

    __swig_destroy__ = _sim3dlong.delete_collectionRK4
    __del__ = lambda self : None;
collectionRK4_swigregister = _sim3dlong.collectionRK4_swigregister
collectionRK4_swigregister(collectionRK4)

class collectionGear4NPH(collection):
    """Proxy of C++ collectionGear4NPH class"""
    __swig_setmethods__ = {}
    for _s in [collection]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, collectionGear4NPH, name, value)
    __swig_getmethods__ = {}
    for _s in [collection]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, collectionGear4NPH, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(collectionGear4NPH self, OriginBox box, flt const dt, flt const P, flt const Q, uint ncorrectionsteps, avector groups=std::vector< atomgroup * >(), 
            ivector interactions=std::vector< interaction * >(), 
            tvector trackers=std::vector< statetracker * >(), constraintvector constraints=std::vector< constraint * >()) -> collectionGear4NPH
        __init__(collectionGear4NPH self, OriginBox box, flt const dt, flt const P, flt const Q, uint ncorrectionsteps, avector groups=std::vector< atomgroup * >(), 
            ivector interactions=std::vector< interaction * >(), 
            tvector trackers=std::vector< statetracker * >()) -> collectionGear4NPH
        __init__(collectionGear4NPH self, OriginBox box, flt const dt, flt const P, flt const Q, uint ncorrectionsteps, avector groups=std::vector< atomgroup * >(), 
            ivector interactions=std::vector< interaction * >()) -> collectionGear4NPH
        __init__(collectionGear4NPH self, OriginBox box, flt const dt, flt const P, flt const Q, uint ncorrectionsteps, avector groups=std::vector< atomgroup * >()) -> collectionGear4NPH
        __init__(collectionGear4NPH self, OriginBox box, flt const dt, flt const P, flt const Q, uint ncorrectionsteps) -> collectionGear4NPH
        __init__(collectionGear4NPH self, OriginBox box, flt const dt, flt const P, flt const Q, avector groups=std::vector< atomgroup * >(), 
            ivector interactions=std::vector< interaction * >(), tvector trackers=std::vector< statetracker * >(), 
            constraintvector constraints=std::vector< constraint * >()) -> collectionGear4NPH
        __init__(collectionGear4NPH self, OriginBox box, flt const dt, flt const P, flt const Q, avector groups=std::vector< atomgroup * >(), 
            ivector interactions=std::vector< interaction * >(), tvector trackers=std::vector< statetracker * >()) -> collectionGear4NPH
        __init__(collectionGear4NPH self, OriginBox box, flt const dt, flt const P, flt const Q, avector groups=std::vector< atomgroup * >(), 
            ivector interactions=std::vector< interaction * >()) -> collectionGear4NPH
        __init__(collectionGear4NPH self, OriginBox box, flt const dt, flt const P, flt const Q, avector groups=std::vector< atomgroup * >()) -> collectionGear4NPH
        __init__(collectionGear4NPH self, OriginBox box, flt const dt, flt const P, flt const Q) -> collectionGear4NPH
        """
        this = _sim3dlong.new_collectionGear4NPH(*args)
        try: self.this.append(this)
        except: self.this = this
    def timestep(self) -> "void" :
        """timestep(collectionGear4NPH self)"""
        return _sim3dlong.collectionGear4NPH_timestep(self)

    def kinetic(self) -> "flt" :
        """kinetic(collectionGear4NPH self) -> flt"""
        return _sim3dlong.collectionGear4NPH_kinetic(self)

    def temp(self, minuscomv : 'bool'=True) -> "flt" :
        """
        temp(collectionGear4NPH self, bool minuscomv=True) -> flt
        temp(collectionGear4NPH self) -> flt
        """
        return _sim3dlong.collectionGear4NPH_temp(self, minuscomv)

    def Hamiltonian(self) -> "flt" :
        """Hamiltonian(collectionGear4NPH self) -> flt"""
        return _sim3dlong.collectionGear4NPH_Hamiltonian(self)

    def getdV(self) -> "flt" :
        """getdV(collectionGear4NPH self) -> flt"""
        return _sim3dlong.collectionGear4NPH_getdV(self)

    def getddV(self) -> "flt" :
        """getddV(collectionGear4NPH self) -> flt"""
        return _sim3dlong.collectionGear4NPH_getddV(self)

    def setdt(self, *args) -> "void" :
        """setdt(collectionGear4NPH self, flt newdt)"""
        return _sim3dlong.collectionGear4NPH_setdt(self, *args)

    __swig_destroy__ = _sim3dlong.delete_collectionGear4NPH
    __del__ = lambda self : None;
collectionGear4NPH_swigregister = _sim3dlong.collectionGear4NPH_swigregister
collectionGear4NPH_swigregister(collectionGear4NPH)

class xrpsummer(fpairxFunct):
    """Proxy of C++ xrpsummer class"""
    __swig_setmethods__ = {}
    for _s in [fpairxFunct]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, xrpsummer, name, value)
    __swig_getmethods__ = {}
    for _s in [fpairxFunct]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, xrpsummer, name)
    __repr__ = _swig_repr
    __swig_setmethods__["xsum"] = _sim3dlong.xrpsummer_xsum_set
    __swig_getmethods__["xsum"] = _sim3dlong.xrpsummer_xsum_get
    if _newclass:xsum = _swig_property(_sim3dlong.xrpsummer_xsum_get, _sim3dlong.xrpsummer_xsum_set)
    __swig_setmethods__["rpxsum"] = _sim3dlong.xrpsummer_rpxsum_set
    __swig_getmethods__["rpxsum"] = _sim3dlong.xrpsummer_rpxsum_get
    if _newclass:rpxsum = _swig_property(_sim3dlong.xrpsummer_rpxsum_get, _sim3dlong.xrpsummer_rpxsum_set)
    __swig_setmethods__["vfsum"] = _sim3dlong.xrpsummer_vfsum_set
    __swig_getmethods__["vfsum"] = _sim3dlong.xrpsummer_vfsum_get
    if _newclass:vfsum = _swig_property(_sim3dlong.xrpsummer_vfsum_get, _sim3dlong.xrpsummer_vfsum_set)
    __swig_setmethods__["rfsum"] = _sim3dlong.xrpsummer_rfsum_set
    __swig_getmethods__["rfsum"] = _sim3dlong.xrpsummer_rfsum_get
    if _newclass:rfsum = _swig_property(_sim3dlong.xrpsummer_rfsum_get, _sim3dlong.xrpsummer_rfsum_set)
    def __init__(self, *args): 
        """__init__(xrpsummer self, Box box) -> xrpsummer"""
        this = _sim3dlong.new_xrpsummer(*args)
        try: self.this.append(this)
        except: self.this = this
    def run(self, *args) -> "void" :
        """run(xrpsummer self, forcepairx arg2)"""
        return _sim3dlong.xrpsummer_run(self, *args)

    def reset(self) -> "void" :
        """reset(xrpsummer self)"""
        return _sim3dlong.xrpsummer_reset(self)

    __swig_destroy__ = _sim3dlong.delete_xrpsummer
    __del__ = lambda self : None;
xrpsummer_swigregister = _sim3dlong.xrpsummer_swigregister
xrpsummer_swigregister(xrpsummer)

class collectionGear4NPT(collection):
    """Proxy of C++ collectionGear4NPT class"""
    __swig_setmethods__ = {}
    for _s in [collection]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, collectionGear4NPT, name, value)
    __swig_getmethods__ = {}
    for _s in [collection]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, collectionGear4NPT, name)
    __repr__ = _swig_repr
    __swig_setmethods__["dt"] = _sim3dlong.collectionGear4NPT_dt_set
    __swig_getmethods__["dt"] = _sim3dlong.collectionGear4NPT_dt_get
    if _newclass:dt = _swig_property(_sim3dlong.collectionGear4NPT_dt_get, _sim3dlong.collectionGear4NPT_dt_set)
    __swig_setmethods__["xrpsums"] = _sim3dlong.collectionGear4NPT_xrpsums_set
    __swig_getmethods__["xrpsums"] = _sim3dlong.collectionGear4NPT_xrpsums_get
    if _newclass:xrpsums = _swig_property(_sim3dlong.collectionGear4NPT_xrpsums_get, _sim3dlong.collectionGear4NPT_xrpsums_set)
    __swig_setmethods__["ncorrec"] = _sim3dlong.collectionGear4NPT_ncorrec_set
    __swig_getmethods__["ncorrec"] = _sim3dlong.collectionGear4NPT_ncorrec_get
    if _newclass:ncorrec = _swig_property(_sim3dlong.collectionGear4NPT_ncorrec_get, _sim3dlong.collectionGear4NPT_ncorrec_set)
    __swig_setmethods__["V1"] = _sim3dlong.collectionGear4NPT_V1_set
    __swig_getmethods__["V1"] = _sim3dlong.collectionGear4NPT_V1_get
    if _newclass:V1 = _swig_property(_sim3dlong.collectionGear4NPT_V1_get, _sim3dlong.collectionGear4NPT_V1_set)
    __swig_setmethods__["V2"] = _sim3dlong.collectionGear4NPT_V2_set
    __swig_getmethods__["V2"] = _sim3dlong.collectionGear4NPT_V2_get
    if _newclass:V2 = _swig_property(_sim3dlong.collectionGear4NPT_V2_get, _sim3dlong.collectionGear4NPT_V2_set)
    __swig_setmethods__["V3"] = _sim3dlong.collectionGear4NPT_V3_set
    __swig_getmethods__["V3"] = _sim3dlong.collectionGear4NPT_V3_get
    if _newclass:V3 = _swig_property(_sim3dlong.collectionGear4NPT_V3_get, _sim3dlong.collectionGear4NPT_V3_set)
    __swig_setmethods__["chi"] = _sim3dlong.collectionGear4NPT_chi_set
    __swig_getmethods__["chi"] = _sim3dlong.collectionGear4NPT_chi_get
    if _newclass:chi = _swig_property(_sim3dlong.collectionGear4NPT_chi_get, _sim3dlong.collectionGear4NPT_chi_set)
    __swig_setmethods__["chixi"] = _sim3dlong.collectionGear4NPT_chixi_set
    __swig_getmethods__["chixi"] = _sim3dlong.collectionGear4NPT_chixi_get
    if _newclass:chixi = _swig_property(_sim3dlong.collectionGear4NPT_chixi_get, _sim3dlong.collectionGear4NPT_chixi_set)
    __swig_setmethods__["xs1"] = _sim3dlong.collectionGear4NPT_xs1_set
    __swig_getmethods__["xs1"] = _sim3dlong.collectionGear4NPT_xs1_get
    if _newclass:xs1 = _swig_property(_sim3dlong.collectionGear4NPT_xs1_get, _sim3dlong.collectionGear4NPT_xs1_set)
    __swig_setmethods__["xs2"] = _sim3dlong.collectionGear4NPT_xs2_set
    __swig_getmethods__["xs2"] = _sim3dlong.collectionGear4NPT_xs2_get
    if _newclass:xs2 = _swig_property(_sim3dlong.collectionGear4NPT_xs2_get, _sim3dlong.collectionGear4NPT_xs2_set)
    __swig_setmethods__["xs3"] = _sim3dlong.collectionGear4NPT_xs3_set
    __swig_getmethods__["xs3"] = _sim3dlong.collectionGear4NPT_xs3_get
    if _newclass:xs3 = _swig_property(_sim3dlong.collectionGear4NPT_xs3_get, _sim3dlong.collectionGear4NPT_xs3_set)
    __swig_setmethods__["vs2"] = _sim3dlong.collectionGear4NPT_vs2_set
    __swig_getmethods__["vs2"] = _sim3dlong.collectionGear4NPT_vs2_get
    if _newclass:vs2 = _swig_property(_sim3dlong.collectionGear4NPT_vs2_get, _sim3dlong.collectionGear4NPT_vs2_set)
    __swig_setmethods__["vs3"] = _sim3dlong.collectionGear4NPT_vs3_set
    __swig_getmethods__["vs3"] = _sim3dlong.collectionGear4NPT_vs3_get
    if _newclass:vs3 = _swig_property(_sim3dlong.collectionGear4NPT_vs3_get, _sim3dlong.collectionGear4NPT_vs3_set)
    def resetbs(self) -> "void" :
        """resetbs(collectionGear4NPT self)"""
        return _sim3dlong.collectionGear4NPT_resetbs(self)

    def tointerpair(*args) -> "std::vector< interaction * >" :
        """tointerpair(ifxvector arg1) -> ivector"""
        return _sim3dlong.collectionGear4NPT_tointerpair(*args)

    if _newclass:tointerpair = staticmethod(tointerpair)
    __swig_getmethods__["tointerpair"] = lambda x: tointerpair
    def __init__(self, *args): 
        """
        __init__(collectionGear4NPT self, OriginBox box, flt const dt, uint ncorrectionsteps, avector groups=std::vector< atomgroup * >(), 
            ifxvector interactions=std::vector< interactionpairsx * >(), 
            tvector trackers=std::vector< statetracker * >(), constraintvector constraints=std::vector< constraint * >()) -> collectionGear4NPT
        __init__(collectionGear4NPT self, OriginBox box, flt const dt, uint ncorrectionsteps, avector groups=std::vector< atomgroup * >(), 
            ifxvector interactions=std::vector< interactionpairsx * >(), 
            tvector trackers=std::vector< statetracker * >()) -> collectionGear4NPT
        __init__(collectionGear4NPT self, OriginBox box, flt const dt, uint ncorrectionsteps, avector groups=std::vector< atomgroup * >(), 
            ifxvector interactions=std::vector< interactionpairsx * >()) -> collectionGear4NPT
        __init__(collectionGear4NPT self, OriginBox box, flt const dt, uint ncorrectionsteps, avector groups=std::vector< atomgroup * >()) -> collectionGear4NPT
        __init__(collectionGear4NPT self, OriginBox box, flt const dt, uint ncorrectionsteps) -> collectionGear4NPT
        __init__(collectionGear4NPT self, OriginBox box, flt const dt, avector groups=std::vector< atomgroup * >(), ifxvector interactions=std::vector< interactionpairsx * >(), 
            tvector trackers=std::vector< statetracker * >(), 
            constraintvector constraints=std::vector< constraint * >()) -> collectionGear4NPT
        __init__(collectionGear4NPT self, OriginBox box, flt const dt, avector groups=std::vector< atomgroup * >(), ifxvector interactions=std::vector< interactionpairsx * >(), 
            tvector trackers=std::vector< statetracker * >()) -> collectionGear4NPT
        __init__(collectionGear4NPT self, OriginBox box, flt const dt, avector groups=std::vector< atomgroup * >(), ifxvector interactions=std::vector< interactionpairsx * >()) -> collectionGear4NPT
        __init__(collectionGear4NPT self, OriginBox box, flt const dt, avector groups=std::vector< atomgroup * >()) -> collectionGear4NPT
        __init__(collectionGear4NPT self, OriginBox box, flt const dt) -> collectionGear4NPT
        """
        this = _sim3dlong.new_collectionGear4NPT(*args)
        try: self.this.append(this)
        except: self.this = this
    def setForces(self, seta : 'bool'=True) -> "void" :
        """
        setForces(collectionGear4NPT self, bool seta=True)
        setForces(collectionGear4NPT self)
        """
        return _sim3dlong.collectionGear4NPT_setForces(self, seta)

    def timestep(self) -> "void" :
        """timestep(collectionGear4NPT self)"""
        return _sim3dlong.collectionGear4NPT_timestep(self)

    __swig_destroy__ = _sim3dlong.delete_collectionGear4NPT
    __del__ = lambda self : None;
collectionGear4NPT_swigregister = _sim3dlong.collectionGear4NPT_swigregister
collectionGear4NPT_swigregister(collectionGear4NPT)

def collectionGear4NPT_tointerpair(*args) -> "std::vector< interaction * >" :
  """collectionGear4NPT_tointerpair(ifxvector arg1) -> ivector"""
  return _sim3dlong.collectionGear4NPT_tointerpair(*args)

class collectionVerletNPT(collection):
    """Proxy of C++ collectionVerletNPT class"""
    __swig_setmethods__ = {}
    for _s in [collection]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, collectionVerletNPT, name, value)
    __swig_getmethods__ = {}
    for _s in [collection]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, collectionVerletNPT, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(collectionVerletNPT self, OriginBox box, flt const dt, flt const P, flt const QP, flt const T, flt const QT, 
            avector groups=std::vector< atomgroup * >(), ivector interactions=std::vector< interaction * >(), 
            tvector trackers=std::vector< statetracker * >(), 
            constraintvector constraints=std::vector< constraint * >()) -> collectionVerletNPT
        __init__(collectionVerletNPT self, OriginBox box, flt const dt, flt const P, flt const QP, flt const T, flt const QT, 
            avector groups=std::vector< atomgroup * >(), ivector interactions=std::vector< interaction * >(), 
            tvector trackers=std::vector< statetracker * >()) -> collectionVerletNPT
        __init__(collectionVerletNPT self, OriginBox box, flt const dt, flt const P, flt const QP, flt const T, flt const QT, 
            avector groups=std::vector< atomgroup * >(), ivector interactions=std::vector< interaction * >()) -> collectionVerletNPT
        __init__(collectionVerletNPT self, OriginBox box, flt const dt, flt const P, flt const QP, flt const T, flt const QT, 
            avector groups=std::vector< atomgroup * >()) -> collectionVerletNPT
        __init__(collectionVerletNPT self, OriginBox box, flt const dt, flt const P, flt const QP, flt const T, flt const QT) -> collectionVerletNPT
        """
        this = _sim3dlong.new_collectionVerletNPT(*args)
        try: self.this.append(this)
        except: self.this = this
    def timestep(self) -> "void" :
        """timestep(collectionVerletNPT self)"""
        return _sim3dlong.collectionVerletNPT_timestep(self)

    def setdt(self, *args) -> "void" :
        """setdt(collectionVerletNPT self, flt newdt)"""
        return _sim3dlong.collectionVerletNPT_setdt(self, *args)

    def resetcomv(self) -> "void" :
        """resetcomv(collectionVerletNPT self)"""
        return _sim3dlong.collectionVerletNPT_resetcomv(self)

    def resetL(self) -> "void" :
        """resetL(collectionVerletNPT self)"""
        return _sim3dlong.collectionVerletNPT_resetL(self)

    def scaleVs(self, *args) -> "void" :
        """scaleVs(collectionVerletNPT self, flt scaleby)"""
        return _sim3dlong.collectionVerletNPT_scaleVs(self, *args)

    def scaleVelocitiesT(self, *args) -> "void" :
        """scaleVelocitiesT(collectionVerletNPT self, flt T)"""
        return _sim3dlong.collectionVerletNPT_scaleVelocitiesT(self, *args)

    def scaleVelocitiesE(self, *args) -> "void" :
        """scaleVelocitiesE(collectionVerletNPT self, flt E)"""
        return _sim3dlong.collectionVerletNPT_scaleVelocitiesE(self, *args)

    def geteta(self) -> "flt" :
        """geteta(collectionVerletNPT self) -> flt"""
        return _sim3dlong.collectionVerletNPT_geteta(self)

    def getxidot(self) -> "flt" :
        """getxidot(collectionVerletNPT self) -> flt"""
        return _sim3dlong.collectionVerletNPT_getxidot(self)

    def getP(self) -> "flt" :
        """getP(collectionVerletNPT self) -> flt"""
        return _sim3dlong.collectionVerletNPT_getP(self)

    def getvhalf(self, *args) -> "Vec" :
        """getvhalf(collectionVerletNPT self, uint n) -> VecL"""
        return _sim3dlong.collectionVerletNPT_getvhalf(self, *args)

    __swig_destroy__ = _sim3dlong.delete_collectionVerletNPT
    __del__ = lambda self : None;
collectionVerletNPT_swigregister = _sim3dlong.collectionVerletNPT_swigregister
collectionVerletNPT_swigregister(collectionVerletNPT)

# This file is compatible with both classic and new-style classes.


