#!/usr/bin/env python2
from __future__ import print_function

import xyzstats, xyzfile
import argparse
from matplotlib import pyplot as plt
from contextlib import closing
import numpy as np, math
import re
import os, os.path, glob
from simw import running_avg
from smooth import smooth

import logging, sys
#~ logging.getLogger().setLevel(logging.DEBUG)

import numpy
numpy.seterr('raise')

parser = argparse.ArgumentParser()
parser.add_argument('files', nargs='+', type=str)
parser.add_argument('-t', dest='ext', type=str, default='eps')
parser.add_argument('-c', dest = 'combined', type=str, default=None)
parser.add_argument('-a', dest = 'averages', type=str, default=None)
parser.add_argument('-f', dest = 'full', action='store_true')
parser.add_argument('-v', dest = 'verbose', action='store_true')


opts = parser.parse_args()

if len(opts.files) == 1 and os.path.isdir(opts.files[0]):
    d = opts.files[0]
    opts.files = glob.glob(d + '/*.xyz')
    opts.combined = d + '/combined.eps'
    opts.averages = d + '/avgs.eps'

def convertfname(f):
    m = re.search('T(\d*\.?\d+)', f)
    if m is None:
        print('Could not match filename', f)
        return f
    n, = m.groups()
    return n

Rgs = {}
Rg_avgs = {}

def status(s):
    if opts.verbose:
        print(s, file=sys.stderr)

for n,f in enumerate(opts.files):
    base, sep, ext = f.rpartition('.')
    statfname = base + sep + 'stats'
    Tstr = convertfname(f)
    T = float(Tstr)
    print('Running', f, '(%d / %d)' % (n+1, len(opts.files)))
    with xyzstats.statkeeper(f, statfname) as sk:
        status('getting Rg')
        gyradii = sk.Rg()
        #~ Rg_avg = xyzstats.average(Rg)
        status('getting times')
        ts = [t/1000.0 for t in sk.times]
        status('getting relaxation')
        relaxt = sk.relax_acorr() if not opts.full else sk.relax_ISF()
        status('getting sim_Rg')
        sim_Rg = Rg,std,err,npoints = sk.sim_Rg(relaxt)
        if npoints is None: npoints = 0
        if np.isnan([Rg,std,err]).any() or std <= 1e-8:
            print('NANS!!!')
            continue
        Rg_avgs[T] = sim_Rg
        opts.verbose and print('getting relax_Rg')
        acts, acs = sk.ISF_Rg() if opts.full else sk.autocorr()
        acts = [t/1000.0 for t in acts]
    #~ print('Rg:', Rg_avg)
    #~ print(Rg, std, err)
    print('Rg: %.2f; std: %.3f; err: %.3f; N: %.2f' % sim_Rg)
    status('plotting')
    fig=plt.figure('Single File')
    plt.clf()
    ax1 = fig.add_subplot(111)
    ax1.plot(ts, gyradii,color='b')
    ax1.plot(ts, running_avg(gyradii), color=(.6,.6,.6))
    status('setting properties')
    ax1.set_xlabel('time (unitless, thousands)')
    ax1.set_ylabel('Rg (angstroms)',color='b')
    for tl in ax1.get_yticklabels():
        tl.set_color('b')
    ax2 = ax1.twinx()
    ax2.plot(acts, acs,color='g')
    ax2.set_ylabel('Autocorrelation',color='g')
    for tl in ax2.get_yticklabels():
        tl.set_color('g')
    status('saving fig')
    plt.savefig(base + '-Rg' + '.' + opts.ext)
    
    if opts.combined:
        Tnum = convertfname(f)
        Rgs[T] = (Tstr, ts, gyradii, npoints)


if opts.averages:
    plt.figure('Rg Averages')
    plt.xlabel('T (unitless)')
    plt.ylabel('Rg (angstroms)')
    vals = [(T,) + v for T,v in sorted(Rg_avgs.items())]
    #~ print(vals)
    Ts, Rg, stds, errors, npoints = zip(*vals)
    #~ print('Rgs:', *Rgs)
    #~ print('err:', *errors)
    
    # negative error means one full relaxation time was not met.
    # just use 0 then...
    errors = np.array([max(0,err) for err in errors])
    #~ Ts=[1,2,3]
    #~ Rgs=[37.2,40.6,36.23]
    #~ Rgs = np.array(Rgs)
    plt.fill_between(Ts, Rg-errors, Rg+errors, color=(.6,.6,.6))
    plt.errorbar(Ts, Rg, yerr=stds)
    #~ plt.gca().set_xscale('log')
    #~ plt.xlim([0,Ts[-1]*1.08])
    plt.savefig(opts.averages)

if opts.combined:
    plt.figure('Rg')
    for T, Rgtuple in sorted(Rgs.items()):
        Tstr, ts, Rg, Npts = Rgtuple
        windowsize = len(ts) / 200.0
        Rg = smooth(Rg, windowsize)
        plt.plot(ts, Rg, label=('T = %s (%d)' % (Tstr, Npts)))
    plt.legend(prop={'size':9})
    plt.xlabel('time (unitless)')
    plt.ylabel('Rg (angstroms)')
    plt.savefig(opts.combined)
