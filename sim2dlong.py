# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.11
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_sim2dlong', [dirname(__file__)])
        except ImportError:
            import _sim2dlong
            return _sim2dlong
        if fp is not None:
            try:
                _mod = imp.load_module('_sim2dlong', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _sim2dlong = swig_import_helper()
    del swig_import_helper
else:
    import _sim2dlong
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


import collections
class SwigPyIterator(_object):
    """Proxy of C++ swig::SwigPyIterator class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _sim2dlong.delete_SwigPyIterator
    __del__ = lambda self : None;
    def value(self) -> "PyObject *" :
        """value(SwigPyIterator self) -> PyObject *"""
        return _sim2dlong.SwigPyIterator_value(self)

    def incr(self, n : 'size_t'=1) -> "swig::SwigPyIterator *" :
        """
        incr(SwigPyIterator self, size_t n=1) -> SwigPyIterator
        incr(SwigPyIterator self) -> SwigPyIterator
        """
        return _sim2dlong.SwigPyIterator_incr(self, n)

    def decr(self, n : 'size_t'=1) -> "swig::SwigPyIterator *" :
        """
        decr(SwigPyIterator self, size_t n=1) -> SwigPyIterator
        decr(SwigPyIterator self) -> SwigPyIterator
        """
        return _sim2dlong.SwigPyIterator_decr(self, n)

    def distance(self, *args) -> "ptrdiff_t" :
        """distance(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t"""
        return _sim2dlong.SwigPyIterator_distance(self, *args)

    def equal(self, *args) -> "bool" :
        """equal(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _sim2dlong.SwigPyIterator_equal(self, *args)

    def copy(self) -> "swig::SwigPyIterator *" :
        """copy(SwigPyIterator self) -> SwigPyIterator"""
        return _sim2dlong.SwigPyIterator_copy(self)

    def next(self) -> "PyObject *" :
        """next(SwigPyIterator self) -> PyObject *"""
        return _sim2dlong.SwigPyIterator_next(self)

    def __next__(self) -> "PyObject *" :
        """__next__(SwigPyIterator self) -> PyObject *"""
        return _sim2dlong.SwigPyIterator___next__(self)

    def previous(self) -> "PyObject *" :
        """previous(SwigPyIterator self) -> PyObject *"""
        return _sim2dlong.SwigPyIterator_previous(self)

    def advance(self, *args) -> "swig::SwigPyIterator *" :
        """advance(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _sim2dlong.SwigPyIterator_advance(self, *args)

    def __eq__(self, *args) -> "bool" :
        """__eq__(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _sim2dlong.SwigPyIterator___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        """__ne__(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _sim2dlong.SwigPyIterator___ne__(self, *args)

    def __iadd__(self, *args) -> "swig::SwigPyIterator &" :
        """__iadd__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _sim2dlong.SwigPyIterator___iadd__(self, *args)

    def __isub__(self, *args) -> "swig::SwigPyIterator &" :
        """__isub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _sim2dlong.SwigPyIterator___isub__(self, *args)

    def __add__(self, *args) -> "swig::SwigPyIterator *" :
        """__add__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _sim2dlong.SwigPyIterator___add__(self, *args)

    def __sub__(self, *args) -> "ptrdiff_t" :
        """
        __sub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator
        __sub__(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t
        """
        return _sim2dlong.SwigPyIterator___sub__(self, *args)

    def __iter__(self): return self
SwigPyIterator_swigregister = _sim2dlong.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class _Nvector3(_object):
    """Proxy of C++ Nvector<(double,3)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _Nvector3, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _Nvector3, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(Nvector<(double,3)> self) -> _Nvector3
        __init__(Nvector<(double,3)> self, _Nvector3 rhs) -> _Nvector3
        __init__(Nvector<(double,3)> self, double const [3] locs) -> _Nvector3
        """
        this = _sim2dlong.new__Nvector3(*args)
        try: self.this.append(this)
        except: self.this = this
    def get(self, *args) -> "double const &" :
        """get(_Nvector3 self, unsigned int const n) -> double const &"""
        return _sim2dlong._Nvector3_get(self, *args)

    def set(self, *args) -> "void" :
        """set(_Nvector3 self, unsigned int const n, double const a)"""
        return _sim2dlong._Nvector3_set(self, *args)

    def len(self) -> "unsigned int" :
        """len(_Nvector3 self) -> unsigned int"""
        return _sim2dlong._Nvector3_len(self)

    def __iadd__(self, *args) -> "Nvector< double,3 > &" :
        """__iadd__(_Nvector3 self, _Nvector3 rhs) -> _Nvector3"""
        return _sim2dlong._Nvector3___iadd__(self, *args)

    def __isub__(self, *args) -> "Nvector< double,3 > &" :
        """__isub__(_Nvector3 self, _Nvector3 rhs) -> _Nvector3"""
        return _sim2dlong._Nvector3___isub__(self, *args)

    def __neg__(self) -> "Nvector< double,3 >" :
        """__neg__(_Nvector3 self) -> _Nvector3"""
        return _sim2dlong._Nvector3___neg__(self)

    def __add__(self, *args) -> "Nvector< double,3 >" :
        """__add__(_Nvector3 self, _Nvector3 rhs) -> _Nvector3"""
        return _sim2dlong._Nvector3___add__(self, *args)

    def __sub__(self, *args) -> "Nvector< double,3 >" :
        """__sub__(_Nvector3 self, _Nvector3 rhs) -> _Nvector3"""
        return _sim2dlong._Nvector3___sub__(self, *args)

    def begin(self) -> "double *" :
        """begin(_Nvector3 self) -> double *"""
        return _sim2dlong._Nvector3_begin(self)

    def end(self) -> "double *" :
        """end(_Nvector3 self) -> double *"""
        return _sim2dlong._Nvector3_end(self)

    __swig_destroy__ = _sim2dlong.delete__Nvector3
    __del__ = lambda self : None;
    def __mul__(self, *args) -> "Nvector< double,3 >" :
        """__mul__(_Nvector3 self, double const rhs) -> _Nvector3"""
        return _sim2dlong._Nvector3___mul__(self, *args)

    def __div__(self, *args) -> "Nvector< double,3 >" :
        """__div__(_Nvector3 self, double const rhs) -> _Nvector3"""
        return _sim2dlong._Nvector3___div__(self, *args)

    def __truediv__(self, *args) -> "Nvector< double,3 >" :
        """__truediv__(_Nvector3 self, double const n) -> _Nvector3"""
        return _sim2dlong._Nvector3___truediv__(self, *args)

    def __getitem__(self, *args) -> "double" :
        """__getitem__(_Nvector3 self, unsigned int const n) -> double"""
        return _sim2dlong._Nvector3___getitem__(self, *args)

    def __setitem__(self, *args) -> "void" :
        """__setitem__(_Nvector3 self, unsigned int const n, double const val)"""
        return _sim2dlong._Nvector3___setitem__(self, *args)

    def __len__(self) -> "unsigned int" :
        """__len__(_Nvector3 self) -> unsigned int"""
        return _sim2dlong._Nvector3___len__(self)

    #~ def __setitem__(self, n, val):
        #~ return self.set(n, val)

    def __iter__(self):
        for i in range(len(self)):
            yield self.get(i)

    #~ def __len__(self):
        #~ return self.len()

_Nvector3_swigregister = _sim2dlong._Nvector3_swigregister
_Nvector3_swigregister(_Nvector3)

class _Nvector2(_object):
    """Proxy of C++ Nvector<(double,2)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _Nvector2, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _Nvector2, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(Nvector<(double,2)> self) -> _Nvector2
        __init__(Nvector<(double,2)> self, _Nvector2 rhs) -> _Nvector2
        __init__(Nvector<(double,2)> self, double const [2] locs) -> _Nvector2
        """
        this = _sim2dlong.new__Nvector2(*args)
        try: self.this.append(this)
        except: self.this = this
    def get(self, *args) -> "double const &" :
        """get(_Nvector2 self, unsigned int const n) -> double const &"""
        return _sim2dlong._Nvector2_get(self, *args)

    def set(self, *args) -> "void" :
        """set(_Nvector2 self, unsigned int const n, double const a)"""
        return _sim2dlong._Nvector2_set(self, *args)

    def len(self) -> "unsigned int" :
        """len(_Nvector2 self) -> unsigned int"""
        return _sim2dlong._Nvector2_len(self)

    def __iadd__(self, *args) -> "Nvector< double,2 > &" :
        """__iadd__(_Nvector2 self, _Nvector2 rhs) -> _Nvector2"""
        return _sim2dlong._Nvector2___iadd__(self, *args)

    def __isub__(self, *args) -> "Nvector< double,2 > &" :
        """__isub__(_Nvector2 self, _Nvector2 rhs) -> _Nvector2"""
        return _sim2dlong._Nvector2___isub__(self, *args)

    def __neg__(self) -> "Nvector< double,2 >" :
        """__neg__(_Nvector2 self) -> _Nvector2"""
        return _sim2dlong._Nvector2___neg__(self)

    def __add__(self, *args) -> "Nvector< double,2 >" :
        """__add__(_Nvector2 self, _Nvector2 rhs) -> _Nvector2"""
        return _sim2dlong._Nvector2___add__(self, *args)

    def __sub__(self, *args) -> "Nvector< double,2 >" :
        """__sub__(_Nvector2 self, _Nvector2 rhs) -> _Nvector2"""
        return _sim2dlong._Nvector2___sub__(self, *args)

    def begin(self) -> "double *" :
        """begin(_Nvector2 self) -> double *"""
        return _sim2dlong._Nvector2_begin(self)

    def end(self) -> "double *" :
        """end(_Nvector2 self) -> double *"""
        return _sim2dlong._Nvector2_end(self)

    __swig_destroy__ = _sim2dlong.delete__Nvector2
    __del__ = lambda self : None;
    def __mul__(self, *args) -> "Nvector< double,2 >" :
        """__mul__(_Nvector2 self, double const rhs) -> _Nvector2"""
        return _sim2dlong._Nvector2___mul__(self, *args)

    def __div__(self, *args) -> "Nvector< double,2 >" :
        """__div__(_Nvector2 self, double const rhs) -> _Nvector2"""
        return _sim2dlong._Nvector2___div__(self, *args)

    def __truediv__(self, *args) -> "Nvector< double,2 >" :
        """__truediv__(_Nvector2 self, double const n) -> _Nvector2"""
        return _sim2dlong._Nvector2___truediv__(self, *args)

    def __getitem__(self, *args) -> "double" :
        """__getitem__(_Nvector2 self, unsigned int const n) -> double"""
        return _sim2dlong._Nvector2___getitem__(self, *args)

    def __setitem__(self, *args) -> "void" :
        """__setitem__(_Nvector2 self, unsigned int const n, double const val)"""
        return _sim2dlong._Nvector2___setitem__(self, *args)

    def __len__(self) -> "unsigned int" :
        """__len__(_Nvector2 self) -> unsigned int"""
        return _sim2dlong._Nvector2___len__(self)

    #~ def __setitem__(self, n, val):
        #~ return self.set(n, val)

    def __iter__(self):
        for i in range(len(self)):
            yield self.get(i)

    #~ def __len__(self):
        #~ return self.len()

_Nvector2_swigregister = _sim2dlong._Nvector2_swigregister
_Nvector2_swigregister(_Nvector2)

class _Numvector3(_Nvector3):
    """Proxy of C++ Numvector<(double,3)> class"""
    __swig_setmethods__ = {}
    for _s in [_Nvector3]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, _Numvector3, name, value)
    __swig_getmethods__ = {}
    for _s in [_Nvector3]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, _Numvector3, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(Numvector<(double,3)> self) -> _Numvector3
        __init__(Numvector<(double,3)> self, _Nvector3 rhs) -> _Numvector3
        __init__(Numvector<(double,3)> self, double const [3] rhs) -> _Numvector3
        """
        this = _sim2dlong.new__Numvector3(*args)
        try: self.this.append(this)
        except: self.this = this
    def dot(self, *args) -> "double" :
        """dot(_Numvector3 self, _Numvector3 other) -> double"""
        return _sim2dlong._Numvector3_dot(self, *args)

    def sq(self) -> "double" :
        """sq(_Numvector3 self) -> double"""
        return _sim2dlong._Numvector3_sq(self)

    def mag(self) -> "double" :
        """mag(_Numvector3 self) -> double"""
        return _sim2dlong._Numvector3_mag(self)

    def distance(self, *args) -> "double" :
        """distance(_Numvector3 self, _Numvector3 rhs) -> double"""
        return _sim2dlong._Numvector3_distance(self, *args)

    def perpto(self, *args) -> "Numvector< double,3 >" :
        """perpto(_Numvector3 self, _Numvector3 other) -> _Numvector3"""
        return _sim2dlong._Numvector3_perpto(self, *args)

    def normalize(self) -> "void" :
        """normalize(_Numvector3 self)"""
        return _sim2dlong._Numvector3_normalize(self)

    def norm(self) -> "Numvector< double,3 >" :
        """norm(_Numvector3 self) -> _Numvector3"""
        return _sim2dlong._Numvector3_norm(self)

    __swig_destroy__ = _sim2dlong.delete__Numvector3
    __del__ = lambda self : None;
_Numvector3_swigregister = _sim2dlong._Numvector3_swigregister
_Numvector3_swigregister(_Numvector3)

class _Numvector2(_Nvector2):
    """Proxy of C++ Numvector<(double,2)> class"""
    __swig_setmethods__ = {}
    for _s in [_Nvector2]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, _Numvector2, name, value)
    __swig_getmethods__ = {}
    for _s in [_Nvector2]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, _Numvector2, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(Numvector<(double,2)> self) -> _Numvector2
        __init__(Numvector<(double,2)> self, _Nvector2 rhs) -> _Numvector2
        __init__(Numvector<(double,2)> self, double const [2] rhs) -> _Numvector2
        """
        this = _sim2dlong.new__Numvector2(*args)
        try: self.this.append(this)
        except: self.this = this
    def dot(self, *args) -> "double" :
        """dot(_Numvector2 self, _Numvector2 other) -> double"""
        return _sim2dlong._Numvector2_dot(self, *args)

    def sq(self) -> "double" :
        """sq(_Numvector2 self) -> double"""
        return _sim2dlong._Numvector2_sq(self)

    def mag(self) -> "double" :
        """mag(_Numvector2 self) -> double"""
        return _sim2dlong._Numvector2_mag(self)

    def distance(self, *args) -> "double" :
        """distance(_Numvector2 self, _Numvector2 rhs) -> double"""
        return _sim2dlong._Numvector2_distance(self, *args)

    def perpto(self, *args) -> "Numvector< double,2 >" :
        """perpto(_Numvector2 self, _Numvector2 other) -> _Numvector2"""
        return _sim2dlong._Numvector2_perpto(self, *args)

    def normalize(self) -> "void" :
        """normalize(_Numvector2 self)"""
        return _sim2dlong._Numvector2_normalize(self)

    def norm(self) -> "Numvector< double,2 >" :
        """norm(_Numvector2 self) -> _Numvector2"""
        return _sim2dlong._Numvector2_norm(self)

    __swig_destroy__ = _sim2dlong.delete__Numvector2
    __del__ = lambda self : None;
_Numvector2_swigregister = _sim2dlong._Numvector2_swigregister
_Numvector2_swigregister(_Numvector2)

class _Nvector3L(_object):
    """Proxy of C++ Nvector<(long double,3)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _Nvector3L, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _Nvector3L, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(Nvector<(long double,3)> self) -> _Nvector3L
        __init__(Nvector<(long double,3)> self, _Nvector3L rhs) -> _Nvector3L
        __init__(Nvector<(long double,3)> self, long double const [3] locs) -> _Nvector3L
        """
        this = _sim2dlong.new__Nvector3L(*args)
        try: self.this.append(this)
        except: self.this = this
    def get(self, *args) -> "long double const &" :
        """get(_Nvector3L self, unsigned int const n) -> long double const &"""
        return _sim2dlong._Nvector3L_get(self, *args)

    def set(self, *args) -> "void" :
        """set(_Nvector3L self, unsigned int const n, long double const a)"""
        return _sim2dlong._Nvector3L_set(self, *args)

    def len(self) -> "unsigned int" :
        """len(_Nvector3L self) -> unsigned int"""
        return _sim2dlong._Nvector3L_len(self)

    def __iadd__(self, *args) -> "Nvector< long double,3 > &" :
        """__iadd__(_Nvector3L self, _Nvector3L rhs) -> _Nvector3L"""
        return _sim2dlong._Nvector3L___iadd__(self, *args)

    def __isub__(self, *args) -> "Nvector< long double,3 > &" :
        """__isub__(_Nvector3L self, _Nvector3L rhs) -> _Nvector3L"""
        return _sim2dlong._Nvector3L___isub__(self, *args)

    def __neg__(self) -> "Nvector< long double,3 >" :
        """__neg__(_Nvector3L self) -> _Nvector3L"""
        return _sim2dlong._Nvector3L___neg__(self)

    def __add__(self, *args) -> "Nvector< long double,3 >" :
        """__add__(_Nvector3L self, _Nvector3L rhs) -> _Nvector3L"""
        return _sim2dlong._Nvector3L___add__(self, *args)

    def __sub__(self, *args) -> "Nvector< long double,3 >" :
        """__sub__(_Nvector3L self, _Nvector3L rhs) -> _Nvector3L"""
        return _sim2dlong._Nvector3L___sub__(self, *args)

    def begin(self) -> "long double *" :
        """begin(_Nvector3L self) -> long double *"""
        return _sim2dlong._Nvector3L_begin(self)

    def end(self) -> "long double *" :
        """end(_Nvector3L self) -> long double *"""
        return _sim2dlong._Nvector3L_end(self)

    __swig_destroy__ = _sim2dlong.delete__Nvector3L
    __del__ = lambda self : None;
    def __mul__(self, *args) -> "Nvector< long double,3 >" :
        """__mul__(_Nvector3L self, double const rhs) -> _Nvector3L"""
        return _sim2dlong._Nvector3L___mul__(self, *args)

    def __div__(self, *args) -> "Nvector< long double,3 >" :
        """__div__(_Nvector3L self, double const rhs) -> _Nvector3L"""
        return _sim2dlong._Nvector3L___div__(self, *args)

    def __truediv__(self, *args) -> "Nvector< long double,3 >" :
        """__truediv__(_Nvector3L self, double const n) -> _Nvector3L"""
        return _sim2dlong._Nvector3L___truediv__(self, *args)

    def __getitem__(self, *args) -> "long double" :
        """__getitem__(_Nvector3L self, unsigned int const n) -> long double"""
        return _sim2dlong._Nvector3L___getitem__(self, *args)

    def __setitem__(self, *args) -> "void" :
        """__setitem__(_Nvector3L self, unsigned int const n, long double const val)"""
        return _sim2dlong._Nvector3L___setitem__(self, *args)

    def __len__(self) -> "unsigned int" :
        """__len__(_Nvector3L self) -> unsigned int"""
        return _sim2dlong._Nvector3L___len__(self)

    #~ def __setitem__(self, n, val):
        #~ return self.set(n, val)

    def __iter__(self):
        for i in range(len(self)):
            yield self.get(i)

    #~ def __len__(self):
        #~ return self.len()

_Nvector3L_swigregister = _sim2dlong._Nvector3L_swigregister
_Nvector3L_swigregister(_Nvector3L)

class _Nvector2L(_object):
    """Proxy of C++ Nvector<(long double,2)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _Nvector2L, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _Nvector2L, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(Nvector<(long double,2)> self) -> _Nvector2L
        __init__(Nvector<(long double,2)> self, _Nvector2L rhs) -> _Nvector2L
        __init__(Nvector<(long double,2)> self, long double const [2] locs) -> _Nvector2L
        """
        this = _sim2dlong.new__Nvector2L(*args)
        try: self.this.append(this)
        except: self.this = this
    def get(self, *args) -> "long double const &" :
        """get(_Nvector2L self, unsigned int const n) -> long double const &"""
        return _sim2dlong._Nvector2L_get(self, *args)

    def set(self, *args) -> "void" :
        """set(_Nvector2L self, unsigned int const n, long double const a)"""
        return _sim2dlong._Nvector2L_set(self, *args)

    def len(self) -> "unsigned int" :
        """len(_Nvector2L self) -> unsigned int"""
        return _sim2dlong._Nvector2L_len(self)

    def __iadd__(self, *args) -> "Nvector< long double,2 > &" :
        """__iadd__(_Nvector2L self, _Nvector2L rhs) -> _Nvector2L"""
        return _sim2dlong._Nvector2L___iadd__(self, *args)

    def __isub__(self, *args) -> "Nvector< long double,2 > &" :
        """__isub__(_Nvector2L self, _Nvector2L rhs) -> _Nvector2L"""
        return _sim2dlong._Nvector2L___isub__(self, *args)

    def __neg__(self) -> "Nvector< long double,2 >" :
        """__neg__(_Nvector2L self) -> _Nvector2L"""
        return _sim2dlong._Nvector2L___neg__(self)

    def __add__(self, *args) -> "Nvector< long double,2 >" :
        """__add__(_Nvector2L self, _Nvector2L rhs) -> _Nvector2L"""
        return _sim2dlong._Nvector2L___add__(self, *args)

    def __sub__(self, *args) -> "Nvector< long double,2 >" :
        """__sub__(_Nvector2L self, _Nvector2L rhs) -> _Nvector2L"""
        return _sim2dlong._Nvector2L___sub__(self, *args)

    def begin(self) -> "long double *" :
        """begin(_Nvector2L self) -> long double *"""
        return _sim2dlong._Nvector2L_begin(self)

    def end(self) -> "long double *" :
        """end(_Nvector2L self) -> long double *"""
        return _sim2dlong._Nvector2L_end(self)

    __swig_destroy__ = _sim2dlong.delete__Nvector2L
    __del__ = lambda self : None;
    def __mul__(self, *args) -> "Nvector< long double,2 >" :
        """__mul__(_Nvector2L self, double const rhs) -> _Nvector2L"""
        return _sim2dlong._Nvector2L___mul__(self, *args)

    def __div__(self, *args) -> "Nvector< long double,2 >" :
        """__div__(_Nvector2L self, double const rhs) -> _Nvector2L"""
        return _sim2dlong._Nvector2L___div__(self, *args)

    def __truediv__(self, *args) -> "Nvector< long double,2 >" :
        """__truediv__(_Nvector2L self, double const n) -> _Nvector2L"""
        return _sim2dlong._Nvector2L___truediv__(self, *args)

    def __getitem__(self, *args) -> "long double" :
        """__getitem__(_Nvector2L self, unsigned int const n) -> long double"""
        return _sim2dlong._Nvector2L___getitem__(self, *args)

    def __setitem__(self, *args) -> "void" :
        """__setitem__(_Nvector2L self, unsigned int const n, long double const val)"""
        return _sim2dlong._Nvector2L___setitem__(self, *args)

    def __len__(self) -> "unsigned int" :
        """__len__(_Nvector2L self) -> unsigned int"""
        return _sim2dlong._Nvector2L___len__(self)

    #~ def __setitem__(self, n, val):
        #~ return self.set(n, val)

    def __iter__(self):
        for i in range(len(self)):
            yield self.get(i)

    #~ def __len__(self):
        #~ return self.len()

_Nvector2L_swigregister = _sim2dlong._Nvector2L_swigregister
_Nvector2L_swigregister(_Nvector2L)

class _Numvector3L(_Nvector3L):
    """Proxy of C++ Numvector<(long double,3)> class"""
    __swig_setmethods__ = {}
    for _s in [_Nvector3L]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, _Numvector3L, name, value)
    __swig_getmethods__ = {}
    for _s in [_Nvector3L]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, _Numvector3L, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(Numvector<(long double,3)> self) -> _Numvector3L
        __init__(Numvector<(long double,3)> self, _Nvector3L rhs) -> _Numvector3L
        __init__(Numvector<(long double,3)> self, long double const [3] rhs) -> _Numvector3L
        """
        this = _sim2dlong.new__Numvector3L(*args)
        try: self.this.append(this)
        except: self.this = this
    def dot(self, *args) -> "long double" :
        """dot(_Numvector3L self, _Numvector3L other) -> long double"""
        return _sim2dlong._Numvector3L_dot(self, *args)

    def sq(self) -> "long double" :
        """sq(_Numvector3L self) -> long double"""
        return _sim2dlong._Numvector3L_sq(self)

    def mag(self) -> "long double" :
        """mag(_Numvector3L self) -> long double"""
        return _sim2dlong._Numvector3L_mag(self)

    def distance(self, *args) -> "long double" :
        """distance(_Numvector3L self, _Numvector3L rhs) -> long double"""
        return _sim2dlong._Numvector3L_distance(self, *args)

    def perpto(self, *args) -> "Numvector< long double,3 >" :
        """perpto(_Numvector3L self, _Numvector3L other) -> _Numvector3L"""
        return _sim2dlong._Numvector3L_perpto(self, *args)

    def normalize(self) -> "void" :
        """normalize(_Numvector3L self)"""
        return _sim2dlong._Numvector3L_normalize(self)

    def norm(self) -> "Numvector< long double,3 >" :
        """norm(_Numvector3L self) -> _Numvector3L"""
        return _sim2dlong._Numvector3L_norm(self)

    __swig_destroy__ = _sim2dlong.delete__Numvector3L
    __del__ = lambda self : None;
_Numvector3L_swigregister = _sim2dlong._Numvector3L_swigregister
_Numvector3L_swigregister(_Numvector3L)

class _Numvector2L(_Nvector2L):
    """Proxy of C++ Numvector<(long double,2)> class"""
    __swig_setmethods__ = {}
    for _s in [_Nvector2L]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, _Numvector2L, name, value)
    __swig_getmethods__ = {}
    for _s in [_Nvector2L]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, _Numvector2L, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(Numvector<(long double,2)> self) -> _Numvector2L
        __init__(Numvector<(long double,2)> self, _Nvector2L rhs) -> _Numvector2L
        __init__(Numvector<(long double,2)> self, long double const [2] rhs) -> _Numvector2L
        """
        this = _sim2dlong.new__Numvector2L(*args)
        try: self.this.append(this)
        except: self.this = this
    def dot(self, *args) -> "long double" :
        """dot(_Numvector2L self, _Numvector2L other) -> long double"""
        return _sim2dlong._Numvector2L_dot(self, *args)

    def sq(self) -> "long double" :
        """sq(_Numvector2L self) -> long double"""
        return _sim2dlong._Numvector2L_sq(self)

    def mag(self) -> "long double" :
        """mag(_Numvector2L self) -> long double"""
        return _sim2dlong._Numvector2L_mag(self)

    def distance(self, *args) -> "long double" :
        """distance(_Numvector2L self, _Numvector2L rhs) -> long double"""
        return _sim2dlong._Numvector2L_distance(self, *args)

    def perpto(self, *args) -> "Numvector< long double,2 >" :
        """perpto(_Numvector2L self, _Numvector2L other) -> _Numvector2L"""
        return _sim2dlong._Numvector2L_perpto(self, *args)

    def normalize(self) -> "void" :
        """normalize(_Numvector2L self)"""
        return _sim2dlong._Numvector2L_normalize(self)

    def norm(self) -> "Numvector< long double,2 >" :
        """norm(_Numvector2L self) -> _Numvector2L"""
        return _sim2dlong._Numvector2L_norm(self)

    __swig_destroy__ = _sim2dlong.delete__Numvector2L
    __del__ = lambda self : None;
_Numvector2L_swigregister = _sim2dlong._Numvector2L_swigregister
_Numvector2L_swigregister(_Numvector2L)

class Vec(_Numvector2):
    """Proxy of C++ Vector2<(double)> class"""
    __swig_setmethods__ = {}
    for _s in [_Numvector2]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Vec, name, value)
    __swig_getmethods__ = {}
    for _s in [_Numvector2]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Vec, name)
    def __init__(self, *args): 
        """
        __init__(Vector2<(double)> self) -> Vec
        __init__(Vector2<(double)> self, double const a, double const b) -> Vec
        __init__(Vector2<(double)> self, _Numvector2 rhs) -> Vec
        __init__(Vector2<(double)> self, _Nvector2 rhs) -> Vec
        """
        this = _sim2dlong.new_Vec(*args)
        try: self.this.append(this)
        except: self.this = this
    def getx(self) -> "double const" :
        """getx(Vec self) -> double const"""
        return _sim2dlong.Vec_getx(self)

    def gety(self) -> "double const" :
        """gety(Vec self) -> double const"""
        return _sim2dlong.Vec_gety(self)

    def getxd(self) -> "double" :
        """getxd(Vec self) -> double"""
        return _sim2dlong.Vec_getxd(self)

    def getyd(self) -> "double" :
        """getyd(Vec self) -> double"""
        return _sim2dlong.Vec_getyd(self)

    def setx(self, *args) -> "void" :
        """setx(Vec self, double const a)"""
        return _sim2dlong.Vec_setx(self, *args)

    def sety(self, *args) -> "void" :
        """sety(Vec self, double const b)"""
        return _sim2dlong.Vec_sety(self, *args)

    def setxd(self, *args) -> "void" :
        """setxd(Vec self, double const a)"""
        return _sim2dlong.Vec_setxd(self, *args)

    def setyd(self, *args) -> "void" :
        """setyd(Vec self, double const b)"""
        return _sim2dlong.Vec_setyd(self, *args)

    def set(self, *args) -> "void" :
        """set(Vec self, double const a, double const b)"""
        return _sim2dlong.Vec_set(self, *args)

    def __neg__(self) -> "Vector2< double >" :
        """__neg__(Vec self) -> Vec"""
        return _sim2dlong.Vec___neg__(self)

    def __add__(self, *args) -> "Vector2< double >" :
        """__add__(Vec self, Vec rhs) -> Vec"""
        return _sim2dlong.Vec___add__(self, *args)

    def __sub__(self, *args) -> "Vector2< double >" :
        """__sub__(Vec self, Vec rhs) -> Vec"""
        return _sim2dlong.Vec___sub__(self, *args)

    def cross(self, *args) -> "double" :
        """cross(Vec self, Vec rhs) -> double"""
        return _sim2dlong.Vec_cross(self, *args)

    def perp(self) -> "Vector2< double >" :
        """perp(Vec self) -> Vec"""
        return _sim2dlong.Vec_perp(self)

    def norm(self) -> "Vector2< double >" :
        """norm(Vec self) -> Vec"""
        return _sim2dlong.Vec_norm(self)

    def __isub__(self, *args) -> "Vector2< double > &" :
        """__isub__(Vec self, Vec rhs) -> Vec"""
        return _sim2dlong.Vec___isub__(self, *args)

    def __iadd__(self, *args) -> "Vector2< double > &" :
        """__iadd__(Vec self, Vec rhs) -> Vec"""
        return _sim2dlong.Vec___iadd__(self, *args)

    def rotate(self, *args) -> "Vector2< double >" :
        """rotate(Vec self, uint i) -> Vec"""
        return _sim2dlong.Vec_rotate(self, *args)

    def flip(self) -> "Vector2< double >" :
        """flip(Vec self) -> Vec"""
        return _sim2dlong.Vec_flip(self)

    def rotate_flip(self, *args) -> "Vector2< double >" :
        """rotate_flip(Vec self, uint i) -> Vec"""
        return _sim2dlong.Vec_rotate_flip(self, *args)

    def rotate_flip_inv(self, *args) -> "Vector2< double >" :
        """rotate_flip_inv(Vec self, uint i) -> Vec"""
        return _sim2dlong.Vec_rotate_flip_inv(self, *args)

    def angle(*args) -> "double" :
        """
        angle(Vec dx1, Vec dx2) -> double
        angle(Vec x1, Vec x2, Vec x3) -> double
        """
        return _sim2dlong.Vec_angle(*args)

    if _newclass:angle = staticmethod(angle)
    __swig_getmethods__["angle"] = lambda x: angle
    __swig_destroy__ = _sim2dlong.delete_Vec
    __del__ = lambda self : None;
    def __str__(self) -> "char *" :
        """__str__(Vec self) -> char *"""
        return _sim2dlong.Vec___str__(self)

    def __repr__(self) -> "char *" :
        """__repr__(Vec self) -> char *"""
        return _sim2dlong.Vec___repr__(self)

    def __truediv__(self, *args) -> "Vector2< double >" :
        """__truediv__(Vec self, double const n) -> Vec"""
        return _sim2dlong.Vec___truediv__(self, *args)

    def __mul__(self, *args) -> "Vector2< double >" :
        """
        __mul__(Vec self, Vec rhs) -> double
        __mul__(Vec self, double const n) -> Vec
        """
        return _sim2dlong.Vec___mul__(self, *args)

    @property
    def X(self):
        return self.getxd()

    @property
    def Y(self):
        return self.getyd()

Vec_swigregister = _sim2dlong.Vec_swigregister
Vec_swigregister(Vec)

def Vec_angle(*args) -> "double" :
  """
    angle(Vec dx1, Vec dx2) -> double
    Vec_angle(Vec x1, Vec x2, Vec x3) -> double
    """
  return _sim2dlong.Vec_angle(*args)

class VecL(_Numvector2L):
    """Proxy of C++ Vector2<(long double)> class"""
    __swig_setmethods__ = {}
    for _s in [_Numvector2L]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, VecL, name, value)
    __swig_getmethods__ = {}
    for _s in [_Numvector2L]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, VecL, name)
    def __init__(self, *args): 
        """
        __init__(Vector2<(long double)> self) -> VecL
        __init__(Vector2<(long double)> self, long double const a, long double const b) -> VecL
        __init__(Vector2<(long double)> self, _Numvector2L rhs) -> VecL
        __init__(Vector2<(long double)> self, _Nvector2L rhs) -> VecL
        """
        this = _sim2dlong.new_VecL(*args)
        try: self.this.append(this)
        except: self.this = this
    def getx(self) -> "long double const" :
        """getx(VecL self) -> long double const"""
        return _sim2dlong.VecL_getx(self)

    def gety(self) -> "long double const" :
        """gety(VecL self) -> long double const"""
        return _sim2dlong.VecL_gety(self)

    def getxd(self) -> "double" :
        """getxd(VecL self) -> double"""
        return _sim2dlong.VecL_getxd(self)

    def getyd(self) -> "double" :
        """getyd(VecL self) -> double"""
        return _sim2dlong.VecL_getyd(self)

    def setx(self, *args) -> "void" :
        """setx(VecL self, long double const a)"""
        return _sim2dlong.VecL_setx(self, *args)

    def sety(self, *args) -> "void" :
        """sety(VecL self, long double const b)"""
        return _sim2dlong.VecL_sety(self, *args)

    def setxd(self, *args) -> "void" :
        """setxd(VecL self, double const a)"""
        return _sim2dlong.VecL_setxd(self, *args)

    def setyd(self, *args) -> "void" :
        """setyd(VecL self, double const b)"""
        return _sim2dlong.VecL_setyd(self, *args)

    def set(self, *args) -> "void" :
        """set(VecL self, long double const a, long double const b)"""
        return _sim2dlong.VecL_set(self, *args)

    def __neg__(self) -> "Vector2< long double >" :
        """__neg__(VecL self) -> VecL"""
        return _sim2dlong.VecL___neg__(self)

    def __add__(self, *args) -> "Vector2< long double >" :
        """__add__(VecL self, VecL rhs) -> VecL"""
        return _sim2dlong.VecL___add__(self, *args)

    def __sub__(self, *args) -> "Vector2< long double >" :
        """__sub__(VecL self, VecL rhs) -> VecL"""
        return _sim2dlong.VecL___sub__(self, *args)

    def cross(self, *args) -> "long double" :
        """cross(VecL self, VecL rhs) -> long double"""
        return _sim2dlong.VecL_cross(self, *args)

    def perp(self) -> "Vector2< long double >" :
        """perp(VecL self) -> VecL"""
        return _sim2dlong.VecL_perp(self)

    def norm(self) -> "Vector2< long double >" :
        """norm(VecL self) -> VecL"""
        return _sim2dlong.VecL_norm(self)

    def __isub__(self, *args) -> "Vector2< long double > &" :
        """__isub__(VecL self, VecL rhs) -> VecL"""
        return _sim2dlong.VecL___isub__(self, *args)

    def __iadd__(self, *args) -> "Vector2< long double > &" :
        """__iadd__(VecL self, VecL rhs) -> VecL"""
        return _sim2dlong.VecL___iadd__(self, *args)

    def rotate(self, *args) -> "Vector2< long double >" :
        """rotate(VecL self, uint i) -> VecL"""
        return _sim2dlong.VecL_rotate(self, *args)

    def flip(self) -> "Vector2< long double >" :
        """flip(VecL self) -> VecL"""
        return _sim2dlong.VecL_flip(self)

    def rotate_flip(self, *args) -> "Vector2< long double >" :
        """rotate_flip(VecL self, uint i) -> VecL"""
        return _sim2dlong.VecL_rotate_flip(self, *args)

    def rotate_flip_inv(self, *args) -> "Vector2< long double >" :
        """rotate_flip_inv(VecL self, uint i) -> VecL"""
        return _sim2dlong.VecL_rotate_flip_inv(self, *args)

    def angle(*args) -> "long double" :
        """
        angle(VecL dx1, VecL dx2) -> long double
        angle(VecL x1, VecL x2, VecL x3) -> long double
        """
        return _sim2dlong.VecL_angle(*args)

    if _newclass:angle = staticmethod(angle)
    __swig_getmethods__["angle"] = lambda x: angle
    __swig_destroy__ = _sim2dlong.delete_VecL
    __del__ = lambda self : None;
    def __str__(self) -> "char *" :
        """__str__(VecL self) -> char *"""
        return _sim2dlong.VecL___str__(self)

    def __repr__(self) -> "char *" :
        """__repr__(VecL self) -> char *"""
        return _sim2dlong.VecL___repr__(self)

    def __truediv__(self, *args) -> "Vector2< long double >" :
        """__truediv__(VecL self, double const n) -> VecL"""
        return _sim2dlong.VecL___truediv__(self, *args)

    def __mul__(self, *args) -> "Vector2< long double >" :
        """
        __mul__(VecL self, VecL rhs) -> long double
        __mul__(VecL self, double const n) -> VecL
        """
        return _sim2dlong.VecL___mul__(self, *args)

    @property
    def X(self):
        return self.getxd()

    @property
    def Y(self):
        return self.getyd()

VecL_swigregister = _sim2dlong.VecL_swigregister
VecL_swigregister(VecL)

def VecL_angle(*args) -> "long double" :
  """
    angle(VecL dx1, VecL dx2) -> long double
    VecL_angle(VecL x1, VecL x2, VecL x3) -> long double
    """
  return _sim2dlong.VecL_angle(*args)

class vecptrvector(_object):
    """Proxy of C++ std::vector<(p.Vector2<(double)>)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vecptrvector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vecptrvector, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" :
        """iterator(vecptrvector self) -> SwigPyIterator"""
        return _sim2dlong.vecptrvector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" :
        """__nonzero__(vecptrvector self) -> bool"""
        return _sim2dlong.vecptrvector___nonzero__(self)

    def __bool__(self) -> "bool" :
        """__bool__(vecptrvector self) -> bool"""
        return _sim2dlong.vecptrvector___bool__(self)

    def __len__(self) -> "std::vector< Vector2< double > * >::size_type" :
        """__len__(vecptrvector self) -> std::vector< Vector2< double > * >::size_type"""
        return _sim2dlong.vecptrvector___len__(self)

    def pop(self) -> "std::vector< Vector2< double > * >::value_type" :
        """pop(vecptrvector self) -> Vec"""
        return _sim2dlong.vecptrvector_pop(self)

    def __getslice__(self, *args) -> "std::vector< Vector2< double > *,std::allocator< Vector2< double > * > > *" :
        """__getslice__(vecptrvector self, std::vector< Vector2< double > * >::difference_type i, std::vector< Vector2< double > * >::difference_type j) -> vecptrvector"""
        return _sim2dlong.vecptrvector___getslice__(self, *args)

    def __setslice__(self, *args) -> "void" :
        """
        __setslice__(vecptrvector self, std::vector< Vector2< double > * >::difference_type i, std::vector< Vector2< double > * >::difference_type j, 
            vecptrvector v=std::vector< Vector2< double > *,std::allocator< Vector2< double > * > >())
        __setslice__(vecptrvector self, std::vector< Vector2< double > * >::difference_type i, std::vector< Vector2< double > * >::difference_type j)
        """
        return _sim2dlong.vecptrvector___setslice__(self, *args)

    def __delslice__(self, *args) -> "void" :
        """__delslice__(vecptrvector self, std::vector< Vector2< double > * >::difference_type i, std::vector< Vector2< double > * >::difference_type j)"""
        return _sim2dlong.vecptrvector___delslice__(self, *args)

    def __delitem__(self, *args) -> "void" :
        """
        __delitem__(vecptrvector self, std::vector< Vector2< double > * >::difference_type i)
        __delitem__(vecptrvector self, PySliceObject * slice)
        """
        return _sim2dlong.vecptrvector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< Vector2< double > * >::value_type" :
        """
        __getitem__(vecptrvector self, PySliceObject * slice) -> vecptrvector
        __getitem__(vecptrvector self, std::vector< Vector2< double > * >::difference_type i) -> Vec
        """
        return _sim2dlong.vecptrvector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void" :
        """
        __setitem__(vecptrvector self, PySliceObject * slice, vecptrvector v)
        __setitem__(vecptrvector self, PySliceObject * slice)
        __setitem__(vecptrvector self, std::vector< Vector2< double > * >::difference_type i, Vec x)
        """
        return _sim2dlong.vecptrvector___setitem__(self, *args)

    def append(self, *args) -> "void" :
        """append(vecptrvector self, Vec x)"""
        return _sim2dlong.vecptrvector_append(self, *args)

    def empty(self) -> "bool" :
        """empty(vecptrvector self) -> bool"""
        return _sim2dlong.vecptrvector_empty(self)

    def size(self) -> "std::vector< Vector2< double > * >::size_type" :
        """size(vecptrvector self) -> std::vector< Vector2< double > * >::size_type"""
        return _sim2dlong.vecptrvector_size(self)

    def clear(self) -> "void" :
        """clear(vecptrvector self)"""
        return _sim2dlong.vecptrvector_clear(self)

    def swap(self, *args) -> "void" :
        """swap(vecptrvector self, vecptrvector v)"""
        return _sim2dlong.vecptrvector_swap(self, *args)

    def get_allocator(self) -> "std::vector< Vector2< double > * >::allocator_type" :
        """get_allocator(vecptrvector self) -> std::vector< Vector2< double > * >::allocator_type"""
        return _sim2dlong.vecptrvector_get_allocator(self)

    def begin(self) -> "std::vector< Vector2< double > * >::iterator" :
        """begin(vecptrvector self) -> std::vector< Vector2< double > * >::iterator"""
        return _sim2dlong.vecptrvector_begin(self)

    def end(self) -> "std::vector< Vector2< double > * >::iterator" :
        """end(vecptrvector self) -> std::vector< Vector2< double > * >::iterator"""
        return _sim2dlong.vecptrvector_end(self)

    def rbegin(self) -> "std::vector< Vector2< double > * >::reverse_iterator" :
        """rbegin(vecptrvector self) -> std::vector< Vector2< double > * >::reverse_iterator"""
        return _sim2dlong.vecptrvector_rbegin(self)

    def rend(self) -> "std::vector< Vector2< double > * >::reverse_iterator" :
        """rend(vecptrvector self) -> std::vector< Vector2< double > * >::reverse_iterator"""
        return _sim2dlong.vecptrvector_rend(self)

    def pop_back(self) -> "void" :
        """pop_back(vecptrvector self)"""
        return _sim2dlong.vecptrvector_pop_back(self)

    def erase(self, *args) -> "std::vector< Vector2< double > * >::iterator" :
        """
        erase(vecptrvector self, std::vector< Vector2< double > * >::iterator pos) -> std::vector< Vector2< double > * >::iterator
        erase(vecptrvector self, std::vector< Vector2< double > * >::iterator first, std::vector< Vector2< double > * >::iterator last) -> std::vector< Vector2< double > * >::iterator
        """
        return _sim2dlong.vecptrvector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(p.Vector2<(double)>)> self) -> vecptrvector
        __init__(std::vector<(p.Vector2<(double)>)> self, vecptrvector arg2) -> vecptrvector
        __init__(std::vector<(p.Vector2<(double)>)> self, std::vector< Vector2< double > * >::size_type size) -> vecptrvector
        __init__(std::vector<(p.Vector2<(double)>)> self, std::vector< Vector2< double > * >::size_type size, Vec value) -> vecptrvector
        """
        this = _sim2dlong.new_vecptrvector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" :
        """push_back(vecptrvector self, Vec x)"""
        return _sim2dlong.vecptrvector_push_back(self, *args)

    def front(self) -> "std::vector< Vector2< double > * >::value_type" :
        """front(vecptrvector self) -> Vec"""
        return _sim2dlong.vecptrvector_front(self)

    def back(self) -> "std::vector< Vector2< double > * >::value_type" :
        """back(vecptrvector self) -> Vec"""
        return _sim2dlong.vecptrvector_back(self)

    def assign(self, *args) -> "void" :
        """assign(vecptrvector self, std::vector< Vector2< double > * >::size_type n, Vec x)"""
        return _sim2dlong.vecptrvector_assign(self, *args)

    def resize(self, *args) -> "void" :
        """
        resize(vecptrvector self, std::vector< Vector2< double > * >::size_type new_size)
        resize(vecptrvector self, std::vector< Vector2< double > * >::size_type new_size, Vec x)
        """
        return _sim2dlong.vecptrvector_resize(self, *args)

    def insert(self, *args) -> "void" :
        """
        insert(vecptrvector self, std::vector< Vector2< double > * >::iterator pos, Vec x) -> std::vector< Vector2< double > * >::iterator
        insert(vecptrvector self, std::vector< Vector2< double > * >::iterator pos, std::vector< Vector2< double > * >::size_type n, 
            Vec x)
        """
        return _sim2dlong.vecptrvector_insert(self, *args)

    def reserve(self, *args) -> "void" :
        """reserve(vecptrvector self, std::vector< Vector2< double > * >::size_type n)"""
        return _sim2dlong.vecptrvector_reserve(self, *args)

    def capacity(self) -> "std::vector< Vector2< double > * >::size_type" :
        """capacity(vecptrvector self) -> std::vector< Vector2< double > * >::size_type"""
        return _sim2dlong.vecptrvector_capacity(self)

    __swig_destroy__ = _sim2dlong.delete_vecptrvector
    __del__ = lambda self : None;
vecptrvector_swigregister = _sim2dlong.vecptrvector_swigregister
vecptrvector_swigregister(vecptrvector)

class vecvector(collections.MutableSequence):
    """Proxy of C++ std::vector<(Vector2<(double)>)> class"""
    __swig_setmethods__ = {}
    for _s in [collections.MutableSequence]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, vecvector, name, value)
    __swig_getmethods__ = {}
    for _s in [collections.MutableSequence]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, vecvector, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" :
        """iterator(vecvector self) -> SwigPyIterator"""
        return _sim2dlong.vecvector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" :
        """__nonzero__(vecvector self) -> bool"""
        return _sim2dlong.vecvector___nonzero__(self)

    def __bool__(self) -> "bool" :
        """__bool__(vecvector self) -> bool"""
        return _sim2dlong.vecvector___bool__(self)

    def __len__(self) -> "std::vector< Vector2< double > >::size_type" :
        """__len__(vecvector self) -> std::vector< Vector2< double > >::size_type"""
        return _sim2dlong.vecvector___len__(self)

    def pop(self) -> "std::vector< Vector2< double > >::value_type" :
        """pop(vecvector self) -> Vec"""
        return _sim2dlong.vecvector_pop(self)

    def __getslice__(self, *args) -> "std::vector< Vector2< double >,std::allocator< Vector2< double > > > *" :
        """__getslice__(vecvector self, std::vector< Vector2< double > >::difference_type i, std::vector< Vector2< double > >::difference_type j) -> vecvector"""
        return _sim2dlong.vecvector___getslice__(self, *args)

    def __setslice__(self, *args) -> "void" :
        """
        __setslice__(vecvector self, std::vector< Vector2< double > >::difference_type i, std::vector< Vector2< double > >::difference_type j, 
            vecvector v=std::vector< Vector2< double >,std::allocator< Vector2< double > > >())
        __setslice__(vecvector self, std::vector< Vector2< double > >::difference_type i, std::vector< Vector2< double > >::difference_type j)
        """
        return _sim2dlong.vecvector___setslice__(self, *args)

    def __delslice__(self, *args) -> "void" :
        """__delslice__(vecvector self, std::vector< Vector2< double > >::difference_type i, std::vector< Vector2< double > >::difference_type j)"""
        return _sim2dlong.vecvector___delslice__(self, *args)

    def __delitem__(self, *args) -> "void" :
        """
        __delitem__(vecvector self, std::vector< Vector2< double > >::difference_type i)
        __delitem__(vecvector self, PySliceObject * slice)
        """
        return _sim2dlong.vecvector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< Vector2< double > >::value_type const &" :
        """
        __getitem__(vecvector self, PySliceObject * slice) -> vecvector
        __getitem__(vecvector self, std::vector< Vector2< double > >::difference_type i) -> Vec
        """
        return _sim2dlong.vecvector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void" :
        """
        __setitem__(vecvector self, PySliceObject * slice, vecvector v)
        __setitem__(vecvector self, PySliceObject * slice)
        __setitem__(vecvector self, std::vector< Vector2< double > >::difference_type i, Vec x)
        """
        return _sim2dlong.vecvector___setitem__(self, *args)

    def append(self, *args) -> "void" :
        """append(vecvector self, Vec x)"""
        return _sim2dlong.vecvector_append(self, *args)

    def empty(self) -> "bool" :
        """empty(vecvector self) -> bool"""
        return _sim2dlong.vecvector_empty(self)

    def size(self) -> "std::vector< Vector2< double > >::size_type" :
        """size(vecvector self) -> std::vector< Vector2< double > >::size_type"""
        return _sim2dlong.vecvector_size(self)

    def clear(self) -> "void" :
        """clear(vecvector self)"""
        return _sim2dlong.vecvector_clear(self)

    def swap(self, *args) -> "void" :
        """swap(vecvector self, vecvector v)"""
        return _sim2dlong.vecvector_swap(self, *args)

    def get_allocator(self) -> "std::vector< Vector2< double > >::allocator_type" :
        """get_allocator(vecvector self) -> std::vector< Vector2< double > >::allocator_type"""
        return _sim2dlong.vecvector_get_allocator(self)

    def begin(self) -> "std::vector< Vector2< double > >::iterator" :
        """begin(vecvector self) -> std::vector< Vector2< double > >::iterator"""
        return _sim2dlong.vecvector_begin(self)

    def end(self) -> "std::vector< Vector2< double > >::iterator" :
        """end(vecvector self) -> std::vector< Vector2< double > >::iterator"""
        return _sim2dlong.vecvector_end(self)

    def rbegin(self) -> "std::vector< Vector2< double > >::reverse_iterator" :
        """rbegin(vecvector self) -> std::vector< Vector2< double > >::reverse_iterator"""
        return _sim2dlong.vecvector_rbegin(self)

    def rend(self) -> "std::vector< Vector2< double > >::reverse_iterator" :
        """rend(vecvector self) -> std::vector< Vector2< double > >::reverse_iterator"""
        return _sim2dlong.vecvector_rend(self)

    def pop_back(self) -> "void" :
        """pop_back(vecvector self)"""
        return _sim2dlong.vecvector_pop_back(self)

    def erase(self, *args) -> "std::vector< Vector2< double > >::iterator" :
        """
        erase(vecvector self, std::vector< Vector2< double > >::iterator pos) -> std::vector< Vector2< double > >::iterator
        erase(vecvector self, std::vector< Vector2< double > >::iterator first, std::vector< Vector2< double > >::iterator last) -> std::vector< Vector2< double > >::iterator
        """
        return _sim2dlong.vecvector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(Vector2<(double)>)> self) -> vecvector
        __init__(std::vector<(Vector2<(double)>)> self, vecvector arg2) -> vecvector
        __init__(std::vector<(Vector2<(double)>)> self, std::vector< Vector2< double > >::size_type size) -> vecvector
        __init__(std::vector<(Vector2<(double)>)> self, std::vector< Vector2< double > >::size_type size, Vec value) -> vecvector
        """
        this = _sim2dlong.new_vecvector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" :
        """push_back(vecvector self, Vec x)"""
        return _sim2dlong.vecvector_push_back(self, *args)

    def front(self) -> "std::vector< Vector2< double > >::value_type const &" :
        """front(vecvector self) -> Vec"""
        return _sim2dlong.vecvector_front(self)

    def back(self) -> "std::vector< Vector2< double > >::value_type const &" :
        """back(vecvector self) -> Vec"""
        return _sim2dlong.vecvector_back(self)

    def assign(self, *args) -> "void" :
        """assign(vecvector self, std::vector< Vector2< double > >::size_type n, Vec x)"""
        return _sim2dlong.vecvector_assign(self, *args)

    def resize(self, *args) -> "void" :
        """
        resize(vecvector self, std::vector< Vector2< double > >::size_type new_size)
        resize(vecvector self, std::vector< Vector2< double > >::size_type new_size, Vec x)
        """
        return _sim2dlong.vecvector_resize(self, *args)

    def insert(self, *args) -> "void" :
        """
        insert(vecvector self, std::vector< Vector2< double > >::iterator pos, Vec x) -> std::vector< Vector2< double > >::iterator
        insert(vecvector self, std::vector< Vector2< double > >::iterator pos, std::vector< Vector2< double > >::size_type n, 
            Vec x)
        """
        return _sim2dlong.vecvector_insert(self, *args)

    def reserve(self, *args) -> "void" :
        """reserve(vecvector self, std::vector< Vector2< double > >::size_type n)"""
        return _sim2dlong.vecvector_reserve(self, *args)

    def capacity(self) -> "std::vector< Vector2< double > >::size_type" :
        """capacity(vecvector self) -> std::vector< Vector2< double > >::size_type"""
        return _sim2dlong.vecvector_capacity(self)

    __swig_destroy__ = _sim2dlong.delete_vecvector
    __del__ = lambda self : None;
vecvector_swigregister = _sim2dlong.vecvector_swigregister
vecvector_swigregister(vecvector)

class _jamminglist(collections.MutableSequence):
    """Proxy of C++ std::list<(jamminglist)> class"""
    __swig_setmethods__ = {}
    for _s in [collections.MutableSequence]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, _jamminglist, name, value)
    __swig_getmethods__ = {}
    for _s in [collections.MutableSequence]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, _jamminglist, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" :
        """iterator(_jamminglist self) -> SwigPyIterator"""
        return _sim2dlong._jamminglist_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" :
        """__nonzero__(_jamminglist self) -> bool"""
        return _sim2dlong._jamminglist___nonzero__(self)

    def __bool__(self) -> "bool" :
        """__bool__(_jamminglist self) -> bool"""
        return _sim2dlong._jamminglist___bool__(self)

    def __len__(self) -> "std::list< jamminglist >::size_type" :
        """__len__(_jamminglist self) -> std::list< jamminglist >::size_type"""
        return _sim2dlong._jamminglist___len__(self)

    def pop(self) -> "std::list< jamminglist >::value_type" :
        """pop(_jamminglist self) -> jamminglist"""
        return _sim2dlong._jamminglist_pop(self)

    def __getslice__(self, *args) -> "std::list< jamminglist,std::allocator< jamminglist > > *" :
        """__getslice__(_jamminglist self, std::list< jamminglist >::difference_type i, std::list< jamminglist >::difference_type j) -> _jamminglist"""
        return _sim2dlong._jamminglist___getslice__(self, *args)

    def __setslice__(self, *args) -> "void" :
        """
        __setslice__(_jamminglist self, std::list< jamminglist >::difference_type i, std::list< jamminglist >::difference_type j, 
            _jamminglist v=std::list< jamminglist,std::allocator< jamminglist > >())
        __setslice__(_jamminglist self, std::list< jamminglist >::difference_type i, std::list< jamminglist >::difference_type j)
        """
        return _sim2dlong._jamminglist___setslice__(self, *args)

    def __delslice__(self, *args) -> "void" :
        """__delslice__(_jamminglist self, std::list< jamminglist >::difference_type i, std::list< jamminglist >::difference_type j)"""
        return _sim2dlong._jamminglist___delslice__(self, *args)

    def __delitem__(self, *args) -> "void" :
        """
        __delitem__(_jamminglist self, std::list< jamminglist >::difference_type i)
        __delitem__(_jamminglist self, PySliceObject * slice)
        """
        return _sim2dlong._jamminglist___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::list< jamminglist >::value_type const &" :
        """
        __getitem__(_jamminglist self, PySliceObject * slice) -> _jamminglist
        __getitem__(_jamminglist self, std::list< jamminglist >::difference_type i) -> jamminglist
        """
        return _sim2dlong._jamminglist___getitem__(self, *args)

    def __setitem__(self, *args) -> "void" :
        """
        __setitem__(_jamminglist self, PySliceObject * slice, _jamminglist v)
        __setitem__(_jamminglist self, PySliceObject * slice)
        __setitem__(_jamminglist self, std::list< jamminglist >::difference_type i, jamminglist x)
        """
        return _sim2dlong._jamminglist___setitem__(self, *args)

    def append(self, *args) -> "void" :
        """append(_jamminglist self, jamminglist x)"""
        return _sim2dlong._jamminglist_append(self, *args)

    def empty(self) -> "bool" :
        """empty(_jamminglist self) -> bool"""
        return _sim2dlong._jamminglist_empty(self)

    def size(self) -> "std::list< jamminglist >::size_type" :
        """size(_jamminglist self) -> std::list< jamminglist >::size_type"""
        return _sim2dlong._jamminglist_size(self)

    def clear(self) -> "void" :
        """clear(_jamminglist self)"""
        return _sim2dlong._jamminglist_clear(self)

    def swap(self, *args) -> "void" :
        """swap(_jamminglist self, _jamminglist v)"""
        return _sim2dlong._jamminglist_swap(self, *args)

    def get_allocator(self) -> "std::list< jamminglist >::allocator_type" :
        """get_allocator(_jamminglist self) -> std::list< jamminglist >::allocator_type"""
        return _sim2dlong._jamminglist_get_allocator(self)

    def begin(self) -> "std::list< jamminglist >::iterator" :
        """begin(_jamminglist self) -> std::list< jamminglist >::iterator"""
        return _sim2dlong._jamminglist_begin(self)

    def end(self) -> "std::list< jamminglist >::iterator" :
        """end(_jamminglist self) -> std::list< jamminglist >::iterator"""
        return _sim2dlong._jamminglist_end(self)

    def rbegin(self) -> "std::list< jamminglist >::reverse_iterator" :
        """rbegin(_jamminglist self) -> std::list< jamminglist >::reverse_iterator"""
        return _sim2dlong._jamminglist_rbegin(self)

    def rend(self) -> "std::list< jamminglist >::reverse_iterator" :
        """rend(_jamminglist self) -> std::list< jamminglist >::reverse_iterator"""
        return _sim2dlong._jamminglist_rend(self)

    def pop_back(self) -> "void" :
        """pop_back(_jamminglist self)"""
        return _sim2dlong._jamminglist_pop_back(self)

    def erase(self, *args) -> "std::list< jamminglist >::iterator" :
        """
        erase(_jamminglist self, std::list< jamminglist >::iterator pos) -> std::list< jamminglist >::iterator
        erase(_jamminglist self, std::list< jamminglist >::iterator first, std::list< jamminglist >::iterator last) -> std::list< jamminglist >::iterator
        """
        return _sim2dlong._jamminglist_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::list<(jamminglist)> self) -> _jamminglist
        __init__(std::list<(jamminglist)> self, _jamminglist arg2) -> _jamminglist
        __init__(std::list<(jamminglist)> self, std::list< jamminglist >::size_type size) -> _jamminglist
        __init__(std::list<(jamminglist)> self, std::list< jamminglist >::size_type size, jamminglist value) -> _jamminglist
        """
        this = _sim2dlong.new__jamminglist(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" :
        """push_back(_jamminglist self, jamminglist x)"""
        return _sim2dlong._jamminglist_push_back(self, *args)

    def front(self) -> "std::list< jamminglist >::value_type const &" :
        """front(_jamminglist self) -> jamminglist"""
        return _sim2dlong._jamminglist_front(self)

    def back(self) -> "std::list< jamminglist >::value_type const &" :
        """back(_jamminglist self) -> jamminglist"""
        return _sim2dlong._jamminglist_back(self)

    def assign(self, *args) -> "void" :
        """assign(_jamminglist self, std::list< jamminglist >::size_type n, jamminglist x)"""
        return _sim2dlong._jamminglist_assign(self, *args)

    def resize(self, *args) -> "void" :
        """
        resize(_jamminglist self, std::list< jamminglist >::size_type new_size)
        resize(_jamminglist self, std::list< jamminglist >::size_type new_size, jamminglist x)
        """
        return _sim2dlong._jamminglist_resize(self, *args)

    def insert(self, *args) -> "void" :
        """
        insert(_jamminglist self, std::list< jamminglist >::iterator pos, jamminglist x) -> std::list< jamminglist >::iterator
        insert(_jamminglist self, std::list< jamminglist >::iterator pos, std::list< jamminglist >::size_type n, jamminglist x)
        """
        return _sim2dlong._jamminglist_insert(self, *args)

    def pop_front(self) -> "void" :
        """pop_front(_jamminglist self)"""
        return _sim2dlong._jamminglist_pop_front(self)

    def push_front(self, *args) -> "void" :
        """push_front(_jamminglist self, jamminglist x)"""
        return _sim2dlong._jamminglist_push_front(self, *args)

    def reverse(self) -> "void" :
        """reverse(_jamminglist self)"""
        return _sim2dlong._jamminglist_reverse(self)

    __swig_destroy__ = _sim2dlong.delete__jamminglist
    __del__ = lambda self : None;
_jamminglist_swigregister = _sim2dlong._jamminglist_swigregister
_jamminglist_swigregister(_jamminglist)

class _jamminglistrot(collections.MutableSequence):
    """Proxy of C++ std::list<(jamminglistrot)> class"""
    __swig_setmethods__ = {}
    for _s in [collections.MutableSequence]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, _jamminglistrot, name, value)
    __swig_getmethods__ = {}
    for _s in [collections.MutableSequence]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, _jamminglistrot, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" :
        """iterator(_jamminglistrot self) -> SwigPyIterator"""
        return _sim2dlong._jamminglistrot_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" :
        """__nonzero__(_jamminglistrot self) -> bool"""
        return _sim2dlong._jamminglistrot___nonzero__(self)

    def __bool__(self) -> "bool" :
        """__bool__(_jamminglistrot self) -> bool"""
        return _sim2dlong._jamminglistrot___bool__(self)

    def __len__(self) -> "std::list< jamminglistrot >::size_type" :
        """__len__(_jamminglistrot self) -> std::list< jamminglistrot >::size_type"""
        return _sim2dlong._jamminglistrot___len__(self)

    def pop(self) -> "std::list< jamminglistrot >::value_type" :
        """pop(_jamminglistrot self) -> jamminglistrot"""
        return _sim2dlong._jamminglistrot_pop(self)

    def __getslice__(self, *args) -> "std::list< jamminglistrot,std::allocator< jamminglistrot > > *" :
        """__getslice__(_jamminglistrot self, std::list< jamminglistrot >::difference_type i, std::list< jamminglistrot >::difference_type j) -> _jamminglistrot"""
        return _sim2dlong._jamminglistrot___getslice__(self, *args)

    def __setslice__(self, *args) -> "void" :
        """
        __setslice__(_jamminglistrot self, std::list< jamminglistrot >::difference_type i, std::list< jamminglistrot >::difference_type j, 
            _jamminglistrot v=std::list< jamminglistrot,std::allocator< jamminglistrot > >())
        __setslice__(_jamminglistrot self, std::list< jamminglistrot >::difference_type i, std::list< jamminglistrot >::difference_type j)
        """
        return _sim2dlong._jamminglistrot___setslice__(self, *args)

    def __delslice__(self, *args) -> "void" :
        """__delslice__(_jamminglistrot self, std::list< jamminglistrot >::difference_type i, std::list< jamminglistrot >::difference_type j)"""
        return _sim2dlong._jamminglistrot___delslice__(self, *args)

    def __delitem__(self, *args) -> "void" :
        """
        __delitem__(_jamminglistrot self, std::list< jamminglistrot >::difference_type i)
        __delitem__(_jamminglistrot self, PySliceObject * slice)
        """
        return _sim2dlong._jamminglistrot___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::list< jamminglistrot >::value_type const &" :
        """
        __getitem__(_jamminglistrot self, PySliceObject * slice) -> _jamminglistrot
        __getitem__(_jamminglistrot self, std::list< jamminglistrot >::difference_type i) -> jamminglistrot
        """
        return _sim2dlong._jamminglistrot___getitem__(self, *args)

    def __setitem__(self, *args) -> "void" :
        """
        __setitem__(_jamminglistrot self, PySliceObject * slice, _jamminglistrot v)
        __setitem__(_jamminglistrot self, PySliceObject * slice)
        __setitem__(_jamminglistrot self, std::list< jamminglistrot >::difference_type i, jamminglistrot x)
        """
        return _sim2dlong._jamminglistrot___setitem__(self, *args)

    def append(self, *args) -> "void" :
        """append(_jamminglistrot self, jamminglistrot x)"""
        return _sim2dlong._jamminglistrot_append(self, *args)

    def empty(self) -> "bool" :
        """empty(_jamminglistrot self) -> bool"""
        return _sim2dlong._jamminglistrot_empty(self)

    def size(self) -> "std::list< jamminglistrot >::size_type" :
        """size(_jamminglistrot self) -> std::list< jamminglistrot >::size_type"""
        return _sim2dlong._jamminglistrot_size(self)

    def clear(self) -> "void" :
        """clear(_jamminglistrot self)"""
        return _sim2dlong._jamminglistrot_clear(self)

    def swap(self, *args) -> "void" :
        """swap(_jamminglistrot self, _jamminglistrot v)"""
        return _sim2dlong._jamminglistrot_swap(self, *args)

    def get_allocator(self) -> "std::list< jamminglistrot >::allocator_type" :
        """get_allocator(_jamminglistrot self) -> std::list< jamminglistrot >::allocator_type"""
        return _sim2dlong._jamminglistrot_get_allocator(self)

    def begin(self) -> "std::list< jamminglistrot >::iterator" :
        """begin(_jamminglistrot self) -> std::list< jamminglistrot >::iterator"""
        return _sim2dlong._jamminglistrot_begin(self)

    def end(self) -> "std::list< jamminglistrot >::iterator" :
        """end(_jamminglistrot self) -> std::list< jamminglistrot >::iterator"""
        return _sim2dlong._jamminglistrot_end(self)

    def rbegin(self) -> "std::list< jamminglistrot >::reverse_iterator" :
        """rbegin(_jamminglistrot self) -> std::list< jamminglistrot >::reverse_iterator"""
        return _sim2dlong._jamminglistrot_rbegin(self)

    def rend(self) -> "std::list< jamminglistrot >::reverse_iterator" :
        """rend(_jamminglistrot self) -> std::list< jamminglistrot >::reverse_iterator"""
        return _sim2dlong._jamminglistrot_rend(self)

    def pop_back(self) -> "void" :
        """pop_back(_jamminglistrot self)"""
        return _sim2dlong._jamminglistrot_pop_back(self)

    def erase(self, *args) -> "std::list< jamminglistrot >::iterator" :
        """
        erase(_jamminglistrot self, std::list< jamminglistrot >::iterator pos) -> std::list< jamminglistrot >::iterator
        erase(_jamminglistrot self, std::list< jamminglistrot >::iterator first, std::list< jamminglistrot >::iterator last) -> std::list< jamminglistrot >::iterator
        """
        return _sim2dlong._jamminglistrot_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::list<(jamminglistrot)> self) -> _jamminglistrot
        __init__(std::list<(jamminglistrot)> self, _jamminglistrot arg2) -> _jamminglistrot
        __init__(std::list<(jamminglistrot)> self, std::list< jamminglistrot >::size_type size) -> _jamminglistrot
        __init__(std::list<(jamminglistrot)> self, std::list< jamminglistrot >::size_type size, jamminglistrot value) -> _jamminglistrot
        """
        this = _sim2dlong.new__jamminglistrot(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" :
        """push_back(_jamminglistrot self, jamminglistrot x)"""
        return _sim2dlong._jamminglistrot_push_back(self, *args)

    def front(self) -> "std::list< jamminglistrot >::value_type const &" :
        """front(_jamminglistrot self) -> jamminglistrot"""
        return _sim2dlong._jamminglistrot_front(self)

    def back(self) -> "std::list< jamminglistrot >::value_type const &" :
        """back(_jamminglistrot self) -> jamminglistrot"""
        return _sim2dlong._jamminglistrot_back(self)

    def assign(self, *args) -> "void" :
        """assign(_jamminglistrot self, std::list< jamminglistrot >::size_type n, jamminglistrot x)"""
        return _sim2dlong._jamminglistrot_assign(self, *args)

    def resize(self, *args) -> "void" :
        """
        resize(_jamminglistrot self, std::list< jamminglistrot >::size_type new_size)
        resize(_jamminglistrot self, std::list< jamminglistrot >::size_type new_size, jamminglistrot x)
        """
        return _sim2dlong._jamminglistrot_resize(self, *args)

    def insert(self, *args) -> "void" :
        """
        insert(_jamminglistrot self, std::list< jamminglistrot >::iterator pos, jamminglistrot x) -> std::list< jamminglistrot >::iterator
        insert(_jamminglistrot self, std::list< jamminglistrot >::iterator pos, std::list< jamminglistrot >::size_type n, 
            jamminglistrot x)
        """
        return _sim2dlong._jamminglistrot_insert(self, *args)

    def pop_front(self) -> "void" :
        """pop_front(_jamminglistrot self)"""
        return _sim2dlong._jamminglistrot_pop_front(self)

    def push_front(self, *args) -> "void" :
        """push_front(_jamminglistrot self, jamminglistrot x)"""
        return _sim2dlong._jamminglistrot_push_front(self, *args)

    def reverse(self) -> "void" :
        """reverse(_jamminglistrot self)"""
        return _sim2dlong._jamminglistrot_reverse(self)

    __swig_destroy__ = _sim2dlong.delete__jamminglistrot
    __del__ = lambda self : None;
_jamminglistrot_swigregister = _sim2dlong._jamminglistrot_swigregister
_jamminglistrot_swigregister(_jamminglistrot)

class vecptrvectorL(_object):
    """Proxy of C++ std::vector<(p.Vector2<(long double)>)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vecptrvectorL, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vecptrvectorL, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" :
        """iterator(vecptrvectorL self) -> SwigPyIterator"""
        return _sim2dlong.vecptrvectorL_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" :
        """__nonzero__(vecptrvectorL self) -> bool"""
        return _sim2dlong.vecptrvectorL___nonzero__(self)

    def __bool__(self) -> "bool" :
        """__bool__(vecptrvectorL self) -> bool"""
        return _sim2dlong.vecptrvectorL___bool__(self)

    def __len__(self) -> "std::vector< Vector2< long double > * >::size_type" :
        """__len__(vecptrvectorL self) -> std::vector< Vector2< long double > * >::size_type"""
        return _sim2dlong.vecptrvectorL___len__(self)

    def pop(self) -> "std::vector< Vector2< long double > * >::value_type" :
        """pop(vecptrvectorL self) -> VecL"""
        return _sim2dlong.vecptrvectorL_pop(self)

    def __getslice__(self, *args) -> "std::vector< Vector2< long double > *,std::allocator< Vector2< long double > * > > *" :
        """__getslice__(vecptrvectorL self, std::vector< Vector2< long double > * >::difference_type i, std::vector< Vector2< long double > * >::difference_type j) -> vecptrvectorL"""
        return _sim2dlong.vecptrvectorL___getslice__(self, *args)

    def __setslice__(self, *args) -> "void" :
        """
        __setslice__(vecptrvectorL self, std::vector< Vector2< long double > * >::difference_type i, std::vector< Vector2< long double > * >::difference_type j, 
            vecptrvectorL v=std::vector< Vector2< long double > *,std::allocator< Vector2< long double > * > >())
        __setslice__(vecptrvectorL self, std::vector< Vector2< long double > * >::difference_type i, std::vector< Vector2< long double > * >::difference_type j)
        """
        return _sim2dlong.vecptrvectorL___setslice__(self, *args)

    def __delslice__(self, *args) -> "void" :
        """__delslice__(vecptrvectorL self, std::vector< Vector2< long double > * >::difference_type i, std::vector< Vector2< long double > * >::difference_type j)"""
        return _sim2dlong.vecptrvectorL___delslice__(self, *args)

    def __delitem__(self, *args) -> "void" :
        """
        __delitem__(vecptrvectorL self, std::vector< Vector2< long double > * >::difference_type i)
        __delitem__(vecptrvectorL self, PySliceObject * slice)
        """
        return _sim2dlong.vecptrvectorL___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< Vector2< long double > * >::value_type" :
        """
        __getitem__(vecptrvectorL self, PySliceObject * slice) -> vecptrvectorL
        __getitem__(vecptrvectorL self, std::vector< Vector2< long double > * >::difference_type i) -> VecL
        """
        return _sim2dlong.vecptrvectorL___getitem__(self, *args)

    def __setitem__(self, *args) -> "void" :
        """
        __setitem__(vecptrvectorL self, PySliceObject * slice, vecptrvectorL v)
        __setitem__(vecptrvectorL self, PySliceObject * slice)
        __setitem__(vecptrvectorL self, std::vector< Vector2< long double > * >::difference_type i, VecL x)
        """
        return _sim2dlong.vecptrvectorL___setitem__(self, *args)

    def append(self, *args) -> "void" :
        """append(vecptrvectorL self, VecL x)"""
        return _sim2dlong.vecptrvectorL_append(self, *args)

    def empty(self) -> "bool" :
        """empty(vecptrvectorL self) -> bool"""
        return _sim2dlong.vecptrvectorL_empty(self)

    def size(self) -> "std::vector< Vector2< long double > * >::size_type" :
        """size(vecptrvectorL self) -> std::vector< Vector2< long double > * >::size_type"""
        return _sim2dlong.vecptrvectorL_size(self)

    def clear(self) -> "void" :
        """clear(vecptrvectorL self)"""
        return _sim2dlong.vecptrvectorL_clear(self)

    def swap(self, *args) -> "void" :
        """swap(vecptrvectorL self, vecptrvectorL v)"""
        return _sim2dlong.vecptrvectorL_swap(self, *args)

    def get_allocator(self) -> "std::vector< Vector2< long double > * >::allocator_type" :
        """get_allocator(vecptrvectorL self) -> std::vector< Vector2< long double > * >::allocator_type"""
        return _sim2dlong.vecptrvectorL_get_allocator(self)

    def begin(self) -> "std::vector< Vector2< long double > * >::iterator" :
        """begin(vecptrvectorL self) -> std::vector< Vector2< long double > * >::iterator"""
        return _sim2dlong.vecptrvectorL_begin(self)

    def end(self) -> "std::vector< Vector2< long double > * >::iterator" :
        """end(vecptrvectorL self) -> std::vector< Vector2< long double > * >::iterator"""
        return _sim2dlong.vecptrvectorL_end(self)

    def rbegin(self) -> "std::vector< Vector2< long double > * >::reverse_iterator" :
        """rbegin(vecptrvectorL self) -> std::vector< Vector2< long double > * >::reverse_iterator"""
        return _sim2dlong.vecptrvectorL_rbegin(self)

    def rend(self) -> "std::vector< Vector2< long double > * >::reverse_iterator" :
        """rend(vecptrvectorL self) -> std::vector< Vector2< long double > * >::reverse_iterator"""
        return _sim2dlong.vecptrvectorL_rend(self)

    def pop_back(self) -> "void" :
        """pop_back(vecptrvectorL self)"""
        return _sim2dlong.vecptrvectorL_pop_back(self)

    def erase(self, *args) -> "std::vector< Vector2< long double > * >::iterator" :
        """
        erase(vecptrvectorL self, std::vector< Vector2< long double > * >::iterator pos) -> std::vector< Vector2< long double > * >::iterator
        erase(vecptrvectorL self, std::vector< Vector2< long double > * >::iterator first, std::vector< Vector2< long double > * >::iterator last) -> std::vector< Vector2< long double > * >::iterator
        """
        return _sim2dlong.vecptrvectorL_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(p.Vector2<(long double)>)> self) -> vecptrvectorL
        __init__(std::vector<(p.Vector2<(long double)>)> self, vecptrvectorL arg2) -> vecptrvectorL
        __init__(std::vector<(p.Vector2<(long double)>)> self, std::vector< Vector2< long double > * >::size_type size) -> vecptrvectorL
        __init__(std::vector<(p.Vector2<(long double)>)> self, std::vector< Vector2< long double > * >::size_type size, VecL value) -> vecptrvectorL
        """
        this = _sim2dlong.new_vecptrvectorL(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" :
        """push_back(vecptrvectorL self, VecL x)"""
        return _sim2dlong.vecptrvectorL_push_back(self, *args)

    def front(self) -> "std::vector< Vector2< long double > * >::value_type" :
        """front(vecptrvectorL self) -> VecL"""
        return _sim2dlong.vecptrvectorL_front(self)

    def back(self) -> "std::vector< Vector2< long double > * >::value_type" :
        """back(vecptrvectorL self) -> VecL"""
        return _sim2dlong.vecptrvectorL_back(self)

    def assign(self, *args) -> "void" :
        """assign(vecptrvectorL self, std::vector< Vector2< long double > * >::size_type n, VecL x)"""
        return _sim2dlong.vecptrvectorL_assign(self, *args)

    def resize(self, *args) -> "void" :
        """
        resize(vecptrvectorL self, std::vector< Vector2< long double > * >::size_type new_size)
        resize(vecptrvectorL self, std::vector< Vector2< long double > * >::size_type new_size, VecL x)
        """
        return _sim2dlong.vecptrvectorL_resize(self, *args)

    def insert(self, *args) -> "void" :
        """
        insert(vecptrvectorL self, std::vector< Vector2< long double > * >::iterator pos, VecL x) -> std::vector< Vector2< long double > * >::iterator
        insert(vecptrvectorL self, std::vector< Vector2< long double > * >::iterator pos, std::vector< Vector2< long double > * >::size_type n, 
            VecL x)
        """
        return _sim2dlong.vecptrvectorL_insert(self, *args)

    def reserve(self, *args) -> "void" :
        """reserve(vecptrvectorL self, std::vector< Vector2< long double > * >::size_type n)"""
        return _sim2dlong.vecptrvectorL_reserve(self, *args)

    def capacity(self) -> "std::vector< Vector2< long double > * >::size_type" :
        """capacity(vecptrvectorL self) -> std::vector< Vector2< long double > * >::size_type"""
        return _sim2dlong.vecptrvectorL_capacity(self)

    __swig_destroy__ = _sim2dlong.delete_vecptrvectorL
    __del__ = lambda self : None;
vecptrvectorL_swigregister = _sim2dlong.vecptrvectorL_swigregister
vecptrvectorL_swigregister(vecptrvectorL)

class vecvectorL(collections.MutableSequence):
    """Proxy of C++ std::vector<(Vector2<(long double)>)> class"""
    __swig_setmethods__ = {}
    for _s in [collections.MutableSequence]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, vecvectorL, name, value)
    __swig_getmethods__ = {}
    for _s in [collections.MutableSequence]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, vecvectorL, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" :
        """iterator(vecvectorL self) -> SwigPyIterator"""
        return _sim2dlong.vecvectorL_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" :
        """__nonzero__(vecvectorL self) -> bool"""
        return _sim2dlong.vecvectorL___nonzero__(self)

    def __bool__(self) -> "bool" :
        """__bool__(vecvectorL self) -> bool"""
        return _sim2dlong.vecvectorL___bool__(self)

    def __len__(self) -> "std::vector< Vector2< long double > >::size_type" :
        """__len__(vecvectorL self) -> std::vector< Vector2< long double > >::size_type"""
        return _sim2dlong.vecvectorL___len__(self)

    def pop(self) -> "std::vector< Vector2< long double > >::value_type" :
        """pop(vecvectorL self) -> VecL"""
        return _sim2dlong.vecvectorL_pop(self)

    def __getslice__(self, *args) -> "std::vector< Vector2< long double >,std::allocator< Vector2< long double > > > *" :
        """__getslice__(vecvectorL self, std::vector< Vector2< long double > >::difference_type i, std::vector< Vector2< long double > >::difference_type j) -> vecvectorL"""
        return _sim2dlong.vecvectorL___getslice__(self, *args)

    def __setslice__(self, *args) -> "void" :
        """
        __setslice__(vecvectorL self, std::vector< Vector2< long double > >::difference_type i, std::vector< Vector2< long double > >::difference_type j, 
            vecvectorL v=std::vector< Vector2< long double >,std::allocator< Vector2< long double > > >())
        __setslice__(vecvectorL self, std::vector< Vector2< long double > >::difference_type i, std::vector< Vector2< long double > >::difference_type j)
        """
        return _sim2dlong.vecvectorL___setslice__(self, *args)

    def __delslice__(self, *args) -> "void" :
        """__delslice__(vecvectorL self, std::vector< Vector2< long double > >::difference_type i, std::vector< Vector2< long double > >::difference_type j)"""
        return _sim2dlong.vecvectorL___delslice__(self, *args)

    def __delitem__(self, *args) -> "void" :
        """
        __delitem__(vecvectorL self, std::vector< Vector2< long double > >::difference_type i)
        __delitem__(vecvectorL self, PySliceObject * slice)
        """
        return _sim2dlong.vecvectorL___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< Vector2< long double > >::value_type const &" :
        """
        __getitem__(vecvectorL self, PySliceObject * slice) -> vecvectorL
        __getitem__(vecvectorL self, std::vector< Vector2< long double > >::difference_type i) -> VecL
        """
        return _sim2dlong.vecvectorL___getitem__(self, *args)

    def __setitem__(self, *args) -> "void" :
        """
        __setitem__(vecvectorL self, PySliceObject * slice, vecvectorL v)
        __setitem__(vecvectorL self, PySliceObject * slice)
        __setitem__(vecvectorL self, std::vector< Vector2< long double > >::difference_type i, VecL x)
        """
        return _sim2dlong.vecvectorL___setitem__(self, *args)

    def append(self, *args) -> "void" :
        """append(vecvectorL self, VecL x)"""
        return _sim2dlong.vecvectorL_append(self, *args)

    def empty(self) -> "bool" :
        """empty(vecvectorL self) -> bool"""
        return _sim2dlong.vecvectorL_empty(self)

    def size(self) -> "std::vector< Vector2< long double > >::size_type" :
        """size(vecvectorL self) -> std::vector< Vector2< long double > >::size_type"""
        return _sim2dlong.vecvectorL_size(self)

    def clear(self) -> "void" :
        """clear(vecvectorL self)"""
        return _sim2dlong.vecvectorL_clear(self)

    def swap(self, *args) -> "void" :
        """swap(vecvectorL self, vecvectorL v)"""
        return _sim2dlong.vecvectorL_swap(self, *args)

    def get_allocator(self) -> "std::vector< Vector2< long double > >::allocator_type" :
        """get_allocator(vecvectorL self) -> std::vector< Vector2< long double > >::allocator_type"""
        return _sim2dlong.vecvectorL_get_allocator(self)

    def begin(self) -> "std::vector< Vector2< long double > >::iterator" :
        """begin(vecvectorL self) -> std::vector< Vector2< long double > >::iterator"""
        return _sim2dlong.vecvectorL_begin(self)

    def end(self) -> "std::vector< Vector2< long double > >::iterator" :
        """end(vecvectorL self) -> std::vector< Vector2< long double > >::iterator"""
        return _sim2dlong.vecvectorL_end(self)

    def rbegin(self) -> "std::vector< Vector2< long double > >::reverse_iterator" :
        """rbegin(vecvectorL self) -> std::vector< Vector2< long double > >::reverse_iterator"""
        return _sim2dlong.vecvectorL_rbegin(self)

    def rend(self) -> "std::vector< Vector2< long double > >::reverse_iterator" :
        """rend(vecvectorL self) -> std::vector< Vector2< long double > >::reverse_iterator"""
        return _sim2dlong.vecvectorL_rend(self)

    def pop_back(self) -> "void" :
        """pop_back(vecvectorL self)"""
        return _sim2dlong.vecvectorL_pop_back(self)

    def erase(self, *args) -> "std::vector< Vector2< long double > >::iterator" :
        """
        erase(vecvectorL self, std::vector< Vector2< long double > >::iterator pos) -> std::vector< Vector2< long double > >::iterator
        erase(vecvectorL self, std::vector< Vector2< long double > >::iterator first, std::vector< Vector2< long double > >::iterator last) -> std::vector< Vector2< long double > >::iterator
        """
        return _sim2dlong.vecvectorL_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(Vector2<(long double)>)> self) -> vecvectorL
        __init__(std::vector<(Vector2<(long double)>)> self, vecvectorL arg2) -> vecvectorL
        __init__(std::vector<(Vector2<(long double)>)> self, std::vector< Vector2< long double > >::size_type size) -> vecvectorL
        __init__(std::vector<(Vector2<(long double)>)> self, std::vector< Vector2< long double > >::size_type size, VecL value) -> vecvectorL
        """
        this = _sim2dlong.new_vecvectorL(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" :
        """push_back(vecvectorL self, VecL x)"""
        return _sim2dlong.vecvectorL_push_back(self, *args)

    def front(self) -> "std::vector< Vector2< long double > >::value_type const &" :
        """front(vecvectorL self) -> VecL"""
        return _sim2dlong.vecvectorL_front(self)

    def back(self) -> "std::vector< Vector2< long double > >::value_type const &" :
        """back(vecvectorL self) -> VecL"""
        return _sim2dlong.vecvectorL_back(self)

    def assign(self, *args) -> "void" :
        """assign(vecvectorL self, std::vector< Vector2< long double > >::size_type n, VecL x)"""
        return _sim2dlong.vecvectorL_assign(self, *args)

    def resize(self, *args) -> "void" :
        """
        resize(vecvectorL self, std::vector< Vector2< long double > >::size_type new_size)
        resize(vecvectorL self, std::vector< Vector2< long double > >::size_type new_size, VecL x)
        """
        return _sim2dlong.vecvectorL_resize(self, *args)

    def insert(self, *args) -> "void" :
        """
        insert(vecvectorL self, std::vector< Vector2< long double > >::iterator pos, VecL x) -> std::vector< Vector2< long double > >::iterator
        insert(vecvectorL self, std::vector< Vector2< long double > >::iterator pos, std::vector< Vector2< long double > >::size_type n, 
            VecL x)
        """
        return _sim2dlong.vecvectorL_insert(self, *args)

    def reserve(self, *args) -> "void" :
        """reserve(vecvectorL self, std::vector< Vector2< long double > >::size_type n)"""
        return _sim2dlong.vecvectorL_reserve(self, *args)

    def capacity(self) -> "std::vector< Vector2< long double > >::size_type" :
        """capacity(vecvectorL self) -> std::vector< Vector2< long double > >::size_type"""
        return _sim2dlong.vecvectorL_capacity(self)

    __swig_destroy__ = _sim2dlong.delete_vecvectorL
    __del__ = lambda self : None;
vecvectorL_swigregister = _sim2dlong.vecvectorL_swigregister
vecvectorL_swigregister(vecvectorL)

class Pair(_Nvector2):
    """Proxy of C++ Numvector<(double,2)> class"""
    __swig_setmethods__ = {}
    for _s in [_Nvector2]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Pair, name, value)
    __swig_getmethods__ = {}
    for _s in [_Nvector2]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Pair, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(Numvector<(double,2)> self) -> Pair
        __init__(Numvector<(double,2)> self, _Nvector2 rhs) -> Pair
        __init__(Numvector<(double,2)> self, double const [2] rhs) -> Pair
        """
        this = _sim2dlong.new_Pair(*args)
        try: self.this.append(this)
        except: self.this = this
    def dot(self, *args) -> "double" :
        """dot(Pair self, _Numvector2 other) -> double"""
        return _sim2dlong.Pair_dot(self, *args)

    def sq(self) -> "double" :
        """sq(Pair self) -> double"""
        return _sim2dlong.Pair_sq(self)

    def mag(self) -> "double" :
        """mag(Pair self) -> double"""
        return _sim2dlong.Pair_mag(self)

    def distance(self, *args) -> "double" :
        """distance(Pair self, _Numvector2 rhs) -> double"""
        return _sim2dlong.Pair_distance(self, *args)

    def perpto(self, *args) -> "Numvector< double,2 >" :
        """perpto(Pair self, _Numvector2 other) -> _Numvector2"""
        return _sim2dlong.Pair_perpto(self, *args)

    def normalize(self) -> "void" :
        """normalize(Pair self)"""
        return _sim2dlong.Pair_normalize(self)

    def norm(self) -> "Numvector< double,2 >" :
        """norm(Pair self) -> _Numvector2"""
        return _sim2dlong.Pair_norm(self)

    __swig_destroy__ = _sim2dlong.delete_Pair
    __del__ = lambda self : None;
Pair_swigregister = _sim2dlong.Pair_swigregister
Pair_swigregister(Pair)

class VecPair(_object):
    """Proxy of C++ Nvector<(Vec,2)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VecPair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VecPair, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(Nvector<(Vec,2)> self) -> VecPair
        __init__(Nvector<(Vec,2)> self, VecPair rhs) -> VecPair
        __init__(Nvector<(Vec,2)> self, VecL locs) -> VecPair
        """
        this = _sim2dlong.new_VecPair(*args)
        try: self.this.append(this)
        except: self.this = this
    def get(self, *args) -> "Vec const &" :
        """get(VecPair self, unsigned int const n) -> VecL"""
        return _sim2dlong.VecPair_get(self, *args)

    def set(self, *args) -> "void" :
        """set(VecPair self, unsigned int const n, VecL a)"""
        return _sim2dlong.VecPair_set(self, *args)

    def len(self) -> "unsigned int" :
        """len(VecPair self) -> unsigned int"""
        return _sim2dlong.VecPair_len(self)

    def __iadd__(self, *args) -> "Nvector< Vec,2 > &" :
        """__iadd__(VecPair self, VecPair rhs) -> VecPair"""
        return _sim2dlong.VecPair___iadd__(self, *args)

    def __isub__(self, *args) -> "Nvector< Vec,2 > &" :
        """__isub__(VecPair self, VecPair rhs) -> VecPair"""
        return _sim2dlong.VecPair___isub__(self, *args)

    def __neg__(self) -> "Nvector< Vec,2 >" :
        """__neg__(VecPair self) -> VecPair"""
        return _sim2dlong.VecPair___neg__(self)

    def __add__(self, *args) -> "Nvector< Vec,2 >" :
        """__add__(VecPair self, VecPair rhs) -> VecPair"""
        return _sim2dlong.VecPair___add__(self, *args)

    def __sub__(self, *args) -> "Nvector< Vec,2 >" :
        """__sub__(VecPair self, VecPair rhs) -> VecPair"""
        return _sim2dlong.VecPair___sub__(self, *args)

    def begin(self) -> "Vec *" :
        """begin(VecPair self) -> VecL"""
        return _sim2dlong.VecPair_begin(self)

    def end(self) -> "Vec *" :
        """end(VecPair self) -> VecL"""
        return _sim2dlong.VecPair_end(self)

    __swig_destroy__ = _sim2dlong.delete_VecPair
    __del__ = lambda self : None;
    def __mul__(self, *args) -> "Nvector< Vec,2 >" :
        """__mul__(VecPair self, double const rhs) -> VecPair"""
        return _sim2dlong.VecPair___mul__(self, *args)

    def __div__(self, *args) -> "Nvector< Vec,2 >" :
        """__div__(VecPair self, double const rhs) -> VecPair"""
        return _sim2dlong.VecPair___div__(self, *args)

    def __truediv__(self, *args) -> "Nvector< Vec,2 >" :
        """__truediv__(VecPair self, double const n) -> VecPair"""
        return _sim2dlong.VecPair___truediv__(self, *args)

    def __getitem__(self, *args) -> "Vec" :
        """__getitem__(VecPair self, unsigned int const n) -> VecL"""
        return _sim2dlong.VecPair___getitem__(self, *args)

    def __setitem__(self, *args) -> "void" :
        """__setitem__(VecPair self, unsigned int const n, VecL val)"""
        return _sim2dlong.VecPair___setitem__(self, *args)

    def __len__(self) -> "unsigned int" :
        """__len__(VecPair self) -> unsigned int"""
        return _sim2dlong.VecPair___len__(self)

    #~ def __setitem__(self, n, val):
        #~ return self.set(n, val)

    def __iter__(self):
        for i in range(len(self)):
            yield self.get(i)

    #~ def __len__(self):
        #~ return self.len()

VecPair_swigregister = _sim2dlong.VecPair_swigregister
VecPair_swigregister(VecPair)

class _atomarray2(_object):
    """Proxy of C++ array<(p.atom,2)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _atomarray2, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _atomarray2, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(array<(p.atom,2)> self) -> _atomarray2
        __init__(array<(p.atom,2)> self, _atomarray2 rhs) -> _atomarray2
        __init__(array<(p.atom,2)> self, atom *const [2] locs) -> _atomarray2
        """
        this = _sim2dlong.new__atomarray2(*args)
        try: self.this.append(this)
        except: self.this = this
    def get(self, *args) -> "atom *const &" :
        """get(_atomarray2 self, unsigned int const n) -> atom"""
        return _sim2dlong._atomarray2_get(self, *args)

    def set(self, *args) -> "void" :
        """set(_atomarray2 self, unsigned int const n, atom a)"""
        return _sim2dlong._atomarray2_set(self, *args)

    def len(self) -> "unsigned int" :
        """len(_atomarray2 self) -> unsigned int"""
        return _sim2dlong._atomarray2_len(self)

    def begin(self) -> "atom **" :
        """begin(_atomarray2 self) -> atom **"""
        return _sim2dlong._atomarray2_begin(self)

    def end(self) -> "atom **" :
        """end(_atomarray2 self) -> atom **"""
        return _sim2dlong._atomarray2_end(self)

    __swig_destroy__ = _sim2dlong.delete__atomarray2
    __del__ = lambda self : None;
_atomarray2_swigregister = _sim2dlong._atomarray2_swigregister
_atomarray2_swigregister(_atomarray2)

class _idarray2(_object):
    """Proxy of C++ array<(atomid,2)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _idarray2, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _idarray2, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(array<(atomid,2)> self) -> _idarray2
        __init__(array<(atomid,2)> self, _idarray2 rhs) -> _idarray2
        __init__(array<(atomid,2)> self, atomid locs) -> _idarray2
        """
        this = _sim2dlong.new__idarray2(*args)
        try: self.this.append(this)
        except: self.this = this
    def get(self, *args) -> "atomid const &" :
        """get(_idarray2 self, unsigned int const n) -> atomid"""
        return _sim2dlong._idarray2_get(self, *args)

    def set(self, *args) -> "void" :
        """set(_idarray2 self, unsigned int const n, atomid a)"""
        return _sim2dlong._idarray2_set(self, *args)

    def len(self) -> "unsigned int" :
        """len(_idarray2 self) -> unsigned int"""
        return _sim2dlong._idarray2_len(self)

    def begin(self) -> "atomid *" :
        """begin(_idarray2 self) -> atomid"""
        return _sim2dlong._idarray2_begin(self)

    def end(self) -> "atomid *" :
        """end(_idarray2 self) -> atomid"""
        return _sim2dlong._idarray2_end(self)

    __swig_destroy__ = _sim2dlong.delete__idarray2
    __del__ = lambda self : None;
_idarray2_swigregister = _sim2dlong._idarray2_swigregister
_idarray2_swigregister(_idarray2)

class _atomarray3(_object):
    """Proxy of C++ array<(p.atom,3)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _atomarray3, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _atomarray3, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(array<(p.atom,3)> self) -> _atomarray3
        __init__(array<(p.atom,3)> self, _atomarray3 rhs) -> _atomarray3
        __init__(array<(p.atom,3)> self, atom *const [3] locs) -> _atomarray3
        """
        this = _sim2dlong.new__atomarray3(*args)
        try: self.this.append(this)
        except: self.this = this
    def get(self, *args) -> "atom *const &" :
        """get(_atomarray3 self, unsigned int const n) -> atom"""
        return _sim2dlong._atomarray3_get(self, *args)

    def set(self, *args) -> "void" :
        """set(_atomarray3 self, unsigned int const n, atom a)"""
        return _sim2dlong._atomarray3_set(self, *args)

    def len(self) -> "unsigned int" :
        """len(_atomarray3 self) -> unsigned int"""
        return _sim2dlong._atomarray3_len(self)

    def begin(self) -> "atom **" :
        """begin(_atomarray3 self) -> atom **"""
        return _sim2dlong._atomarray3_begin(self)

    def end(self) -> "atom **" :
        """end(_atomarray3 self) -> atom **"""
        return _sim2dlong._atomarray3_end(self)

    __swig_destroy__ = _sim2dlong.delete__atomarray3
    __del__ = lambda self : None;
_atomarray3_swigregister = _sim2dlong._atomarray3_swigregister
_atomarray3_swigregister(_atomarray3)

class _atomarray4(_object):
    """Proxy of C++ array<(p.atom,4)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _atomarray4, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _atomarray4, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(array<(p.atom,4)> self) -> _atomarray4
        __init__(array<(p.atom,4)> self, _atomarray4 rhs) -> _atomarray4
        __init__(array<(p.atom,4)> self, atom *const [4] locs) -> _atomarray4
        """
        this = _sim2dlong.new__atomarray4(*args)
        try: self.this.append(this)
        except: self.this = this
    def get(self, *args) -> "atom *const &" :
        """get(_atomarray4 self, unsigned int const n) -> atom"""
        return _sim2dlong._atomarray4_get(self, *args)

    def set(self, *args) -> "void" :
        """set(_atomarray4 self, unsigned int const n, atom a)"""
        return _sim2dlong._atomarray4_set(self, *args)

    def len(self) -> "unsigned int" :
        """len(_atomarray4 self) -> unsigned int"""
        return _sim2dlong._atomarray4_len(self)

    def begin(self) -> "atom **" :
        """begin(_atomarray4 self) -> atom **"""
        return _sim2dlong._atomarray4_begin(self)

    def end(self) -> "atom **" :
        """end(_atomarray4 self) -> atom **"""
        return _sim2dlong._atomarray4_end(self)

    __swig_destroy__ = _sim2dlong.delete__atomarray4
    __del__ = lambda self : None;
_atomarray4_swigregister = _sim2dlong._atomarray4_swigregister
_atomarray4_swigregister(_atomarray4)

class fvector(collections.MutableSequence):
    """Proxy of C++ std::vector<(float)> class"""
    __swig_setmethods__ = {}
    for _s in [collections.MutableSequence]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, fvector, name, value)
    __swig_getmethods__ = {}
    for _s in [collections.MutableSequence]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, fvector, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" :
        """iterator(fvector self) -> SwigPyIterator"""
        return _sim2dlong.fvector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" :
        """__nonzero__(fvector self) -> bool"""
        return _sim2dlong.fvector___nonzero__(self)

    def __bool__(self) -> "bool" :
        """__bool__(fvector self) -> bool"""
        return _sim2dlong.fvector___bool__(self)

    def __len__(self) -> "std::vector< float >::size_type" :
        """__len__(fvector self) -> std::vector< float >::size_type"""
        return _sim2dlong.fvector___len__(self)

    def pop(self) -> "std::vector< float >::value_type" :
        """pop(fvector self) -> std::vector< float >::value_type"""
        return _sim2dlong.fvector_pop(self)

    def __getslice__(self, *args) -> "std::vector< float,std::allocator< float > > *" :
        """__getslice__(fvector self, std::vector< float >::difference_type i, std::vector< float >::difference_type j) -> fvector"""
        return _sim2dlong.fvector___getslice__(self, *args)

    def __setslice__(self, *args) -> "void" :
        """
        __setslice__(fvector self, std::vector< float >::difference_type i, std::vector< float >::difference_type j, 
            fvector v=std::vector< float,std::allocator< float > >())
        __setslice__(fvector self, std::vector< float >::difference_type i, std::vector< float >::difference_type j)
        """
        return _sim2dlong.fvector___setslice__(self, *args)

    def __delslice__(self, *args) -> "void" :
        """__delslice__(fvector self, std::vector< float >::difference_type i, std::vector< float >::difference_type j)"""
        return _sim2dlong.fvector___delslice__(self, *args)

    def __delitem__(self, *args) -> "void" :
        """
        __delitem__(fvector self, std::vector< float >::difference_type i)
        __delitem__(fvector self, PySliceObject * slice)
        """
        return _sim2dlong.fvector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< float >::value_type const &" :
        """
        __getitem__(fvector self, PySliceObject * slice) -> fvector
        __getitem__(fvector self, std::vector< float >::difference_type i) -> std::vector< float >::value_type const &
        """
        return _sim2dlong.fvector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void" :
        """
        __setitem__(fvector self, PySliceObject * slice, fvector v)
        __setitem__(fvector self, PySliceObject * slice)
        __setitem__(fvector self, std::vector< float >::difference_type i, std::vector< float >::value_type const & x)
        """
        return _sim2dlong.fvector___setitem__(self, *args)

    def append(self, *args) -> "void" :
        """append(fvector self, std::vector< float >::value_type const & x)"""
        return _sim2dlong.fvector_append(self, *args)

    def empty(self) -> "bool" :
        """empty(fvector self) -> bool"""
        return _sim2dlong.fvector_empty(self)

    def size(self) -> "std::vector< float >::size_type" :
        """size(fvector self) -> std::vector< float >::size_type"""
        return _sim2dlong.fvector_size(self)

    def clear(self) -> "void" :
        """clear(fvector self)"""
        return _sim2dlong.fvector_clear(self)

    def swap(self, *args) -> "void" :
        """swap(fvector self, fvector v)"""
        return _sim2dlong.fvector_swap(self, *args)

    def get_allocator(self) -> "std::vector< float >::allocator_type" :
        """get_allocator(fvector self) -> std::vector< float >::allocator_type"""
        return _sim2dlong.fvector_get_allocator(self)

    def begin(self) -> "std::vector< float >::iterator" :
        """begin(fvector self) -> std::vector< float >::iterator"""
        return _sim2dlong.fvector_begin(self)

    def end(self) -> "std::vector< float >::iterator" :
        """end(fvector self) -> std::vector< float >::iterator"""
        return _sim2dlong.fvector_end(self)

    def rbegin(self) -> "std::vector< float >::reverse_iterator" :
        """rbegin(fvector self) -> std::vector< float >::reverse_iterator"""
        return _sim2dlong.fvector_rbegin(self)

    def rend(self) -> "std::vector< float >::reverse_iterator" :
        """rend(fvector self) -> std::vector< float >::reverse_iterator"""
        return _sim2dlong.fvector_rend(self)

    def pop_back(self) -> "void" :
        """pop_back(fvector self)"""
        return _sim2dlong.fvector_pop_back(self)

    def erase(self, *args) -> "std::vector< float >::iterator" :
        """
        erase(fvector self, std::vector< float >::iterator pos) -> std::vector< float >::iterator
        erase(fvector self, std::vector< float >::iterator first, std::vector< float >::iterator last) -> std::vector< float >::iterator
        """
        return _sim2dlong.fvector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(float)> self) -> fvector
        __init__(std::vector<(float)> self, fvector arg2) -> fvector
        __init__(std::vector<(float)> self, std::vector< float >::size_type size) -> fvector
        __init__(std::vector<(float)> self, std::vector< float >::size_type size, std::vector< float >::value_type const & value) -> fvector
        """
        this = _sim2dlong.new_fvector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" :
        """push_back(fvector self, std::vector< float >::value_type const & x)"""
        return _sim2dlong.fvector_push_back(self, *args)

    def front(self) -> "std::vector< float >::value_type const &" :
        """front(fvector self) -> std::vector< float >::value_type const &"""
        return _sim2dlong.fvector_front(self)

    def back(self) -> "std::vector< float >::value_type const &" :
        """back(fvector self) -> std::vector< float >::value_type const &"""
        return _sim2dlong.fvector_back(self)

    def assign(self, *args) -> "void" :
        """assign(fvector self, std::vector< float >::size_type n, std::vector< float >::value_type const & x)"""
        return _sim2dlong.fvector_assign(self, *args)

    def resize(self, *args) -> "void" :
        """
        resize(fvector self, std::vector< float >::size_type new_size)
        resize(fvector self, std::vector< float >::size_type new_size, std::vector< float >::value_type const & x)
        """
        return _sim2dlong.fvector_resize(self, *args)

    def insert(self, *args) -> "void" :
        """
        insert(fvector self, std::vector< float >::iterator pos, std::vector< float >::value_type const & x) -> std::vector< float >::iterator
        insert(fvector self, std::vector< float >::iterator pos, std::vector< float >::size_type n, std::vector< float >::value_type const & x)
        """
        return _sim2dlong.fvector_insert(self, *args)

    def reserve(self, *args) -> "void" :
        """reserve(fvector self, std::vector< float >::size_type n)"""
        return _sim2dlong.fvector_reserve(self, *args)

    def capacity(self) -> "std::vector< float >::size_type" :
        """capacity(fvector self) -> std::vector< float >::size_type"""
        return _sim2dlong.fvector_capacity(self)

    __swig_destroy__ = _sim2dlong.delete_fvector
    __del__ = lambda self : None;
fvector_swigregister = _sim2dlong.fvector_swigregister
fvector_swigregister(fvector)

class dvector(collections.MutableSequence):
    """Proxy of C++ std::vector<(double)> class"""
    __swig_setmethods__ = {}
    for _s in [collections.MutableSequence]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, dvector, name, value)
    __swig_getmethods__ = {}
    for _s in [collections.MutableSequence]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, dvector, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" :
        """iterator(dvector self) -> SwigPyIterator"""
        return _sim2dlong.dvector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" :
        """__nonzero__(dvector self) -> bool"""
        return _sim2dlong.dvector___nonzero__(self)

    def __bool__(self) -> "bool" :
        """__bool__(dvector self) -> bool"""
        return _sim2dlong.dvector___bool__(self)

    def __len__(self) -> "std::vector< double >::size_type" :
        """__len__(dvector self) -> std::vector< double >::size_type"""
        return _sim2dlong.dvector___len__(self)

    def pop(self) -> "std::vector< double >::value_type" :
        """pop(dvector self) -> std::vector< double >::value_type"""
        return _sim2dlong.dvector_pop(self)

    def __getslice__(self, *args) -> "std::vector< double,std::allocator< double > > *" :
        """__getslice__(dvector self, std::vector< double >::difference_type i, std::vector< double >::difference_type j) -> dvector"""
        return _sim2dlong.dvector___getslice__(self, *args)

    def __setslice__(self, *args) -> "void" :
        """
        __setslice__(dvector self, std::vector< double >::difference_type i, std::vector< double >::difference_type j, 
            dvector v=std::vector< double,std::allocator< double > >())
        __setslice__(dvector self, std::vector< double >::difference_type i, std::vector< double >::difference_type j)
        """
        return _sim2dlong.dvector___setslice__(self, *args)

    def __delslice__(self, *args) -> "void" :
        """__delslice__(dvector self, std::vector< double >::difference_type i, std::vector< double >::difference_type j)"""
        return _sim2dlong.dvector___delslice__(self, *args)

    def __delitem__(self, *args) -> "void" :
        """
        __delitem__(dvector self, std::vector< double >::difference_type i)
        __delitem__(dvector self, PySliceObject * slice)
        """
        return _sim2dlong.dvector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< double >::value_type const &" :
        """
        __getitem__(dvector self, PySliceObject * slice) -> dvector
        __getitem__(dvector self, std::vector< double >::difference_type i) -> std::vector< double >::value_type const &
        """
        return _sim2dlong.dvector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void" :
        """
        __setitem__(dvector self, PySliceObject * slice, dvector v)
        __setitem__(dvector self, PySliceObject * slice)
        __setitem__(dvector self, std::vector< double >::difference_type i, std::vector< double >::value_type const & x)
        """
        return _sim2dlong.dvector___setitem__(self, *args)

    def append(self, *args) -> "void" :
        """append(dvector self, std::vector< double >::value_type const & x)"""
        return _sim2dlong.dvector_append(self, *args)

    def empty(self) -> "bool" :
        """empty(dvector self) -> bool"""
        return _sim2dlong.dvector_empty(self)

    def size(self) -> "std::vector< double >::size_type" :
        """size(dvector self) -> std::vector< double >::size_type"""
        return _sim2dlong.dvector_size(self)

    def clear(self) -> "void" :
        """clear(dvector self)"""
        return _sim2dlong.dvector_clear(self)

    def swap(self, *args) -> "void" :
        """swap(dvector self, dvector v)"""
        return _sim2dlong.dvector_swap(self, *args)

    def get_allocator(self) -> "std::vector< double >::allocator_type" :
        """get_allocator(dvector self) -> std::vector< double >::allocator_type"""
        return _sim2dlong.dvector_get_allocator(self)

    def begin(self) -> "std::vector< double >::iterator" :
        """begin(dvector self) -> std::vector< double >::iterator"""
        return _sim2dlong.dvector_begin(self)

    def end(self) -> "std::vector< double >::iterator" :
        """end(dvector self) -> std::vector< double >::iterator"""
        return _sim2dlong.dvector_end(self)

    def rbegin(self) -> "std::vector< double >::reverse_iterator" :
        """rbegin(dvector self) -> std::vector< double >::reverse_iterator"""
        return _sim2dlong.dvector_rbegin(self)

    def rend(self) -> "std::vector< double >::reverse_iterator" :
        """rend(dvector self) -> std::vector< double >::reverse_iterator"""
        return _sim2dlong.dvector_rend(self)

    def pop_back(self) -> "void" :
        """pop_back(dvector self)"""
        return _sim2dlong.dvector_pop_back(self)

    def erase(self, *args) -> "std::vector< double >::iterator" :
        """
        erase(dvector self, std::vector< double >::iterator pos) -> std::vector< double >::iterator
        erase(dvector self, std::vector< double >::iterator first, std::vector< double >::iterator last) -> std::vector< double >::iterator
        """
        return _sim2dlong.dvector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(double)> self) -> dvector
        __init__(std::vector<(double)> self, dvector arg2) -> dvector
        __init__(std::vector<(double)> self, std::vector< double >::size_type size) -> dvector
        __init__(std::vector<(double)> self, std::vector< double >::size_type size, std::vector< double >::value_type const & value) -> dvector
        """
        this = _sim2dlong.new_dvector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" :
        """push_back(dvector self, std::vector< double >::value_type const & x)"""
        return _sim2dlong.dvector_push_back(self, *args)

    def front(self) -> "std::vector< double >::value_type const &" :
        """front(dvector self) -> std::vector< double >::value_type const &"""
        return _sim2dlong.dvector_front(self)

    def back(self) -> "std::vector< double >::value_type const &" :
        """back(dvector self) -> std::vector< double >::value_type const &"""
        return _sim2dlong.dvector_back(self)

    def assign(self, *args) -> "void" :
        """assign(dvector self, std::vector< double >::size_type n, std::vector< double >::value_type const & x)"""
        return _sim2dlong.dvector_assign(self, *args)

    def resize(self, *args) -> "void" :
        """
        resize(dvector self, std::vector< double >::size_type new_size)
        resize(dvector self, std::vector< double >::size_type new_size, std::vector< double >::value_type const & x)
        """
        return _sim2dlong.dvector_resize(self, *args)

    def insert(self, *args) -> "void" :
        """
        insert(dvector self, std::vector< double >::iterator pos, std::vector< double >::value_type const & x) -> std::vector< double >::iterator
        insert(dvector self, std::vector< double >::iterator pos, std::vector< double >::size_type n, std::vector< double >::value_type const & x)
        """
        return _sim2dlong.dvector_insert(self, *args)

    def reserve(self, *args) -> "void" :
        """reserve(dvector self, std::vector< double >::size_type n)"""
        return _sim2dlong.dvector_reserve(self, *args)

    def capacity(self) -> "std::vector< double >::size_type" :
        """capacity(dvector self) -> std::vector< double >::size_type"""
        return _sim2dlong.dvector_capacity(self)

    __swig_destroy__ = _sim2dlong.delete_dvector
    __del__ = lambda self : None;
dvector_swigregister = _sim2dlong.dvector_swigregister
dvector_swigregister(dvector)

class ldvector(collections.MutableSequence):
    """Proxy of C++ std::vector<(long double)> class"""
    __swig_setmethods__ = {}
    for _s in [collections.MutableSequence]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ldvector, name, value)
    __swig_getmethods__ = {}
    for _s in [collections.MutableSequence]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ldvector, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" :
        """iterator(ldvector self) -> SwigPyIterator"""
        return _sim2dlong.ldvector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" :
        """__nonzero__(ldvector self) -> bool"""
        return _sim2dlong.ldvector___nonzero__(self)

    def __bool__(self) -> "bool" :
        """__bool__(ldvector self) -> bool"""
        return _sim2dlong.ldvector___bool__(self)

    def __len__(self) -> "std::vector< long double >::size_type" :
        """__len__(ldvector self) -> std::vector< long double >::size_type"""
        return _sim2dlong.ldvector___len__(self)

    def pop(self) -> "std::vector< long double >::value_type" :
        """pop(ldvector self) -> std::vector< long double >::value_type"""
        return _sim2dlong.ldvector_pop(self)

    def __getslice__(self, *args) -> "std::vector< long double,std::allocator< long double > > *" :
        """__getslice__(ldvector self, std::vector< long double >::difference_type i, std::vector< long double >::difference_type j) -> ldvector"""
        return _sim2dlong.ldvector___getslice__(self, *args)

    def __setslice__(self, *args) -> "void" :
        """
        __setslice__(ldvector self, std::vector< long double >::difference_type i, std::vector< long double >::difference_type j, 
            ldvector v=std::vector< long double,std::allocator< long double > >())
        __setslice__(ldvector self, std::vector< long double >::difference_type i, std::vector< long double >::difference_type j)
        """
        return _sim2dlong.ldvector___setslice__(self, *args)

    def __delslice__(self, *args) -> "void" :
        """__delslice__(ldvector self, std::vector< long double >::difference_type i, std::vector< long double >::difference_type j)"""
        return _sim2dlong.ldvector___delslice__(self, *args)

    def __delitem__(self, *args) -> "void" :
        """
        __delitem__(ldvector self, std::vector< long double >::difference_type i)
        __delitem__(ldvector self, PySliceObject * slice)
        """
        return _sim2dlong.ldvector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< long double >::value_type const &" :
        """
        __getitem__(ldvector self, PySliceObject * slice) -> ldvector
        __getitem__(ldvector self, std::vector< long double >::difference_type i) -> std::vector< long double >::value_type const &
        """
        return _sim2dlong.ldvector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void" :
        """
        __setitem__(ldvector self, PySliceObject * slice, ldvector v)
        __setitem__(ldvector self, PySliceObject * slice)
        __setitem__(ldvector self, std::vector< long double >::difference_type i, std::vector< long double >::value_type const & x)
        """
        return _sim2dlong.ldvector___setitem__(self, *args)

    def append(self, *args) -> "void" :
        """append(ldvector self, std::vector< long double >::value_type const & x)"""
        return _sim2dlong.ldvector_append(self, *args)

    def empty(self) -> "bool" :
        """empty(ldvector self) -> bool"""
        return _sim2dlong.ldvector_empty(self)

    def size(self) -> "std::vector< long double >::size_type" :
        """size(ldvector self) -> std::vector< long double >::size_type"""
        return _sim2dlong.ldvector_size(self)

    def clear(self) -> "void" :
        """clear(ldvector self)"""
        return _sim2dlong.ldvector_clear(self)

    def swap(self, *args) -> "void" :
        """swap(ldvector self, ldvector v)"""
        return _sim2dlong.ldvector_swap(self, *args)

    def get_allocator(self) -> "std::vector< long double >::allocator_type" :
        """get_allocator(ldvector self) -> std::vector< long double >::allocator_type"""
        return _sim2dlong.ldvector_get_allocator(self)

    def begin(self) -> "std::vector< long double >::iterator" :
        """begin(ldvector self) -> std::vector< long double >::iterator"""
        return _sim2dlong.ldvector_begin(self)

    def end(self) -> "std::vector< long double >::iterator" :
        """end(ldvector self) -> std::vector< long double >::iterator"""
        return _sim2dlong.ldvector_end(self)

    def rbegin(self) -> "std::vector< long double >::reverse_iterator" :
        """rbegin(ldvector self) -> std::vector< long double >::reverse_iterator"""
        return _sim2dlong.ldvector_rbegin(self)

    def rend(self) -> "std::vector< long double >::reverse_iterator" :
        """rend(ldvector self) -> std::vector< long double >::reverse_iterator"""
        return _sim2dlong.ldvector_rend(self)

    def pop_back(self) -> "void" :
        """pop_back(ldvector self)"""
        return _sim2dlong.ldvector_pop_back(self)

    def erase(self, *args) -> "std::vector< long double >::iterator" :
        """
        erase(ldvector self, std::vector< long double >::iterator pos) -> std::vector< long double >::iterator
        erase(ldvector self, std::vector< long double >::iterator first, std::vector< long double >::iterator last) -> std::vector< long double >::iterator
        """
        return _sim2dlong.ldvector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(long double)> self) -> ldvector
        __init__(std::vector<(long double)> self, ldvector arg2) -> ldvector
        __init__(std::vector<(long double)> self, std::vector< long double >::size_type size) -> ldvector
        __init__(std::vector<(long double)> self, std::vector< long double >::size_type size, std::vector< long double >::value_type const & value) -> ldvector
        """
        this = _sim2dlong.new_ldvector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" :
        """push_back(ldvector self, std::vector< long double >::value_type const & x)"""
        return _sim2dlong.ldvector_push_back(self, *args)

    def front(self) -> "std::vector< long double >::value_type const &" :
        """front(ldvector self) -> std::vector< long double >::value_type const &"""
        return _sim2dlong.ldvector_front(self)

    def back(self) -> "std::vector< long double >::value_type const &" :
        """back(ldvector self) -> std::vector< long double >::value_type const &"""
        return _sim2dlong.ldvector_back(self)

    def assign(self, *args) -> "void" :
        """assign(ldvector self, std::vector< long double >::size_type n, std::vector< long double >::value_type const & x)"""
        return _sim2dlong.ldvector_assign(self, *args)

    def resize(self, *args) -> "void" :
        """
        resize(ldvector self, std::vector< long double >::size_type new_size)
        resize(ldvector self, std::vector< long double >::size_type new_size, std::vector< long double >::value_type const & x)
        """
        return _sim2dlong.ldvector_resize(self, *args)

    def insert(self, *args) -> "void" :
        """
        insert(ldvector self, std::vector< long double >::iterator pos, std::vector< long double >::value_type const & x) -> std::vector< long double >::iterator
        insert(ldvector self, std::vector< long double >::iterator pos, std::vector< long double >::size_type n, 
            std::vector< long double >::value_type const & x)
        """
        return _sim2dlong.ldvector_insert(self, *args)

    def reserve(self, *args) -> "void" :
        """reserve(ldvector self, std::vector< long double >::size_type n)"""
        return _sim2dlong.ldvector_reserve(self, *args)

    def capacity(self) -> "std::vector< long double >::size_type" :
        """capacity(ldvector self) -> std::vector< long double >::size_type"""
        return _sim2dlong.ldvector_capacity(self)

    __swig_destroy__ = _sim2dlong.delete_ldvector
    __del__ = lambda self : None;
ldvector_swigregister = _sim2dlong.ldvector_swigregister
ldvector_swigregister(ldvector)

class avector(_object):
    """Proxy of C++ std::vector<(p.atomgroup)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, avector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, avector, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" :
        """iterator(avector self) -> SwigPyIterator"""
        return _sim2dlong.avector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" :
        """__nonzero__(avector self) -> bool"""
        return _sim2dlong.avector___nonzero__(self)

    def __bool__(self) -> "bool" :
        """__bool__(avector self) -> bool"""
        return _sim2dlong.avector___bool__(self)

    def __len__(self) -> "std::vector< atomgroup * >::size_type" :
        """__len__(avector self) -> std::vector< atomgroup * >::size_type"""
        return _sim2dlong.avector___len__(self)

    def pop(self) -> "std::vector< atomgroup * >::value_type" :
        """pop(avector self) -> atomgroup"""
        return _sim2dlong.avector_pop(self)

    def __getslice__(self, *args) -> "std::vector< atomgroup *,std::allocator< atomgroup * > > *" :
        """__getslice__(avector self, std::vector< atomgroup * >::difference_type i, std::vector< atomgroup * >::difference_type j) -> avector"""
        return _sim2dlong.avector___getslice__(self, *args)

    def __setslice__(self, *args) -> "void" :
        """
        __setslice__(avector self, std::vector< atomgroup * >::difference_type i, std::vector< atomgroup * >::difference_type j, 
            avector v=std::vector< atomgroup *,std::allocator< atomgroup * > >())
        __setslice__(avector self, std::vector< atomgroup * >::difference_type i, std::vector< atomgroup * >::difference_type j)
        """
        return _sim2dlong.avector___setslice__(self, *args)

    def __delslice__(self, *args) -> "void" :
        """__delslice__(avector self, std::vector< atomgroup * >::difference_type i, std::vector< atomgroup * >::difference_type j)"""
        return _sim2dlong.avector___delslice__(self, *args)

    def __delitem__(self, *args) -> "void" :
        """
        __delitem__(avector self, std::vector< atomgroup * >::difference_type i)
        __delitem__(avector self, PySliceObject * slice)
        """
        return _sim2dlong.avector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< atomgroup * >::value_type" :
        """
        __getitem__(avector self, PySliceObject * slice) -> avector
        __getitem__(avector self, std::vector< atomgroup * >::difference_type i) -> atomgroup
        """
        return _sim2dlong.avector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void" :
        """
        __setitem__(avector self, PySliceObject * slice, avector v)
        __setitem__(avector self, PySliceObject * slice)
        __setitem__(avector self, std::vector< atomgroup * >::difference_type i, atomgroup x)
        """
        return _sim2dlong.avector___setitem__(self, *args)

    def append(self, *args) -> "void" :
        """append(avector self, atomgroup x)"""
        return _sim2dlong.avector_append(self, *args)

    def empty(self) -> "bool" :
        """empty(avector self) -> bool"""
        return _sim2dlong.avector_empty(self)

    def size(self) -> "std::vector< atomgroup * >::size_type" :
        """size(avector self) -> std::vector< atomgroup * >::size_type"""
        return _sim2dlong.avector_size(self)

    def clear(self) -> "void" :
        """clear(avector self)"""
        return _sim2dlong.avector_clear(self)

    def swap(self, *args) -> "void" :
        """swap(avector self, avector v)"""
        return _sim2dlong.avector_swap(self, *args)

    def get_allocator(self) -> "std::vector< atomgroup * >::allocator_type" :
        """get_allocator(avector self) -> std::vector< atomgroup * >::allocator_type"""
        return _sim2dlong.avector_get_allocator(self)

    def begin(self) -> "std::vector< atomgroup * >::iterator" :
        """begin(avector self) -> std::vector< atomgroup * >::iterator"""
        return _sim2dlong.avector_begin(self)

    def end(self) -> "std::vector< atomgroup * >::iterator" :
        """end(avector self) -> std::vector< atomgroup * >::iterator"""
        return _sim2dlong.avector_end(self)

    def rbegin(self) -> "std::vector< atomgroup * >::reverse_iterator" :
        """rbegin(avector self) -> std::vector< atomgroup * >::reverse_iterator"""
        return _sim2dlong.avector_rbegin(self)

    def rend(self) -> "std::vector< atomgroup * >::reverse_iterator" :
        """rend(avector self) -> std::vector< atomgroup * >::reverse_iterator"""
        return _sim2dlong.avector_rend(self)

    def pop_back(self) -> "void" :
        """pop_back(avector self)"""
        return _sim2dlong.avector_pop_back(self)

    def erase(self, *args) -> "std::vector< atomgroup * >::iterator" :
        """
        erase(avector self, std::vector< atomgroup * >::iterator pos) -> std::vector< atomgroup * >::iterator
        erase(avector self, std::vector< atomgroup * >::iterator first, std::vector< atomgroup * >::iterator last) -> std::vector< atomgroup * >::iterator
        """
        return _sim2dlong.avector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(p.atomgroup)> self) -> avector
        __init__(std::vector<(p.atomgroup)> self, avector arg2) -> avector
        __init__(std::vector<(p.atomgroup)> self, std::vector< atomgroup * >::size_type size) -> avector
        __init__(std::vector<(p.atomgroup)> self, std::vector< atomgroup * >::size_type size, atomgroup value) -> avector
        """
        this = _sim2dlong.new_avector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" :
        """push_back(avector self, atomgroup x)"""
        return _sim2dlong.avector_push_back(self, *args)

    def front(self) -> "std::vector< atomgroup * >::value_type" :
        """front(avector self) -> atomgroup"""
        return _sim2dlong.avector_front(self)

    def back(self) -> "std::vector< atomgroup * >::value_type" :
        """back(avector self) -> atomgroup"""
        return _sim2dlong.avector_back(self)

    def assign(self, *args) -> "void" :
        """assign(avector self, std::vector< atomgroup * >::size_type n, atomgroup x)"""
        return _sim2dlong.avector_assign(self, *args)

    def resize(self, *args) -> "void" :
        """
        resize(avector self, std::vector< atomgroup * >::size_type new_size)
        resize(avector self, std::vector< atomgroup * >::size_type new_size, atomgroup x)
        """
        return _sim2dlong.avector_resize(self, *args)

    def insert(self, *args) -> "void" :
        """
        insert(avector self, std::vector< atomgroup * >::iterator pos, atomgroup x) -> std::vector< atomgroup * >::iterator
        insert(avector self, std::vector< atomgroup * >::iterator pos, std::vector< atomgroup * >::size_type n, 
            atomgroup x)
        """
        return _sim2dlong.avector_insert(self, *args)

    def reserve(self, *args) -> "void" :
        """reserve(avector self, std::vector< atomgroup * >::size_type n)"""
        return _sim2dlong.avector_reserve(self, *args)

    def capacity(self) -> "std::vector< atomgroup * >::size_type" :
        """capacity(avector self) -> std::vector< atomgroup * >::size_type"""
        return _sim2dlong.avector_capacity(self)

    __swig_destroy__ = _sim2dlong.delete_avector
    __del__ = lambda self : None;
avector_swigregister = _sim2dlong.avector_swigregister
avector_swigregister(avector)

class aptrvector(_object):
    """Proxy of C++ std::vector<(p.atom)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, aptrvector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, aptrvector, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" :
        """iterator(aptrvector self) -> SwigPyIterator"""
        return _sim2dlong.aptrvector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" :
        """__nonzero__(aptrvector self) -> bool"""
        return _sim2dlong.aptrvector___nonzero__(self)

    def __bool__(self) -> "bool" :
        """__bool__(aptrvector self) -> bool"""
        return _sim2dlong.aptrvector___bool__(self)

    def __len__(self) -> "std::vector< atom * >::size_type" :
        """__len__(aptrvector self) -> std::vector< atom * >::size_type"""
        return _sim2dlong.aptrvector___len__(self)

    def pop(self) -> "std::vector< atom * >::value_type" :
        """pop(aptrvector self) -> atom"""
        return _sim2dlong.aptrvector_pop(self)

    def __getslice__(self, *args) -> "std::vector< atom *,std::allocator< atom * > > *" :
        """__getslice__(aptrvector self, std::vector< atom * >::difference_type i, std::vector< atom * >::difference_type j) -> aptrvector"""
        return _sim2dlong.aptrvector___getslice__(self, *args)

    def __setslice__(self, *args) -> "void" :
        """
        __setslice__(aptrvector self, std::vector< atom * >::difference_type i, std::vector< atom * >::difference_type j, 
            aptrvector v=std::vector< atom *,std::allocator< atom * > >())
        __setslice__(aptrvector self, std::vector< atom * >::difference_type i, std::vector< atom * >::difference_type j)
        """
        return _sim2dlong.aptrvector___setslice__(self, *args)

    def __delslice__(self, *args) -> "void" :
        """__delslice__(aptrvector self, std::vector< atom * >::difference_type i, std::vector< atom * >::difference_type j)"""
        return _sim2dlong.aptrvector___delslice__(self, *args)

    def __delitem__(self, *args) -> "void" :
        """
        __delitem__(aptrvector self, std::vector< atom * >::difference_type i)
        __delitem__(aptrvector self, PySliceObject * slice)
        """
        return _sim2dlong.aptrvector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< atom * >::value_type" :
        """
        __getitem__(aptrvector self, PySliceObject * slice) -> aptrvector
        __getitem__(aptrvector self, std::vector< atom * >::difference_type i) -> atom
        """
        return _sim2dlong.aptrvector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void" :
        """
        __setitem__(aptrvector self, PySliceObject * slice, aptrvector v)
        __setitem__(aptrvector self, PySliceObject * slice)
        __setitem__(aptrvector self, std::vector< atom * >::difference_type i, atom x)
        """
        return _sim2dlong.aptrvector___setitem__(self, *args)

    def append(self, *args) -> "void" :
        """append(aptrvector self, atom x)"""
        return _sim2dlong.aptrvector_append(self, *args)

    def empty(self) -> "bool" :
        """empty(aptrvector self) -> bool"""
        return _sim2dlong.aptrvector_empty(self)

    def size(self) -> "std::vector< atom * >::size_type" :
        """size(aptrvector self) -> std::vector< atom * >::size_type"""
        return _sim2dlong.aptrvector_size(self)

    def clear(self) -> "void" :
        """clear(aptrvector self)"""
        return _sim2dlong.aptrvector_clear(self)

    def swap(self, *args) -> "void" :
        """swap(aptrvector self, aptrvector v)"""
        return _sim2dlong.aptrvector_swap(self, *args)

    def get_allocator(self) -> "std::vector< atom * >::allocator_type" :
        """get_allocator(aptrvector self) -> std::vector< atom * >::allocator_type"""
        return _sim2dlong.aptrvector_get_allocator(self)

    def begin(self) -> "std::vector< atom * >::iterator" :
        """begin(aptrvector self) -> std::vector< atom * >::iterator"""
        return _sim2dlong.aptrvector_begin(self)

    def end(self) -> "std::vector< atom * >::iterator" :
        """end(aptrvector self) -> std::vector< atom * >::iterator"""
        return _sim2dlong.aptrvector_end(self)

    def rbegin(self) -> "std::vector< atom * >::reverse_iterator" :
        """rbegin(aptrvector self) -> std::vector< atom * >::reverse_iterator"""
        return _sim2dlong.aptrvector_rbegin(self)

    def rend(self) -> "std::vector< atom * >::reverse_iterator" :
        """rend(aptrvector self) -> std::vector< atom * >::reverse_iterator"""
        return _sim2dlong.aptrvector_rend(self)

    def pop_back(self) -> "void" :
        """pop_back(aptrvector self)"""
        return _sim2dlong.aptrvector_pop_back(self)

    def erase(self, *args) -> "std::vector< atom * >::iterator" :
        """
        erase(aptrvector self, std::vector< atom * >::iterator pos) -> std::vector< atom * >::iterator
        erase(aptrvector self, std::vector< atom * >::iterator first, std::vector< atom * >::iterator last) -> std::vector< atom * >::iterator
        """
        return _sim2dlong.aptrvector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(p.atom)> self) -> aptrvector
        __init__(std::vector<(p.atom)> self, aptrvector arg2) -> aptrvector
        __init__(std::vector<(p.atom)> self, std::vector< atom * >::size_type size) -> aptrvector
        __init__(std::vector<(p.atom)> self, std::vector< atom * >::size_type size, atom value) -> aptrvector
        """
        this = _sim2dlong.new_aptrvector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" :
        """push_back(aptrvector self, atom x)"""
        return _sim2dlong.aptrvector_push_back(self, *args)

    def front(self) -> "std::vector< atom * >::value_type" :
        """front(aptrvector self) -> atom"""
        return _sim2dlong.aptrvector_front(self)

    def back(self) -> "std::vector< atom * >::value_type" :
        """back(aptrvector self) -> atom"""
        return _sim2dlong.aptrvector_back(self)

    def assign(self, *args) -> "void" :
        """assign(aptrvector self, std::vector< atom * >::size_type n, atom x)"""
        return _sim2dlong.aptrvector_assign(self, *args)

    def resize(self, *args) -> "void" :
        """
        resize(aptrvector self, std::vector< atom * >::size_type new_size)
        resize(aptrvector self, std::vector< atom * >::size_type new_size, atom x)
        """
        return _sim2dlong.aptrvector_resize(self, *args)

    def insert(self, *args) -> "void" :
        """
        insert(aptrvector self, std::vector< atom * >::iterator pos, atom x) -> std::vector< atom * >::iterator
        insert(aptrvector self, std::vector< atom * >::iterator pos, std::vector< atom * >::size_type n, atom x)
        """
        return _sim2dlong.aptrvector_insert(self, *args)

    def reserve(self, *args) -> "void" :
        """reserve(aptrvector self, std::vector< atom * >::size_type n)"""
        return _sim2dlong.aptrvector_reserve(self, *args)

    def capacity(self) -> "std::vector< atom * >::size_type" :
        """capacity(aptrvector self) -> std::vector< atom * >::size_type"""
        return _sim2dlong.aptrvector_capacity(self)

    __swig_destroy__ = _sim2dlong.delete_aptrvector
    __del__ = lambda self : None;
aptrvector_swigregister = _sim2dlong.aptrvector_swigregister
aptrvector_swigregister(aptrvector)

class ivector(_object):
    """Proxy of C++ std::vector<(p.interaction)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ivector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ivector, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" :
        """iterator(ivector self) -> SwigPyIterator"""
        return _sim2dlong.ivector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" :
        """__nonzero__(ivector self) -> bool"""
        return _sim2dlong.ivector___nonzero__(self)

    def __bool__(self) -> "bool" :
        """__bool__(ivector self) -> bool"""
        return _sim2dlong.ivector___bool__(self)

    def __len__(self) -> "std::vector< interaction * >::size_type" :
        """__len__(ivector self) -> std::vector< interaction * >::size_type"""
        return _sim2dlong.ivector___len__(self)

    def pop(self) -> "std::vector< interaction * >::value_type" :
        """pop(ivector self) -> interaction"""
        return _sim2dlong.ivector_pop(self)

    def __getslice__(self, *args) -> "std::vector< interaction *,std::allocator< interaction * > > *" :
        """__getslice__(ivector self, std::vector< interaction * >::difference_type i, std::vector< interaction * >::difference_type j) -> ivector"""
        return _sim2dlong.ivector___getslice__(self, *args)

    def __setslice__(self, *args) -> "void" :
        """
        __setslice__(ivector self, std::vector< interaction * >::difference_type i, std::vector< interaction * >::difference_type j, 
            ivector v=std::vector< interaction *,std::allocator< interaction * > >())
        __setslice__(ivector self, std::vector< interaction * >::difference_type i, std::vector< interaction * >::difference_type j)
        """
        return _sim2dlong.ivector___setslice__(self, *args)

    def __delslice__(self, *args) -> "void" :
        """__delslice__(ivector self, std::vector< interaction * >::difference_type i, std::vector< interaction * >::difference_type j)"""
        return _sim2dlong.ivector___delslice__(self, *args)

    def __delitem__(self, *args) -> "void" :
        """
        __delitem__(ivector self, std::vector< interaction * >::difference_type i)
        __delitem__(ivector self, PySliceObject * slice)
        """
        return _sim2dlong.ivector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< interaction * >::value_type" :
        """
        __getitem__(ivector self, PySliceObject * slice) -> ivector
        __getitem__(ivector self, std::vector< interaction * >::difference_type i) -> interaction
        """
        return _sim2dlong.ivector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void" :
        """
        __setitem__(ivector self, PySliceObject * slice, ivector v)
        __setitem__(ivector self, PySliceObject * slice)
        __setitem__(ivector self, std::vector< interaction * >::difference_type i, interaction x)
        """
        return _sim2dlong.ivector___setitem__(self, *args)

    def append(self, *args) -> "void" :
        """append(ivector self, interaction x)"""
        return _sim2dlong.ivector_append(self, *args)

    def empty(self) -> "bool" :
        """empty(ivector self) -> bool"""
        return _sim2dlong.ivector_empty(self)

    def size(self) -> "std::vector< interaction * >::size_type" :
        """size(ivector self) -> std::vector< interaction * >::size_type"""
        return _sim2dlong.ivector_size(self)

    def clear(self) -> "void" :
        """clear(ivector self)"""
        return _sim2dlong.ivector_clear(self)

    def swap(self, *args) -> "void" :
        """swap(ivector self, ivector v)"""
        return _sim2dlong.ivector_swap(self, *args)

    def get_allocator(self) -> "std::vector< interaction * >::allocator_type" :
        """get_allocator(ivector self) -> std::vector< interaction * >::allocator_type"""
        return _sim2dlong.ivector_get_allocator(self)

    def begin(self) -> "std::vector< interaction * >::iterator" :
        """begin(ivector self) -> std::vector< interaction * >::iterator"""
        return _sim2dlong.ivector_begin(self)

    def end(self) -> "std::vector< interaction * >::iterator" :
        """end(ivector self) -> std::vector< interaction * >::iterator"""
        return _sim2dlong.ivector_end(self)

    def rbegin(self) -> "std::vector< interaction * >::reverse_iterator" :
        """rbegin(ivector self) -> std::vector< interaction * >::reverse_iterator"""
        return _sim2dlong.ivector_rbegin(self)

    def rend(self) -> "std::vector< interaction * >::reverse_iterator" :
        """rend(ivector self) -> std::vector< interaction * >::reverse_iterator"""
        return _sim2dlong.ivector_rend(self)

    def pop_back(self) -> "void" :
        """pop_back(ivector self)"""
        return _sim2dlong.ivector_pop_back(self)

    def erase(self, *args) -> "std::vector< interaction * >::iterator" :
        """
        erase(ivector self, std::vector< interaction * >::iterator pos) -> std::vector< interaction * >::iterator
        erase(ivector self, std::vector< interaction * >::iterator first, std::vector< interaction * >::iterator last) -> std::vector< interaction * >::iterator
        """
        return _sim2dlong.ivector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(p.interaction)> self) -> ivector
        __init__(std::vector<(p.interaction)> self, ivector arg2) -> ivector
        __init__(std::vector<(p.interaction)> self, std::vector< interaction * >::size_type size) -> ivector
        __init__(std::vector<(p.interaction)> self, std::vector< interaction * >::size_type size, interaction value) -> ivector
        """
        this = _sim2dlong.new_ivector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" :
        """push_back(ivector self, interaction x)"""
        return _sim2dlong.ivector_push_back(self, *args)

    def front(self) -> "std::vector< interaction * >::value_type" :
        """front(ivector self) -> interaction"""
        return _sim2dlong.ivector_front(self)

    def back(self) -> "std::vector< interaction * >::value_type" :
        """back(ivector self) -> interaction"""
        return _sim2dlong.ivector_back(self)

    def assign(self, *args) -> "void" :
        """assign(ivector self, std::vector< interaction * >::size_type n, interaction x)"""
        return _sim2dlong.ivector_assign(self, *args)

    def resize(self, *args) -> "void" :
        """
        resize(ivector self, std::vector< interaction * >::size_type new_size)
        resize(ivector self, std::vector< interaction * >::size_type new_size, interaction x)
        """
        return _sim2dlong.ivector_resize(self, *args)

    def insert(self, *args) -> "void" :
        """
        insert(ivector self, std::vector< interaction * >::iterator pos, interaction x) -> std::vector< interaction * >::iterator
        insert(ivector self, std::vector< interaction * >::iterator pos, std::vector< interaction * >::size_type n, 
            interaction x)
        """
        return _sim2dlong.ivector_insert(self, *args)

    def reserve(self, *args) -> "void" :
        """reserve(ivector self, std::vector< interaction * >::size_type n)"""
        return _sim2dlong.ivector_reserve(self, *args)

    def capacity(self) -> "std::vector< interaction * >::size_type" :
        """capacity(ivector self) -> std::vector< interaction * >::size_type"""
        return _sim2dlong.ivector_capacity(self)

    __swig_destroy__ = _sim2dlong.delete_ivector
    __del__ = lambda self : None;
ivector_swigregister = _sim2dlong.ivector_swigregister
ivector_swigregister(ivector)

class ifxvector(_object):
    """Proxy of C++ std::vector<(p.interactionpairsx)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ifxvector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ifxvector, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" :
        """iterator(ifxvector self) -> SwigPyIterator"""
        return _sim2dlong.ifxvector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" :
        """__nonzero__(ifxvector self) -> bool"""
        return _sim2dlong.ifxvector___nonzero__(self)

    def __bool__(self) -> "bool" :
        """__bool__(ifxvector self) -> bool"""
        return _sim2dlong.ifxvector___bool__(self)

    def __len__(self) -> "std::vector< interactionpairsx * >::size_type" :
        """__len__(ifxvector self) -> std::vector< interactionpairsx * >::size_type"""
        return _sim2dlong.ifxvector___len__(self)

    def pop(self) -> "std::vector< interactionpairsx * >::value_type" :
        """pop(ifxvector self) -> interactionpairsx"""
        return _sim2dlong.ifxvector_pop(self)

    def __getslice__(self, *args) -> "std::vector< interactionpairsx *,std::allocator< interactionpairsx * > > *" :
        """__getslice__(ifxvector self, std::vector< interactionpairsx * >::difference_type i, std::vector< interactionpairsx * >::difference_type j) -> ifxvector"""
        return _sim2dlong.ifxvector___getslice__(self, *args)

    def __setslice__(self, *args) -> "void" :
        """
        __setslice__(ifxvector self, std::vector< interactionpairsx * >::difference_type i, std::vector< interactionpairsx * >::difference_type j, 
            ifxvector v=std::vector< interactionpairsx *,std::allocator< interactionpairsx * > >())
        __setslice__(ifxvector self, std::vector< interactionpairsx * >::difference_type i, std::vector< interactionpairsx * >::difference_type j)
        """
        return _sim2dlong.ifxvector___setslice__(self, *args)

    def __delslice__(self, *args) -> "void" :
        """__delslice__(ifxvector self, std::vector< interactionpairsx * >::difference_type i, std::vector< interactionpairsx * >::difference_type j)"""
        return _sim2dlong.ifxvector___delslice__(self, *args)

    def __delitem__(self, *args) -> "void" :
        """
        __delitem__(ifxvector self, std::vector< interactionpairsx * >::difference_type i)
        __delitem__(ifxvector self, PySliceObject * slice)
        """
        return _sim2dlong.ifxvector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< interactionpairsx * >::value_type" :
        """
        __getitem__(ifxvector self, PySliceObject * slice) -> ifxvector
        __getitem__(ifxvector self, std::vector< interactionpairsx * >::difference_type i) -> interactionpairsx
        """
        return _sim2dlong.ifxvector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void" :
        """
        __setitem__(ifxvector self, PySliceObject * slice, ifxvector v)
        __setitem__(ifxvector self, PySliceObject * slice)
        __setitem__(ifxvector self, std::vector< interactionpairsx * >::difference_type i, interactionpairsx x)
        """
        return _sim2dlong.ifxvector___setitem__(self, *args)

    def append(self, *args) -> "void" :
        """append(ifxvector self, interactionpairsx x)"""
        return _sim2dlong.ifxvector_append(self, *args)

    def empty(self) -> "bool" :
        """empty(ifxvector self) -> bool"""
        return _sim2dlong.ifxvector_empty(self)

    def size(self) -> "std::vector< interactionpairsx * >::size_type" :
        """size(ifxvector self) -> std::vector< interactionpairsx * >::size_type"""
        return _sim2dlong.ifxvector_size(self)

    def clear(self) -> "void" :
        """clear(ifxvector self)"""
        return _sim2dlong.ifxvector_clear(self)

    def swap(self, *args) -> "void" :
        """swap(ifxvector self, ifxvector v)"""
        return _sim2dlong.ifxvector_swap(self, *args)

    def get_allocator(self) -> "std::vector< interactionpairsx * >::allocator_type" :
        """get_allocator(ifxvector self) -> std::vector< interactionpairsx * >::allocator_type"""
        return _sim2dlong.ifxvector_get_allocator(self)

    def begin(self) -> "std::vector< interactionpairsx * >::iterator" :
        """begin(ifxvector self) -> std::vector< interactionpairsx * >::iterator"""
        return _sim2dlong.ifxvector_begin(self)

    def end(self) -> "std::vector< interactionpairsx * >::iterator" :
        """end(ifxvector self) -> std::vector< interactionpairsx * >::iterator"""
        return _sim2dlong.ifxvector_end(self)

    def rbegin(self) -> "std::vector< interactionpairsx * >::reverse_iterator" :
        """rbegin(ifxvector self) -> std::vector< interactionpairsx * >::reverse_iterator"""
        return _sim2dlong.ifxvector_rbegin(self)

    def rend(self) -> "std::vector< interactionpairsx * >::reverse_iterator" :
        """rend(ifxvector self) -> std::vector< interactionpairsx * >::reverse_iterator"""
        return _sim2dlong.ifxvector_rend(self)

    def pop_back(self) -> "void" :
        """pop_back(ifxvector self)"""
        return _sim2dlong.ifxvector_pop_back(self)

    def erase(self, *args) -> "std::vector< interactionpairsx * >::iterator" :
        """
        erase(ifxvector self, std::vector< interactionpairsx * >::iterator pos) -> std::vector< interactionpairsx * >::iterator
        erase(ifxvector self, std::vector< interactionpairsx * >::iterator first, std::vector< interactionpairsx * >::iterator last) -> std::vector< interactionpairsx * >::iterator
        """
        return _sim2dlong.ifxvector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(p.interactionpairsx)> self) -> ifxvector
        __init__(std::vector<(p.interactionpairsx)> self, ifxvector arg2) -> ifxvector
        __init__(std::vector<(p.interactionpairsx)> self, std::vector< interactionpairsx * >::size_type size) -> ifxvector
        __init__(std::vector<(p.interactionpairsx)> self, std::vector< interactionpairsx * >::size_type size, interactionpairsx value) -> ifxvector
        """
        this = _sim2dlong.new_ifxvector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" :
        """push_back(ifxvector self, interactionpairsx x)"""
        return _sim2dlong.ifxvector_push_back(self, *args)

    def front(self) -> "std::vector< interactionpairsx * >::value_type" :
        """front(ifxvector self) -> interactionpairsx"""
        return _sim2dlong.ifxvector_front(self)

    def back(self) -> "std::vector< interactionpairsx * >::value_type" :
        """back(ifxvector self) -> interactionpairsx"""
        return _sim2dlong.ifxvector_back(self)

    def assign(self, *args) -> "void" :
        """assign(ifxvector self, std::vector< interactionpairsx * >::size_type n, interactionpairsx x)"""
        return _sim2dlong.ifxvector_assign(self, *args)

    def resize(self, *args) -> "void" :
        """
        resize(ifxvector self, std::vector< interactionpairsx * >::size_type new_size)
        resize(ifxvector self, std::vector< interactionpairsx * >::size_type new_size, interactionpairsx x)
        """
        return _sim2dlong.ifxvector_resize(self, *args)

    def insert(self, *args) -> "void" :
        """
        insert(ifxvector self, std::vector< interactionpairsx * >::iterator pos, interactionpairsx x) -> std::vector< interactionpairsx * >::iterator
        insert(ifxvector self, std::vector< interactionpairsx * >::iterator pos, std::vector< interactionpairsx * >::size_type n, 
            interactionpairsx x)
        """
        return _sim2dlong.ifxvector_insert(self, *args)

    def reserve(self, *args) -> "void" :
        """reserve(ifxvector self, std::vector< interactionpairsx * >::size_type n)"""
        return _sim2dlong.ifxvector_reserve(self, *args)

    def capacity(self) -> "std::vector< interactionpairsx * >::size_type" :
        """capacity(ifxvector self) -> std::vector< interactionpairsx * >::size_type"""
        return _sim2dlong.ifxvector_capacity(self)

    __swig_destroy__ = _sim2dlong.delete_ifxvector
    __del__ = lambda self : None;
ifxvector_swigregister = _sim2dlong.ifxvector_swigregister
ifxvector_swigregister(ifxvector)

class tvector(_object):
    """Proxy of C++ std::vector<(p.statetracker)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, tvector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, tvector, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" :
        """iterator(tvector self) -> SwigPyIterator"""
        return _sim2dlong.tvector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" :
        """__nonzero__(tvector self) -> bool"""
        return _sim2dlong.tvector___nonzero__(self)

    def __bool__(self) -> "bool" :
        """__bool__(tvector self) -> bool"""
        return _sim2dlong.tvector___bool__(self)

    def __len__(self) -> "std::vector< statetracker * >::size_type" :
        """__len__(tvector self) -> std::vector< statetracker * >::size_type"""
        return _sim2dlong.tvector___len__(self)

    def pop(self) -> "std::vector< statetracker * >::value_type" :
        """pop(tvector self) -> statetracker"""
        return _sim2dlong.tvector_pop(self)

    def __getslice__(self, *args) -> "std::vector< statetracker *,std::allocator< statetracker * > > *" :
        """__getslice__(tvector self, std::vector< statetracker * >::difference_type i, std::vector< statetracker * >::difference_type j) -> tvector"""
        return _sim2dlong.tvector___getslice__(self, *args)

    def __setslice__(self, *args) -> "void" :
        """
        __setslice__(tvector self, std::vector< statetracker * >::difference_type i, std::vector< statetracker * >::difference_type j, 
            tvector v=std::vector< statetracker *,std::allocator< statetracker * > >())
        __setslice__(tvector self, std::vector< statetracker * >::difference_type i, std::vector< statetracker * >::difference_type j)
        """
        return _sim2dlong.tvector___setslice__(self, *args)

    def __delslice__(self, *args) -> "void" :
        """__delslice__(tvector self, std::vector< statetracker * >::difference_type i, std::vector< statetracker * >::difference_type j)"""
        return _sim2dlong.tvector___delslice__(self, *args)

    def __delitem__(self, *args) -> "void" :
        """
        __delitem__(tvector self, std::vector< statetracker * >::difference_type i)
        __delitem__(tvector self, PySliceObject * slice)
        """
        return _sim2dlong.tvector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< statetracker * >::value_type" :
        """
        __getitem__(tvector self, PySliceObject * slice) -> tvector
        __getitem__(tvector self, std::vector< statetracker * >::difference_type i) -> statetracker
        """
        return _sim2dlong.tvector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void" :
        """
        __setitem__(tvector self, PySliceObject * slice, tvector v)
        __setitem__(tvector self, PySliceObject * slice)
        __setitem__(tvector self, std::vector< statetracker * >::difference_type i, statetracker x)
        """
        return _sim2dlong.tvector___setitem__(self, *args)

    def append(self, *args) -> "void" :
        """append(tvector self, statetracker x)"""
        return _sim2dlong.tvector_append(self, *args)

    def empty(self) -> "bool" :
        """empty(tvector self) -> bool"""
        return _sim2dlong.tvector_empty(self)

    def size(self) -> "std::vector< statetracker * >::size_type" :
        """size(tvector self) -> std::vector< statetracker * >::size_type"""
        return _sim2dlong.tvector_size(self)

    def clear(self) -> "void" :
        """clear(tvector self)"""
        return _sim2dlong.tvector_clear(self)

    def swap(self, *args) -> "void" :
        """swap(tvector self, tvector v)"""
        return _sim2dlong.tvector_swap(self, *args)

    def get_allocator(self) -> "std::vector< statetracker * >::allocator_type" :
        """get_allocator(tvector self) -> std::vector< statetracker * >::allocator_type"""
        return _sim2dlong.tvector_get_allocator(self)

    def begin(self) -> "std::vector< statetracker * >::iterator" :
        """begin(tvector self) -> std::vector< statetracker * >::iterator"""
        return _sim2dlong.tvector_begin(self)

    def end(self) -> "std::vector< statetracker * >::iterator" :
        """end(tvector self) -> std::vector< statetracker * >::iterator"""
        return _sim2dlong.tvector_end(self)

    def rbegin(self) -> "std::vector< statetracker * >::reverse_iterator" :
        """rbegin(tvector self) -> std::vector< statetracker * >::reverse_iterator"""
        return _sim2dlong.tvector_rbegin(self)

    def rend(self) -> "std::vector< statetracker * >::reverse_iterator" :
        """rend(tvector self) -> std::vector< statetracker * >::reverse_iterator"""
        return _sim2dlong.tvector_rend(self)

    def pop_back(self) -> "void" :
        """pop_back(tvector self)"""
        return _sim2dlong.tvector_pop_back(self)

    def erase(self, *args) -> "std::vector< statetracker * >::iterator" :
        """
        erase(tvector self, std::vector< statetracker * >::iterator pos) -> std::vector< statetracker * >::iterator
        erase(tvector self, std::vector< statetracker * >::iterator first, std::vector< statetracker * >::iterator last) -> std::vector< statetracker * >::iterator
        """
        return _sim2dlong.tvector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(p.statetracker)> self) -> tvector
        __init__(std::vector<(p.statetracker)> self, tvector arg2) -> tvector
        __init__(std::vector<(p.statetracker)> self, std::vector< statetracker * >::size_type size) -> tvector
        __init__(std::vector<(p.statetracker)> self, std::vector< statetracker * >::size_type size, statetracker value) -> tvector
        """
        this = _sim2dlong.new_tvector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" :
        """push_back(tvector self, statetracker x)"""
        return _sim2dlong.tvector_push_back(self, *args)

    def front(self) -> "std::vector< statetracker * >::value_type" :
        """front(tvector self) -> statetracker"""
        return _sim2dlong.tvector_front(self)

    def back(self) -> "std::vector< statetracker * >::value_type" :
        """back(tvector self) -> statetracker"""
        return _sim2dlong.tvector_back(self)

    def assign(self, *args) -> "void" :
        """assign(tvector self, std::vector< statetracker * >::size_type n, statetracker x)"""
        return _sim2dlong.tvector_assign(self, *args)

    def resize(self, *args) -> "void" :
        """
        resize(tvector self, std::vector< statetracker * >::size_type new_size)
        resize(tvector self, std::vector< statetracker * >::size_type new_size, statetracker x)
        """
        return _sim2dlong.tvector_resize(self, *args)

    def insert(self, *args) -> "void" :
        """
        insert(tvector self, std::vector< statetracker * >::iterator pos, statetracker x) -> std::vector< statetracker * >::iterator
        insert(tvector self, std::vector< statetracker * >::iterator pos, std::vector< statetracker * >::size_type n, 
            statetracker x)
        """
        return _sim2dlong.tvector_insert(self, *args)

    def reserve(self, *args) -> "void" :
        """reserve(tvector self, std::vector< statetracker * >::size_type n)"""
        return _sim2dlong.tvector_reserve(self, *args)

    def capacity(self) -> "std::vector< statetracker * >::size_type" :
        """capacity(tvector self) -> std::vector< statetracker * >::size_type"""
        return _sim2dlong.tvector_capacity(self)

    __swig_destroy__ = _sim2dlong.delete_tvector
    __del__ = lambda self : None;
tvector_swigregister = _sim2dlong.tvector_swigregister
tvector_swigregister(tvector)

class constraintvector(_object):
    """Proxy of C++ std::vector<(p.constraint)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, constraintvector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, constraintvector, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" :
        """iterator(constraintvector self) -> SwigPyIterator"""
        return _sim2dlong.constraintvector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" :
        """__nonzero__(constraintvector self) -> bool"""
        return _sim2dlong.constraintvector___nonzero__(self)

    def __bool__(self) -> "bool" :
        """__bool__(constraintvector self) -> bool"""
        return _sim2dlong.constraintvector___bool__(self)

    def __len__(self) -> "std::vector< constraint * >::size_type" :
        """__len__(constraintvector self) -> std::vector< constraint * >::size_type"""
        return _sim2dlong.constraintvector___len__(self)

    def pop(self) -> "std::vector< constraint * >::value_type" :
        """pop(constraintvector self) -> constraint"""
        return _sim2dlong.constraintvector_pop(self)

    def __getslice__(self, *args) -> "std::vector< constraint *,std::allocator< constraint * > > *" :
        """__getslice__(constraintvector self, std::vector< constraint * >::difference_type i, std::vector< constraint * >::difference_type j) -> constraintvector"""
        return _sim2dlong.constraintvector___getslice__(self, *args)

    def __setslice__(self, *args) -> "void" :
        """
        __setslice__(constraintvector self, std::vector< constraint * >::difference_type i, std::vector< constraint * >::difference_type j, 
            constraintvector v=std::vector< constraint *,std::allocator< constraint * > >())
        __setslice__(constraintvector self, std::vector< constraint * >::difference_type i, std::vector< constraint * >::difference_type j)
        """
        return _sim2dlong.constraintvector___setslice__(self, *args)

    def __delslice__(self, *args) -> "void" :
        """__delslice__(constraintvector self, std::vector< constraint * >::difference_type i, std::vector< constraint * >::difference_type j)"""
        return _sim2dlong.constraintvector___delslice__(self, *args)

    def __delitem__(self, *args) -> "void" :
        """
        __delitem__(constraintvector self, std::vector< constraint * >::difference_type i)
        __delitem__(constraintvector self, PySliceObject * slice)
        """
        return _sim2dlong.constraintvector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< constraint * >::value_type" :
        """
        __getitem__(constraintvector self, PySliceObject * slice) -> constraintvector
        __getitem__(constraintvector self, std::vector< constraint * >::difference_type i) -> constraint
        """
        return _sim2dlong.constraintvector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void" :
        """
        __setitem__(constraintvector self, PySliceObject * slice, constraintvector v)
        __setitem__(constraintvector self, PySliceObject * slice)
        __setitem__(constraintvector self, std::vector< constraint * >::difference_type i, constraint x)
        """
        return _sim2dlong.constraintvector___setitem__(self, *args)

    def append(self, *args) -> "void" :
        """append(constraintvector self, constraint x)"""
        return _sim2dlong.constraintvector_append(self, *args)

    def empty(self) -> "bool" :
        """empty(constraintvector self) -> bool"""
        return _sim2dlong.constraintvector_empty(self)

    def size(self) -> "std::vector< constraint * >::size_type" :
        """size(constraintvector self) -> std::vector< constraint * >::size_type"""
        return _sim2dlong.constraintvector_size(self)

    def clear(self) -> "void" :
        """clear(constraintvector self)"""
        return _sim2dlong.constraintvector_clear(self)

    def swap(self, *args) -> "void" :
        """swap(constraintvector self, constraintvector v)"""
        return _sim2dlong.constraintvector_swap(self, *args)

    def get_allocator(self) -> "std::vector< constraint * >::allocator_type" :
        """get_allocator(constraintvector self) -> std::vector< constraint * >::allocator_type"""
        return _sim2dlong.constraintvector_get_allocator(self)

    def begin(self) -> "std::vector< constraint * >::iterator" :
        """begin(constraintvector self) -> std::vector< constraint * >::iterator"""
        return _sim2dlong.constraintvector_begin(self)

    def end(self) -> "std::vector< constraint * >::iterator" :
        """end(constraintvector self) -> std::vector< constraint * >::iterator"""
        return _sim2dlong.constraintvector_end(self)

    def rbegin(self) -> "std::vector< constraint * >::reverse_iterator" :
        """rbegin(constraintvector self) -> std::vector< constraint * >::reverse_iterator"""
        return _sim2dlong.constraintvector_rbegin(self)

    def rend(self) -> "std::vector< constraint * >::reverse_iterator" :
        """rend(constraintvector self) -> std::vector< constraint * >::reverse_iterator"""
        return _sim2dlong.constraintvector_rend(self)

    def pop_back(self) -> "void" :
        """pop_back(constraintvector self)"""
        return _sim2dlong.constraintvector_pop_back(self)

    def erase(self, *args) -> "std::vector< constraint * >::iterator" :
        """
        erase(constraintvector self, std::vector< constraint * >::iterator pos) -> std::vector< constraint * >::iterator
        erase(constraintvector self, std::vector< constraint * >::iterator first, std::vector< constraint * >::iterator last) -> std::vector< constraint * >::iterator
        """
        return _sim2dlong.constraintvector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(p.constraint)> self) -> constraintvector
        __init__(std::vector<(p.constraint)> self, constraintvector arg2) -> constraintvector
        __init__(std::vector<(p.constraint)> self, std::vector< constraint * >::size_type size) -> constraintvector
        __init__(std::vector<(p.constraint)> self, std::vector< constraint * >::size_type size, constraint value) -> constraintvector
        """
        this = _sim2dlong.new_constraintvector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" :
        """push_back(constraintvector self, constraint x)"""
        return _sim2dlong.constraintvector_push_back(self, *args)

    def front(self) -> "std::vector< constraint * >::value_type" :
        """front(constraintvector self) -> constraint"""
        return _sim2dlong.constraintvector_front(self)

    def back(self) -> "std::vector< constraint * >::value_type" :
        """back(constraintvector self) -> constraint"""
        return _sim2dlong.constraintvector_back(self)

    def assign(self, *args) -> "void" :
        """assign(constraintvector self, std::vector< constraint * >::size_type n, constraint x)"""
        return _sim2dlong.constraintvector_assign(self, *args)

    def resize(self, *args) -> "void" :
        """
        resize(constraintvector self, std::vector< constraint * >::size_type new_size)
        resize(constraintvector self, std::vector< constraint * >::size_type new_size, constraint x)
        """
        return _sim2dlong.constraintvector_resize(self, *args)

    def insert(self, *args) -> "void" :
        """
        insert(constraintvector self, std::vector< constraint * >::iterator pos, constraint x) -> std::vector< constraint * >::iterator
        insert(constraintvector self, std::vector< constraint * >::iterator pos, std::vector< constraint * >::size_type n, 
            constraint x)
        """
        return _sim2dlong.constraintvector_insert(self, *args)

    def reserve(self, *args) -> "void" :
        """reserve(constraintvector self, std::vector< constraint * >::size_type n)"""
        return _sim2dlong.constraintvector_reserve(self, *args)

    def capacity(self) -> "std::vector< constraint * >::size_type" :
        """capacity(constraintvector self) -> std::vector< constraint * >::size_type"""
        return _sim2dlong.constraintvector_capacity(self)

    __swig_destroy__ = _sim2dlong.delete_constraintvector
    __del__ = lambda self : None;
constraintvector_swigregister = _sim2dlong.constraintvector_swigregister
constraintvector_swigregister(constraintvector)

class aRK4vector(_object):
    """Proxy of C++ std::vector<(p.atomvecRK4)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, aRK4vector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, aRK4vector, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" :
        """iterator(aRK4vector self) -> SwigPyIterator"""
        return _sim2dlong.aRK4vector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" :
        """__nonzero__(aRK4vector self) -> bool"""
        return _sim2dlong.aRK4vector___nonzero__(self)

    def __bool__(self) -> "bool" :
        """__bool__(aRK4vector self) -> bool"""
        return _sim2dlong.aRK4vector___bool__(self)

    def __len__(self) -> "std::vector< atomvecRK4 * >::size_type" :
        """__len__(aRK4vector self) -> std::vector< atomvecRK4 * >::size_type"""
        return _sim2dlong.aRK4vector___len__(self)

    def pop(self) -> "std::vector< atomvecRK4 * >::value_type" :
        """pop(aRK4vector self) -> atomvecRK4"""
        return _sim2dlong.aRK4vector_pop(self)

    def __getslice__(self, *args) -> "std::vector< atomvecRK4 *,std::allocator< atomvecRK4 * > > *" :
        """__getslice__(aRK4vector self, std::vector< atomvecRK4 * >::difference_type i, std::vector< atomvecRK4 * >::difference_type j) -> aRK4vector"""
        return _sim2dlong.aRK4vector___getslice__(self, *args)

    def __setslice__(self, *args) -> "void" :
        """
        __setslice__(aRK4vector self, std::vector< atomvecRK4 * >::difference_type i, std::vector< atomvecRK4 * >::difference_type j, 
            aRK4vector v=std::vector< atomvecRK4 *,std::allocator< atomvecRK4 * > >())
        __setslice__(aRK4vector self, std::vector< atomvecRK4 * >::difference_type i, std::vector< atomvecRK4 * >::difference_type j)
        """
        return _sim2dlong.aRK4vector___setslice__(self, *args)

    def __delslice__(self, *args) -> "void" :
        """__delslice__(aRK4vector self, std::vector< atomvecRK4 * >::difference_type i, std::vector< atomvecRK4 * >::difference_type j)"""
        return _sim2dlong.aRK4vector___delslice__(self, *args)

    def __delitem__(self, *args) -> "void" :
        """
        __delitem__(aRK4vector self, std::vector< atomvecRK4 * >::difference_type i)
        __delitem__(aRK4vector self, PySliceObject * slice)
        """
        return _sim2dlong.aRK4vector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< atomvecRK4 * >::value_type" :
        """
        __getitem__(aRK4vector self, PySliceObject * slice) -> aRK4vector
        __getitem__(aRK4vector self, std::vector< atomvecRK4 * >::difference_type i) -> atomvecRK4
        """
        return _sim2dlong.aRK4vector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void" :
        """
        __setitem__(aRK4vector self, PySliceObject * slice, aRK4vector v)
        __setitem__(aRK4vector self, PySliceObject * slice)
        __setitem__(aRK4vector self, std::vector< atomvecRK4 * >::difference_type i, atomvecRK4 x)
        """
        return _sim2dlong.aRK4vector___setitem__(self, *args)

    def append(self, *args) -> "void" :
        """append(aRK4vector self, atomvecRK4 x)"""
        return _sim2dlong.aRK4vector_append(self, *args)

    def empty(self) -> "bool" :
        """empty(aRK4vector self) -> bool"""
        return _sim2dlong.aRK4vector_empty(self)

    def size(self) -> "std::vector< atomvecRK4 * >::size_type" :
        """size(aRK4vector self) -> std::vector< atomvecRK4 * >::size_type"""
        return _sim2dlong.aRK4vector_size(self)

    def clear(self) -> "void" :
        """clear(aRK4vector self)"""
        return _sim2dlong.aRK4vector_clear(self)

    def swap(self, *args) -> "void" :
        """swap(aRK4vector self, aRK4vector v)"""
        return _sim2dlong.aRK4vector_swap(self, *args)

    def get_allocator(self) -> "std::vector< atomvecRK4 * >::allocator_type" :
        """get_allocator(aRK4vector self) -> std::vector< atomvecRK4 * >::allocator_type"""
        return _sim2dlong.aRK4vector_get_allocator(self)

    def begin(self) -> "std::vector< atomvecRK4 * >::iterator" :
        """begin(aRK4vector self) -> std::vector< atomvecRK4 * >::iterator"""
        return _sim2dlong.aRK4vector_begin(self)

    def end(self) -> "std::vector< atomvecRK4 * >::iterator" :
        """end(aRK4vector self) -> std::vector< atomvecRK4 * >::iterator"""
        return _sim2dlong.aRK4vector_end(self)

    def rbegin(self) -> "std::vector< atomvecRK4 * >::reverse_iterator" :
        """rbegin(aRK4vector self) -> std::vector< atomvecRK4 * >::reverse_iterator"""
        return _sim2dlong.aRK4vector_rbegin(self)

    def rend(self) -> "std::vector< atomvecRK4 * >::reverse_iterator" :
        """rend(aRK4vector self) -> std::vector< atomvecRK4 * >::reverse_iterator"""
        return _sim2dlong.aRK4vector_rend(self)

    def pop_back(self) -> "void" :
        """pop_back(aRK4vector self)"""
        return _sim2dlong.aRK4vector_pop_back(self)

    def erase(self, *args) -> "std::vector< atomvecRK4 * >::iterator" :
        """
        erase(aRK4vector self, std::vector< atomvecRK4 * >::iterator pos) -> std::vector< atomvecRK4 * >::iterator
        erase(aRK4vector self, std::vector< atomvecRK4 * >::iterator first, std::vector< atomvecRK4 * >::iterator last) -> std::vector< atomvecRK4 * >::iterator
        """
        return _sim2dlong.aRK4vector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(p.atomvecRK4)> self) -> aRK4vector
        __init__(std::vector<(p.atomvecRK4)> self, aRK4vector arg2) -> aRK4vector
        __init__(std::vector<(p.atomvecRK4)> self, std::vector< atomvecRK4 * >::size_type size) -> aRK4vector
        __init__(std::vector<(p.atomvecRK4)> self, std::vector< atomvecRK4 * >::size_type size, atomvecRK4 value) -> aRK4vector
        """
        this = _sim2dlong.new_aRK4vector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" :
        """push_back(aRK4vector self, atomvecRK4 x)"""
        return _sim2dlong.aRK4vector_push_back(self, *args)

    def front(self) -> "std::vector< atomvecRK4 * >::value_type" :
        """front(aRK4vector self) -> atomvecRK4"""
        return _sim2dlong.aRK4vector_front(self)

    def back(self) -> "std::vector< atomvecRK4 * >::value_type" :
        """back(aRK4vector self) -> atomvecRK4"""
        return _sim2dlong.aRK4vector_back(self)

    def assign(self, *args) -> "void" :
        """assign(aRK4vector self, std::vector< atomvecRK4 * >::size_type n, atomvecRK4 x)"""
        return _sim2dlong.aRK4vector_assign(self, *args)

    def resize(self, *args) -> "void" :
        """
        resize(aRK4vector self, std::vector< atomvecRK4 * >::size_type new_size)
        resize(aRK4vector self, std::vector< atomvecRK4 * >::size_type new_size, atomvecRK4 x)
        """
        return _sim2dlong.aRK4vector_resize(self, *args)

    def insert(self, *args) -> "void" :
        """
        insert(aRK4vector self, std::vector< atomvecRK4 * >::iterator pos, atomvecRK4 x) -> std::vector< atomvecRK4 * >::iterator
        insert(aRK4vector self, std::vector< atomvecRK4 * >::iterator pos, std::vector< atomvecRK4 * >::size_type n, 
            atomvecRK4 x)
        """
        return _sim2dlong.aRK4vector_insert(self, *args)

    def reserve(self, *args) -> "void" :
        """reserve(aRK4vector self, std::vector< atomvecRK4 * >::size_type n)"""
        return _sim2dlong.aRK4vector_reserve(self, *args)

    def capacity(self) -> "std::vector< atomvecRK4 * >::size_type" :
        """capacity(aRK4vector self) -> std::vector< atomvecRK4 * >::size_type"""
        return _sim2dlong.aRK4vector_capacity(self)

    __swig_destroy__ = _sim2dlong.delete_aRK4vector
    __del__ = lambda self : None;
aRK4vector_swigregister = _sim2dlong.aRK4vector_swigregister
aRK4vector_swigregister(aRK4vector)

class _uintvector(collections.MutableSequence):
    """Proxy of C++ std::vector<(unsigned int)> class"""
    __swig_setmethods__ = {}
    for _s in [collections.MutableSequence]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, _uintvector, name, value)
    __swig_getmethods__ = {}
    for _s in [collections.MutableSequence]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, _uintvector, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" :
        """iterator(_uintvector self) -> SwigPyIterator"""
        return _sim2dlong._uintvector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" :
        """__nonzero__(_uintvector self) -> bool"""
        return _sim2dlong._uintvector___nonzero__(self)

    def __bool__(self) -> "bool" :
        """__bool__(_uintvector self) -> bool"""
        return _sim2dlong._uintvector___bool__(self)

    def __len__(self) -> "std::vector< unsigned int >::size_type" :
        """__len__(_uintvector self) -> std::vector< unsigned int >::size_type"""
        return _sim2dlong._uintvector___len__(self)

    def pop(self) -> "std::vector< unsigned int >::value_type" :
        """pop(_uintvector self) -> std::vector< unsigned int >::value_type"""
        return _sim2dlong._uintvector_pop(self)

    def __getslice__(self, *args) -> "std::vector< unsigned int,std::allocator< unsigned int > > *" :
        """__getslice__(_uintvector self, std::vector< unsigned int >::difference_type i, std::vector< unsigned int >::difference_type j) -> _uintvector"""
        return _sim2dlong._uintvector___getslice__(self, *args)

    def __setslice__(self, *args) -> "void" :
        """
        __setslice__(_uintvector self, std::vector< unsigned int >::difference_type i, std::vector< unsigned int >::difference_type j, 
            _uintvector v=std::vector< unsigned int,std::allocator< unsigned int > >())
        __setslice__(_uintvector self, std::vector< unsigned int >::difference_type i, std::vector< unsigned int >::difference_type j)
        """
        return _sim2dlong._uintvector___setslice__(self, *args)

    def __delslice__(self, *args) -> "void" :
        """__delslice__(_uintvector self, std::vector< unsigned int >::difference_type i, std::vector< unsigned int >::difference_type j)"""
        return _sim2dlong._uintvector___delslice__(self, *args)

    def __delitem__(self, *args) -> "void" :
        """
        __delitem__(_uintvector self, std::vector< unsigned int >::difference_type i)
        __delitem__(_uintvector self, PySliceObject * slice)
        """
        return _sim2dlong._uintvector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< unsigned int >::value_type const &" :
        """
        __getitem__(_uintvector self, PySliceObject * slice) -> _uintvector
        __getitem__(_uintvector self, std::vector< unsigned int >::difference_type i) -> std::vector< unsigned int >::value_type const &
        """
        return _sim2dlong._uintvector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void" :
        """
        __setitem__(_uintvector self, PySliceObject * slice, _uintvector v)
        __setitem__(_uintvector self, PySliceObject * slice)
        __setitem__(_uintvector self, std::vector< unsigned int >::difference_type i, std::vector< unsigned int >::value_type const & x)
        """
        return _sim2dlong._uintvector___setitem__(self, *args)

    def append(self, *args) -> "void" :
        """append(_uintvector self, std::vector< unsigned int >::value_type const & x)"""
        return _sim2dlong._uintvector_append(self, *args)

    def empty(self) -> "bool" :
        """empty(_uintvector self) -> bool"""
        return _sim2dlong._uintvector_empty(self)

    def size(self) -> "std::vector< unsigned int >::size_type" :
        """size(_uintvector self) -> std::vector< unsigned int >::size_type"""
        return _sim2dlong._uintvector_size(self)

    def clear(self) -> "void" :
        """clear(_uintvector self)"""
        return _sim2dlong._uintvector_clear(self)

    def swap(self, *args) -> "void" :
        """swap(_uintvector self, _uintvector v)"""
        return _sim2dlong._uintvector_swap(self, *args)

    def get_allocator(self) -> "std::vector< unsigned int >::allocator_type" :
        """get_allocator(_uintvector self) -> std::vector< unsigned int >::allocator_type"""
        return _sim2dlong._uintvector_get_allocator(self)

    def begin(self) -> "std::vector< unsigned int >::iterator" :
        """begin(_uintvector self) -> std::vector< unsigned int >::iterator"""
        return _sim2dlong._uintvector_begin(self)

    def end(self) -> "std::vector< unsigned int >::iterator" :
        """end(_uintvector self) -> std::vector< unsigned int >::iterator"""
        return _sim2dlong._uintvector_end(self)

    def rbegin(self) -> "std::vector< unsigned int >::reverse_iterator" :
        """rbegin(_uintvector self) -> std::vector< unsigned int >::reverse_iterator"""
        return _sim2dlong._uintvector_rbegin(self)

    def rend(self) -> "std::vector< unsigned int >::reverse_iterator" :
        """rend(_uintvector self) -> std::vector< unsigned int >::reverse_iterator"""
        return _sim2dlong._uintvector_rend(self)

    def pop_back(self) -> "void" :
        """pop_back(_uintvector self)"""
        return _sim2dlong._uintvector_pop_back(self)

    def erase(self, *args) -> "std::vector< unsigned int >::iterator" :
        """
        erase(_uintvector self, std::vector< unsigned int >::iterator pos) -> std::vector< unsigned int >::iterator
        erase(_uintvector self, std::vector< unsigned int >::iterator first, std::vector< unsigned int >::iterator last) -> std::vector< unsigned int >::iterator
        """
        return _sim2dlong._uintvector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(unsigned int)> self) -> _uintvector
        __init__(std::vector<(unsigned int)> self, _uintvector arg2) -> _uintvector
        __init__(std::vector<(unsigned int)> self, std::vector< unsigned int >::size_type size) -> _uintvector
        __init__(std::vector<(unsigned int)> self, std::vector< unsigned int >::size_type size, std::vector< unsigned int >::value_type const & value) -> _uintvector
        """
        this = _sim2dlong.new__uintvector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" :
        """push_back(_uintvector self, std::vector< unsigned int >::value_type const & x)"""
        return _sim2dlong._uintvector_push_back(self, *args)

    def front(self) -> "std::vector< unsigned int >::value_type const &" :
        """front(_uintvector self) -> std::vector< unsigned int >::value_type const &"""
        return _sim2dlong._uintvector_front(self)

    def back(self) -> "std::vector< unsigned int >::value_type const &" :
        """back(_uintvector self) -> std::vector< unsigned int >::value_type const &"""
        return _sim2dlong._uintvector_back(self)

    def assign(self, *args) -> "void" :
        """assign(_uintvector self, std::vector< unsigned int >::size_type n, std::vector< unsigned int >::value_type const & x)"""
        return _sim2dlong._uintvector_assign(self, *args)

    def resize(self, *args) -> "void" :
        """
        resize(_uintvector self, std::vector< unsigned int >::size_type new_size)
        resize(_uintvector self, std::vector< unsigned int >::size_type new_size, std::vector< unsigned int >::value_type const & x)
        """
        return _sim2dlong._uintvector_resize(self, *args)

    def insert(self, *args) -> "void" :
        """
        insert(_uintvector self, std::vector< unsigned int >::iterator pos, std::vector< unsigned int >::value_type const & x) -> std::vector< unsigned int >::iterator
        insert(_uintvector self, std::vector< unsigned int >::iterator pos, std::vector< unsigned int >::size_type n, 
            std::vector< unsigned int >::value_type const & x)
        """
        return _sim2dlong._uintvector_insert(self, *args)

    def reserve(self, *args) -> "void" :
        """reserve(_uintvector self, std::vector< unsigned int >::size_type n)"""
        return _sim2dlong._uintvector_reserve(self, *args)

    def capacity(self) -> "std::vector< unsigned int >::size_type" :
        """capacity(_uintvector self) -> std::vector< unsigned int >::size_type"""
        return _sim2dlong._uintvector_capacity(self)

    __swig_destroy__ = _sim2dlong.delete__uintvector
    __del__ = lambda self : None;
_uintvector_swigregister = _sim2dlong._uintvector_swigregister
_uintvector_swigregister(_uintvector)

NDIM = _sim2dlong.NDIM

def toLD(*args) -> "long double" :
  """toLD(double e) -> long double"""
  return _sim2dlong.toLD(*args)

def fromLD(*args) -> "double" :
  """fromLD(long double e) -> double"""
  return _sim2dlong.fromLD(*args)

def LDVector(*args) -> "std::vector< flt,std::allocator< flt > >" :
  """LDVector(dvector dists) -> ldvector"""
  return _sim2dlong.LDVector(*args)

def isinfflt(*args) -> "bool" :
  """isinfflt(long double n) -> bool"""
  return _sim2dlong.isinfflt(*args)

def isnanflt(*args) -> "bool" :
  """isnanflt(long double n) -> bool"""
  return _sim2dlong.isnanflt(*args)

def powflt(*args) -> "flt" :
  """powflt(flt n, flt m) -> flt"""
  return _sim2dlong.powflt(*args)

def sqrtflt(*args) -> "flt" :
  """sqrtflt(flt n) -> flt"""
  return _sim2dlong.sqrtflt(*args)

def cbrtflt(*args) -> "flt" :
  """cbrtflt(flt n) -> flt"""
  return _sim2dlong.cbrtflt(*args)

def expm1flt(*args) -> "flt" :
  """expm1flt(flt n) -> flt"""
  return _sim2dlong.expm1flt(*args)

def copysignflt(*args) -> "flt" :
  """copysignflt(flt n, flt m) -> flt"""
  return _sim2dlong.copysignflt(*args)

def vec(*args) -> "Vector3< flt >" :
  """
    vec(double x, double y) -> VecL
    vec(double x, double y, double z) -> Vector3< flt >
    """
  return _sim2dlong.vec(*args)

def vecsize() -> "uint" :
  """vecsize() -> uint"""
  return _sim2dlong.vecsize()

def randVec() -> "Vec" :
  """randVec() -> VecL"""
  return _sim2dlong.randVec()

def randVecBoxed() -> "Vec" :
  """randVecBoxed() -> VecL"""
  return _sim2dlong.randVecBoxed()

def seed(*args) -> "unsigned int" :
  """
    seed(unsigned int n) -> unsigned int
    seed() -> unsigned int
    """
  return _sim2dlong.seed(*args)
class gaussVec(_object):
    """Proxy of C++ gaussVec class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, gaussVec, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, gaussVec, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(gaussVec self, flt sigma) -> gaussVec"""
        this = _sim2dlong.new_gaussVec(*args)
        try: self.this.append(this)
        except: self.this = this
    def set(self, *args) -> "void" :
        """set(gaussVec self, flt sigma)"""
        return _sim2dlong.gaussVec_set(self, *args)

    def generate(self) -> "Vec" :
        """generate(gaussVec self) -> VecL"""
        return _sim2dlong.gaussVec_generate(self)

    __swig_destroy__ = _sim2dlong.delete_gaussVec
    __del__ = lambda self : None;
gaussVec_swigregister = _sim2dlong.gaussVec_swigregister
gaussVec_swigregister(gaussVec)
cvar = _sim2dlong.cvar
OVERNDIM = cvar.OVERNDIM

class bivariateGauss(_object):
    """Proxy of C++ bivariateGauss class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, bivariateGauss, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, bivariateGauss, name)
    __repr__ = _swig_repr
    def __init__(self, s1 : 'flt const'=1, s2 : 'flt const'=1, corr : 'flt const'=0): 
        """
        __init__(bivariateGauss self, flt const s1=1, flt const s2=1, flt const corr=0) -> bivariateGauss
        __init__(bivariateGauss self, flt const s1=1, flt const s2=1) -> bivariateGauss
        __init__(bivariateGauss self, flt const s1=1) -> bivariateGauss
        __init__(bivariateGauss self) -> bivariateGauss
        """
        this = _sim2dlong.new_bivariateGauss(s1, s2, corr)
        try: self.this.append(this)
        except: self.this = this
    def set(self, *args) -> "void" :
        """set(bivariateGauss self, flt const s1, flt const s2, flt const corr)"""
        return _sim2dlong.bivariateGauss_set(self, *args)

    def generate(self) -> "Pair" :
        """generate(bivariateGauss self) -> _Numvector2L"""
        return _sim2dlong.bivariateGauss_generate(self)

    def genVec(self) -> "Vec" :
        """genVec(bivariateGauss self) -> VecL"""
        return _sim2dlong.bivariateGauss_genVec(self)

    def genVecs(self) -> "VecPair" :
        """genVecs(bivariateGauss self) -> VecPair"""
        return _sim2dlong.bivariateGauss_genVecs(self)

    __swig_destroy__ = _sim2dlong.delete_bivariateGauss
    __del__ = lambda self : None;
bivariateGauss_swigregister = _sim2dlong.bivariateGauss_swigregister
bivariateGauss_swigregister(bivariateGauss)

class Box(_object):
    """Proxy of C++ Box class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Box, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Box, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def diff(self, *args) -> "Vec" :
        """diff(Box self, VecL r1, VecL r2) -> VecL"""
        return _sim2dlong.Box_diff(self, *args)

    def V(self) -> "flt" :
        """V(Box self) -> flt"""
        return _sim2dlong.Box_V(self)

    __swig_destroy__ = _sim2dlong.delete_Box
    __del__ = lambda self : None;
Box_swigregister = _sim2dlong.Box_swigregister
Box_swigregister(Box)

class interaction(_object):
    """Proxy of C++ interaction class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, interaction, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, interaction, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def energy(self, *args) -> "flt" :
        """energy(interaction self, Box box) -> flt"""
        return _sim2dlong.interaction_energy(self, *args)

    def setForces(self, *args) -> "void" :
        """setForces(interaction self, Box box)"""
        return _sim2dlong.interaction_setForces(self, *args)

    def setForcesGetPressure(self, *args) -> "flt" :
        """setForcesGetPressure(interaction self, Box box) -> flt"""
        return _sim2dlong.interaction_setForcesGetPressure(self, *args)

    def pressure(self, *args) -> "flt" :
        """pressure(interaction self, Box box) -> flt"""
        return _sim2dlong.interaction_pressure(self, *args)

    __swig_destroy__ = _sim2dlong.delete_interaction
    __del__ = lambda self : None;
interaction_swigregister = _sim2dlong.interaction_swigregister
interaction_swigregister(interaction)

class statetracker(_object):
    """Proxy of C++ statetracker class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, statetracker, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, statetracker, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def update(self, *args) -> "void" :
        """update(statetracker self, Box box)"""
        return _sim2dlong.statetracker_update(self, *args)

    __swig_destroy__ = _sim2dlong.delete_statetracker
    __del__ = lambda self : None;
statetracker_swigregister = _sim2dlong.statetracker_swigregister
statetracker_swigregister(statetracker)


def vecmod(*args) -> "Vec" :
  """vecmod(VecL r1, VecL r2) -> VecL"""
  return _sim2dlong.vecmod(*args)
class InfiniteBox(Box):
    """Proxy of C++ InfiniteBox class"""
    __swig_setmethods__ = {}
    for _s in [Box]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, InfiniteBox, name, value)
    __swig_getmethods__ = {}
    for _s in [Box]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, InfiniteBox, name)
    __repr__ = _swig_repr
    def diff(self, *args) -> "Vec" :
        """diff(InfiniteBox self, VecL r1, VecL r2) -> VecL"""
        return _sim2dlong.InfiniteBox_diff(self, *args)

    def V(self) -> "flt" :
        """V(InfiniteBox self) -> flt"""
        return _sim2dlong.InfiniteBox_V(self)

    def __init__(self): 
        """__init__(InfiniteBox self) -> InfiniteBox"""
        this = _sim2dlong.new_InfiniteBox()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _sim2dlong.delete_InfiniteBox
    __del__ = lambda self : None;
InfiniteBox_swigregister = _sim2dlong.InfiniteBox_swigregister
InfiniteBox_swigregister(InfiniteBox)

class OriginBox(Box):
    """Proxy of C++ OriginBox class"""
    __swig_setmethods__ = {}
    for _s in [Box]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, OriginBox, name, value)
    __swig_getmethods__ = {}
    for _s in [Box]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, OriginBox, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(OriginBox self, VecL size) -> OriginBox"""
        this = _sim2dlong.new_OriginBox(*args)
        try: self.this.append(this)
        except: self.this = this
    def diff(self, *args) -> "Vec" :
        """diff(OriginBox self, VecL r1, VecL r2) -> VecL"""
        return _sim2dlong.OriginBox_diff(self, *args)

    def V(self) -> "flt" :
        """V(OriginBox self) -> flt"""
        return _sim2dlong.OriginBox_V(self)

    def L(self) -> "flt" :
        """L(OriginBox self) -> flt"""
        return _sim2dlong.OriginBox_L(self)

    def resize(self, *args) -> "flt" :
        """resize(OriginBox self, flt factor) -> flt"""
        return _sim2dlong.OriginBox_resize(self, *args)

    def resizeV(self, *args) -> "flt" :
        """resizeV(OriginBox self, flt newV) -> flt"""
        return _sim2dlong.OriginBox_resizeV(self, *args)

    def randLoc(self) -> "Vec" :
        """randLoc(OriginBox self) -> VecL"""
        return _sim2dlong.OriginBox_randLoc(self)

    __swig_destroy__ = _sim2dlong.delete_OriginBox
    __del__ = lambda self : None;
OriginBox_swigregister = _sim2dlong.OriginBox_swigregister
OriginBox_swigregister(OriginBox)

class atom(_object):
    """Proxy of C++ atom class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, atom, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, atom, name)
    __repr__ = _swig_repr
    __swig_setmethods__["x"] = _sim2dlong.atom_x_set
    __swig_getmethods__["x"] = _sim2dlong.atom_x_get
    if _newclass:x = _swig_property(_sim2dlong.atom_x_get, _sim2dlong.atom_x_set)
    __swig_setmethods__["v"] = _sim2dlong.atom_v_set
    __swig_getmethods__["v"] = _sim2dlong.atom_v_get
    if _newclass:v = _swig_property(_sim2dlong.atom_v_get, _sim2dlong.atom_v_set)
    __swig_setmethods__["a"] = _sim2dlong.atom_a_set
    __swig_getmethods__["a"] = _sim2dlong.atom_a_get
    if _newclass:a = _swig_property(_sim2dlong.atom_a_get, _sim2dlong.atom_a_set)
    __swig_setmethods__["f"] = _sim2dlong.atom_f_set
    __swig_getmethods__["f"] = _sim2dlong.atom_f_get
    if _newclass:f = _swig_property(_sim2dlong.atom_f_get, _sim2dlong.atom_f_set)
    __swig_setmethods__["m"] = _sim2dlong.atom_m_set
    __swig_getmethods__["m"] = _sim2dlong.atom_m_get
    if _newclass:m = _swig_property(_sim2dlong.atom_m_get, _sim2dlong.atom_m_set)
    def __getstate__(self):
        return (tuple(self.x),tuple(self.v),tuple(self.f), tuple(self.a))

    def __setstate__(self, lst):
        self.x, self.v, self.f, self.a = [Vec(*r) for r in lst]

    def __str__(self):
        if hasattr(self, 'name'):
            return "<atom %s>" % self.name
        return "<atom>"

    def __repr__(self):
        #ifdef VEC2D
        x,y = tuple(self.x)
        if hasattr(self, 'name'):
            return "<atom %s at (%.2f,%.2f)>" % (self.name,x,y)
        return "<atom at (%.2f,%.2f)>" % (x,y)
        #else
        x,y,z = tuple(self.x)
        if hasattr(self, 'name'):
            return "<atom %s at (%.2f,%.2f,%.2f)>" % (self.name,x,y,z)
        return "<atom at (%.2f,%.2f,%.2f)>" % (x,y,z)
        #endif

    def __init__(self): 
        """__init__(atom self) -> atom"""
        this = _sim2dlong.new_atom()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _sim2dlong.delete_atom
    __del__ = lambda self : None;
atom_swigregister = _sim2dlong.atom_swigregister
atom_swigregister(atom)

class atomref(_object):
    """Proxy of C++ atomref class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, atomref, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, atomref, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(atomref self) -> atomref
        __init__(atomref self, atom a) -> atomref
        """
        this = _sim2dlong.new_atomref(*args)
        try: self.this.append(this)
        except: self.this = this
    def __ref__(self) -> "atom &" :
        """__ref__(atomref self) -> atom"""
        return _sim2dlong.atomref___ref__(self)

    def pointer(self) -> "atom *" :
        """pointer(atomref self) -> atom"""
        return _sim2dlong.atomref_pointer(self)

    def x(self) -> "Vec &" :
        """x(atomref self) -> VecL"""
        return _sim2dlong.atomref_x(self)

    def v(self) -> "Vec &" :
        """v(atomref self) -> VecL"""
        return _sim2dlong.atomref_v(self)

    def f(self) -> "Vec &" :
        """f(atomref self) -> VecL"""
        return _sim2dlong.atomref_f(self)

    def a(self) -> "Vec &" :
        """a(atomref self) -> VecL"""
        return _sim2dlong.atomref_a(self)

    def m(self) -> "flt &" :
        """m(atomref self) -> flt &"""
        return _sim2dlong.atomref_m(self)

    def __eq__(self, *args) -> "bool" :
        """
        __eq__(atomref self, atomref other) -> bool
        __eq__(atomref self, atom other) -> bool
        """
        return _sim2dlong.atomref___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        """__ne__(atomref self, atomref other) -> bool"""
        return _sim2dlong.atomref___ne__(self, *args)

    def __lt__(self, *args) -> "bool" :
        """__lt__(atomref self, atomref other) -> bool"""
        return _sim2dlong.atomref___lt__(self, *args)

    def __le__(self, *args) -> "bool" :
        """__le__(atomref self, atomref other) -> bool"""
        return _sim2dlong.atomref___le__(self, *args)

    def __ge__(self, *args) -> "bool" :
        """__ge__(atomref self, atomref other) -> bool"""
        return _sim2dlong.atomref___ge__(self, *args)

    def __gt__(self, *args) -> "bool" :
        """__gt__(atomref self, atomref other) -> bool"""
        return _sim2dlong.atomref___gt__(self, *args)

    __swig_destroy__ = _sim2dlong.delete_atomref
    __del__ = lambda self : None;
atomref_swigregister = _sim2dlong.atomref_swigregister
atomref_swigregister(atomref)

class atomid(atomref):
    """Proxy of C++ atomid class"""
    __swig_setmethods__ = {}
    for _s in [atomref]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, atomid, name, value)
    __swig_getmethods__ = {}
    for _s in [atomref]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, atomid, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(atomid self) -> atomid
        __init__(atomid self, atom a) -> atomid
        __init__(atomid self, atom a, uint n) -> atomid
        """
        this = _sim2dlong.new_atomid(*args)
        try: self.this.append(this)
        except: self.this = this
    def n(self) -> "uint" :
        """n(atomid self) -> uint"""
        return _sim2dlong.atomid_n(self)

    __swig_destroy__ = _sim2dlong.delete_atomid
    __del__ = lambda self : None;
atomid_swigregister = _sim2dlong.atomid_swigregister
atomid_swigregister(atomid)

class idpair(_idarray2):
    """Proxy of C++ idpair class"""
    __swig_setmethods__ = {}
    for _s in [_idarray2]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, idpair, name, value)
    __swig_getmethods__ = {}
    for _s in [_idarray2]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, idpair, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(idpair self, atomid a, atomid b) -> idpair"""
        this = _sim2dlong.new_idpair(*args)
        try: self.this.append(this)
        except: self.this = this
    def first(self) -> "atomid" :
        """first(idpair self) -> atomid"""
        return _sim2dlong.idpair_first(self)

    def last(self) -> "atomid" :
        """last(idpair self) -> atomid"""
        return _sim2dlong.idpair_last(self)

    __swig_destroy__ = _sim2dlong.delete_idpair
    __del__ = lambda self : None;
idpair_swigregister = _sim2dlong.idpair_swigregister
idpair_swigregister(idpair)

class atompair(_atomarray2):
    """Proxy of C++ atompair class"""
    __swig_setmethods__ = {}
    for _s in [_atomarray2]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, atompair, name, value)
    __swig_getmethods__ = {}
    for _s in [_atomarray2]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, atompair, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(atompair self, atom a, atom b) -> atompair"""
        this = _sim2dlong.new_atompair(*args)
        try: self.this.append(this)
        except: self.this = this
    def first(self) -> "atom &" :
        """first(atompair self) -> atom"""
        return _sim2dlong.atompair_first(self)

    def last(self) -> "atom &" :
        """last(atompair self) -> atom"""
        return _sim2dlong.atompair_last(self)

    __swig_destroy__ = _sim2dlong.delete_atompair
    __del__ = lambda self : None;
atompair_swigregister = _sim2dlong.atompair_swigregister
atompair_swigregister(atompair)

class atomgroup(_object):
    """Proxy of C++ atomgroup class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, atomgroup, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, atomgroup, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def get(self, *args) -> "atom *" :
        """get(atomgroup self, cuint n) -> atom"""
        return _sim2dlong.atomgroup_get(self, *args)

    def get_id(self, *args) -> "atomid" :
        """get_id(atomgroup self, cuint n) -> atomid"""
        return _sim2dlong.atomgroup_get_id(self, *args)

    def size(self) -> "uint" :
        """size(atomgroup self) -> uint"""
        return _sim2dlong.atomgroup_size(self)

    def getmass(self, *args) -> "flt" :
        """getmass(atomgroup self, unsigned int const n) -> flt"""
        return _sim2dlong.atomgroup_getmass(self, *args)

    def com(self) -> "Vec" :
        """com(atomgroup self) -> VecL"""
        return _sim2dlong.atomgroup_com(self)

    def comv(self) -> "Vec" :
        """comv(atomgroup self) -> VecL"""
        return _sim2dlong.atomgroup_comv(self)

    def mass(self) -> "flt" :
        """mass(atomgroup self) -> flt"""
        return _sim2dlong.atomgroup_mass(self)

    def kinetic(self, *args) -> "flt" :
        """
        kinetic(atomgroup self, VecL originvelocity=Vec()) -> flt
        kinetic(atomgroup self) -> flt
        """
        return _sim2dlong.atomgroup_kinetic(self, *args)

    def momentum(self) -> "Vec" :
        """momentum(atomgroup self) -> VecL"""
        return _sim2dlong.atomgroup_momentum(self)

    def moment(self, *args) -> "flt" :
        """moment(atomgroup self, VecL loc, Box box) -> flt"""
        return _sim2dlong.atomgroup_moment(self, *args)

    def angmomentum(self, *args) -> "flt" :
        """angmomentum(atomgroup self, VecL loc, Box box) -> flt"""
        return _sim2dlong.atomgroup_angmomentum(self, *args)

    def omega(self, *args) -> "flt" :
        """omega(atomgroup self, VecL loc, Box box) -> flt"""
        return _sim2dlong.atomgroup_omega(self, *args)

    def addOmega(self, *args) -> "void" :
        """addOmega(atomgroup self, flt w, VecL origin, Box box)"""
        return _sim2dlong.atomgroup_addOmega(self, *args)

    def resetL(self, *args) -> "void" :
        """resetL(atomgroup self, Box box)"""
        return _sim2dlong.atomgroup_resetL(self, *args)

    def addv(self, *args) -> "void" :
        """addv(atomgroup self, VecL v)"""
        return _sim2dlong.atomgroup_addv(self, *args)

    def resetcomv(self) -> "void" :
        """resetcomv(atomgroup self)"""
        return _sim2dlong.atomgroup_resetcomv(self)

    def resetForces(self) -> "void" :
        """resetForces(atomgroup self)"""
        return _sim2dlong.atomgroup_resetForces(self)

    def setAccel(self) -> "void" :
        """setAccel(atomgroup self)"""
        return _sim2dlong.atomgroup_setAccel(self)

    __swig_destroy__ = _sim2dlong.delete_atomgroup
    __del__ = lambda self : None;
    def __iter__(self):
        for i in range(self.size()):
            yield self.get(i)

atomgroup_swigregister = _sim2dlong.atomgroup_swigregister
atomgroup_swigregister(atomgroup)

class atomvec(atomgroup):
    """Proxy of C++ atomvec class"""
    __swig_setmethods__ = {}
    for _s in [atomgroup]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, atomvec, name, value)
    __swig_getmethods__ = {}
    for _s in [atomgroup]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, atomvec, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(atomvec self, dvector masses) -> atomvec
        __init__(atomvec self, uint N, flt mass) -> atomvec
        __init__(atomvec self, atomvec other) -> atomvec
        """
        this = _sim2dlong.new_atomvec(*args)
        try: self.this.append(this)
        except: self.this = this
    def get_id(self, *args) -> "atomid" :
        """
        get_id(atomvec self, atom a) -> atomid
        get_id(atomvec self, uint n) -> atomid
        """
        return _sim2dlong.atomvec_get_id(self, *args)

    def size(self) -> "uint" :
        """size(atomvec self) -> uint"""
        return _sim2dlong.atomvec_size(self)

    __swig_destroy__ = _sim2dlong.delete_atomvec
    __del__ = lambda self : None;
    def __iter__(self):
        for i in range(self.size()):
            yield self[i]

    def __len__(self):
        return self.size()

    def __getitem__(self, obj):
        return self.get(obj)

    def __setitem__(self, obj, val):
        return self.set(obj, val)

    def __getstate__(self):
        return ([self.getmass(i) for i in range(self.N())],
                    [a.__getstate__() for a in self])

    def __setstate__(self, lst):
        masses, atomstates = lst
        self.__init__(fvector(masses))
        for i, atomstate in enumerate(atomstates):
            #~ print "i:",i
            a = self.get(i)
            a.__setstate__(atomstate)

atomvec_swigregister = _sim2dlong.atomvec_swigregister
atomvec_swigregister(atomvec)

class metagroup(atomgroup):
    """Proxy of C++ metagroup class"""
    __swig_setmethods__ = {}
    for _s in [atomgroup]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, metagroup, name, value)
    __swig_getmethods__ = {}
    for _s in [atomgroup]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, metagroup, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(metagroup self) -> metagroup
        __init__(metagroup self, avector arg2) -> metagroup
        """
        this = _sim2dlong.new_metagroup(*args)
        try: self.this.append(this)
        except: self.this = this
    def get(self, *args) -> "atom *" :
        """get(metagroup self, cuint n) -> atom"""
        return _sim2dlong.metagroup_get(self, *args)

    def add(self, *args) -> "void" :
        """add(metagroup self, atom a)"""
        return _sim2dlong.metagroup_add(self, *args)

    def get_id(self, *args) -> "atomid" :
        """
        get_id(metagroup self, atom a) -> atomid
        get_id(metagroup self, uint n) -> atomid
        """
        return _sim2dlong.metagroup_get_id(self, *args)

    def size(self) -> "uint" :
        """size(metagroup self) -> uint"""
        return _sim2dlong.metagroup_size(self)

    __swig_destroy__ = _sim2dlong.delete_metagroup
    __del__ = lambda self : None;
metagroup_swigregister = _sim2dlong.metagroup_swigregister
metagroup_swigregister(metagroup)

class interactpair(_object):
    """Proxy of C++ interactpair class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, interactpair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, interactpair, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def energy(self, *args) -> "flt" :
        """energy(interactpair self, VecL diff) -> flt"""
        return _sim2dlong.interactpair_energy(self, *args)

    def forces(self, *args) -> "Vec" :
        """forces(interactpair self, VecL diff) -> VecL"""
        return _sim2dlong.interactpair_forces(self, *args)

    __swig_destroy__ = _sim2dlong.delete_interactpair
    __del__ = lambda self : None;
interactpair_swigregister = _sim2dlong.interactpair_swigregister
interactpair_swigregister(interactpair)

class LJrepulsive(_object):
    """Proxy of C++ LJrepulsive class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJrepulsive, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LJrepulsive, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(LJrepulsive self, flt const epsilon, flt const sigma) -> LJrepulsive"""
        this = _sim2dlong.new_LJrepulsive(*args)
        try: self.this.append(this)
        except: self.this = this
    def energy(self, *args) -> "flt" :
        """
        energy(LJrepulsive self, VecL diff, flt const eps, flt const sig) -> flt
        energy(LJrepulsive self, VecL diff) -> flt
        """
        return _sim2dlong.LJrepulsive_energy(self, *args)

    def forces(self, *args) -> "Vec" :
        """
        forces(LJrepulsive self, VecL diff, flt const eps, flt const sig) -> VecL
        forces(LJrepulsive self, VecL diff) -> VecL
        """
        return _sim2dlong.LJrepulsive_forces(self, *args)

    __swig_destroy__ = _sim2dlong.delete_LJrepulsive
    __del__ = lambda self : None;
LJrepulsive_swigregister = _sim2dlong.LJrepulsive_swigregister
LJrepulsive_swigregister(LJrepulsive)
LJr0 = cvar.LJr0
LJr0sq = cvar.LJr0sq

class LJattract(_object):
    """Proxy of C++ LJattract class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJattract, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LJattract, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(LJattract self, flt const epsilon, flt const sigma) -> LJattract"""
        this = _sim2dlong.new_LJattract(*args)
        try: self.this.append(this)
        except: self.this = this
    def energy(self, *args) -> "flt" :
        """
        energy(LJattract self, VecL diff, flt const eps, flt const sig) -> flt
        energy(LJattract self, flt const rsig) -> flt
        energy(LJattract self, VecL diff) -> flt
        """
        return _sim2dlong.LJattract_energy(self, *args)

    def forces(self, *args) -> "Vec" :
        """
        forces(LJattract self, VecL diff, flt const eps, flt const sig) -> VecL
        forces(LJattract self, flt const rsig) -> flt
        forces(LJattract self, VecL diff) -> VecL
        """
        return _sim2dlong.LJattract_forces(self, *args)

    __swig_destroy__ = _sim2dlong.delete_LJattract
    __del__ = lambda self : None;
LJattract_swigregister = _sim2dlong.LJattract_swigregister
LJattract_swigregister(LJattract)

class LJattractCut(_object):
    """Proxy of C++ LJattractCut class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJattractCut, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LJattractCut, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(LJattractCut self, flt const epsilon, flt const sigma, flt const cutsig) -> LJattractCut"""
        this = _sim2dlong.new_LJattractCut(*args)
        try: self.this.append(this)
        except: self.this = this
    def energy(self, *args) -> "flt" :
        """
        energy(LJattractCut self, VecL diff, flt const eps, flt const sig, flt const cutsig) -> flt
        energy(LJattractCut self, VecL diff) -> flt
        """
        return _sim2dlong.LJattractCut_energy(self, *args)

    def forces(self, *args) -> "Vec" :
        """
        forces(LJattractCut self, VecL diff, flt const eps, flt const sig, flt const cutsig) -> VecL
        forces(LJattractCut self, VecL diff) -> VecL
        """
        return _sim2dlong.LJattractCut_forces(self, *args)

    __swig_destroy__ = _sim2dlong.delete_LJattractCut
    __del__ = lambda self : None;
LJattractCut_swigregister = _sim2dlong.LJattractCut_swigregister
LJattractCut_swigregister(LJattractCut)

class LJFullCut(_object):
    """Proxy of C++ LJFullCut class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJFullCut, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LJFullCut, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(LJFullCut self, flt const epsilon, flt const sigma, flt const cutsig) -> LJFullCut"""
        this = _sim2dlong.new_LJFullCut(*args)
        try: self.this.append(this)
        except: self.this = this
    def energy(self, *args) -> "flt" :
        """
        energy(LJFullCut self, VecL diff, flt const eps, flt const sig, flt const cutsig) -> flt
        energy(LJFullCut self, flt const rsig, flt const cutsig) -> flt
        energy(LJFullCut self, VecL diff) -> flt
        """
        return _sim2dlong.LJFullCut_energy(self, *args)

    def forces(self, *args) -> "Vec" :
        """
        forces(LJFullCut self, VecL diff, flt const eps, flt const sig, flt const cutsig) -> VecL
        forces(LJFullCut self, flt const rsig, flt const cutsig) -> flt
        forces(LJFullCut self, VecL diff) -> VecL
        """
        return _sim2dlong.LJFullCut_forces(self, *args)

    __swig_destroy__ = _sim2dlong.delete_LJFullCut
    __del__ = lambda self : None;
LJFullCut_swigregister = _sim2dlong.LJFullCut_swigregister
LJFullCut_swigregister(LJFullCut)

class spring(interactpair):
    """Proxy of C++ spring class"""
    __swig_setmethods__ = {}
    for _s in [interactpair]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, spring, name, value)
    __swig_getmethods__ = {}
    for _s in [interactpair]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, spring, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(spring self, flt const k, flt const x0) -> spring"""
        this = _sim2dlong.new_spring(*args)
        try: self.this.append(this)
        except: self.this = this
    def energy(self, *args) -> "flt" :
        """energy(spring self, VecL diff) -> flt"""
        return _sim2dlong.spring_energy(self, *args)

    def forces(self, *args) -> "Vec" :
        """forces(spring self, VecL diff) -> VecL"""
        return _sim2dlong.spring_forces(self, *args)

    __swig_destroy__ = _sim2dlong.delete_spring
    __del__ = lambda self : None;
spring_swigregister = _sim2dlong.spring_swigregister
spring_swigregister(spring)

class bondangle(_object):
    """Proxy of C++ bondangle class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, bondangle, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, bondangle, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(bondangle self, flt const k, flt const theta, bool const cosine=False) -> bondangle
        __init__(bondangle self, flt const k, flt const theta) -> bondangle
        """
        this = _sim2dlong.new_bondangle(*args)
        try: self.this.append(this)
        except: self.this = this
    def energy(self, *args) -> "flt" :
        """energy(bondangle self, VecL diff1, VecL diff2) -> flt"""
        return _sim2dlong.bondangle_energy(self, *args)

    def forces(self, *args) -> "Nvector< Vec,3 >" :
        """forces(bondangle self, VecL diff1, VecL diff2) -> Nvector< Vec,3 >"""
        return _sim2dlong.bondangle_forces(self, *args)

    __swig_destroy__ = _sim2dlong.delete_bondangle
    __del__ = lambda self : None;
bondangle_swigregister = _sim2dlong.bondangle_swigregister
bondangle_swigregister(bondangle)

class electricScreened(interactpair):
    """Proxy of C++ electricScreened class"""
    __swig_setmethods__ = {}
    for _s in [interactpair]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, electricScreened, name, value)
    __swig_getmethods__ = {}
    for _s in [interactpair]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, electricScreened, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(electricScreened self, flt const screenLength, flt const q1, flt const q2, flt const cutoff) -> electricScreened"""
        this = _sim2dlong.new_electricScreened(*args)
        try: self.this.append(this)
        except: self.this = this
    def energy(*args) -> "flt" :
        """
        energy(VecL r) -> flt
        energy(flt const r, flt const qaqb, flt const screen, flt const cutoff=0) -> flt
        energy(flt const r, flt const qaqb, flt const screen) -> flt
        """
        return _sim2dlong.electricScreened_energy(*args)

    if _newclass:energy = staticmethod(energy)
    __swig_getmethods__["energy"] = lambda x: energy
    def forces(*args) -> "Vec" :
        """
        forces(VecL r) -> VecL
        forces(VecL r, flt const qaqb, flt const screen, flt const cutoff=0) -> VecL
        forces(VecL r, flt const qaqb, flt const screen) -> VecL
        """
        return _sim2dlong.electricScreened_forces(*args)

    if _newclass:forces = staticmethod(forces)
    __swig_getmethods__["forces"] = lambda x: forces
    __swig_destroy__ = _sim2dlong.delete_electricScreened
    __del__ = lambda self : None;
electricScreened_swigregister = _sim2dlong.electricScreened_swigregister
electricScreened_swigregister(electricScreened)

def electricScreened_energy(*args) -> "flt" :
  """
    energy(VecL r) -> flt
    energy(flt const r, flt const qaqb, flt const screen, flt const cutoff=0) -> flt
    electricScreened_energy(flt const r, flt const qaqb, flt const screen) -> flt
    """
  return _sim2dlong.electricScreened_energy(*args)

def electricScreened_forces(*args) -> "Vec" :
  """
    forces(VecL r) -> VecL
    forces(VecL r, flt const qaqb, flt const screen, flt const cutoff=0) -> VecL
    electricScreened_forces(VecL r, flt const qaqb, flt const screen) -> VecL
    """
  return _sim2dlong.electricScreened_forces(*args)

class fixedForceAtom(_object):
    """Proxy of C++ fixedForceAtom class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, fixedForceAtom, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, fixedForceAtom, name)
    __repr__ = _swig_repr
    __swig_setmethods__["F"] = _sim2dlong.fixedForceAtom_F_set
    __swig_getmethods__["F"] = _sim2dlong.fixedForceAtom_F_get
    if _newclass:F = _swig_property(_sim2dlong.fixedForceAtom_F_get, _sim2dlong.fixedForceAtom_F_set)
    __swig_setmethods__["a"] = _sim2dlong.fixedForceAtom_a_set
    __swig_getmethods__["a"] = _sim2dlong.fixedForceAtom_a_get
    if _newclass:a = _swig_property(_sim2dlong.fixedForceAtom_a_get, _sim2dlong.fixedForceAtom_a_set)
    def __init__(self, *args): 
        """__init__(fixedForceAtom self, VecL F, atom a) -> fixedForceAtom"""
        this = _sim2dlong.new_fixedForceAtom(*args)
        try: self.this.append(this)
        except: self.this = this
    def energy(self, *args) -> "flt" :
        """energy(fixedForceAtom self, Box box) -> flt"""
        return _sim2dlong.fixedForceAtom_energy(self, *args)

    def setForce(self, *args) -> "void" :
        """setForce(fixedForceAtom self, Box box)"""
        return _sim2dlong.fixedForceAtom_setForce(self, *args)

    __swig_destroy__ = _sim2dlong.delete_fixedForceAtom
    __del__ = lambda self : None;
fixedForceAtom_swigregister = _sim2dlong.fixedForceAtom_swigregister
fixedForceAtom_swigregister(fixedForceAtom)

class fixedForce(interaction):
    """Proxy of C++ fixedForce class"""
    __swig_setmethods__ = {}
    for _s in [interaction]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, fixedForce, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, fixedForce, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(fixedForce self, std::vector< fixedForceAtom > atoms=std::vector< fixedForceAtom >()) -> fixedForce
        __init__(fixedForce self) -> fixedForce
        """
        this = _sim2dlong.new_fixedForce(*args)
        try: self.this.append(this)
        except: self.this = this
    def add(self, *args) -> "void" :
        """
        add(fixedForce self, fixedForceAtom a)
        add(fixedForce self, VecL F, atom a)
        add(fixedForce self, flt x, flt y, atom a)
        """
        return _sim2dlong.fixedForce_add(self, *args)

    def size(self) -> "uint" :
        """size(fixedForce self) -> uint"""
        return _sim2dlong.fixedForce_size(self)

    def energy(self, *args) -> "flt" :
        """energy(fixedForce self, Box box) -> flt"""
        return _sim2dlong.fixedForce_energy(self, *args)

    def setForces(self, *args) -> "void" :
        """setForces(fixedForce self, Box box)"""
        return _sim2dlong.fixedForce_setForces(self, *args)

    def pressure(self, *args) -> "flt" :
        """pressure(fixedForce self, Box box) -> flt"""
        return _sim2dlong.fixedForce_pressure(self, *args)

    __swig_destroy__ = _sim2dlong.delete_fixedForce
    __del__ = lambda self : None;
fixedForce_swigregister = _sim2dlong.fixedForce_swigregister
fixedForce_swigregister(fixedForce)

class fixedSpringAtom(_object):
    """Proxy of C++ fixedSpringAtom class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, fixedSpringAtom, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, fixedSpringAtom, name)
    __repr__ = _swig_repr
    __swig_setmethods__["loc"] = _sim2dlong.fixedSpringAtom_loc_set
    __swig_getmethods__["loc"] = _sim2dlong.fixedSpringAtom_loc_get
    if _newclass:loc = _swig_property(_sim2dlong.fixedSpringAtom_loc_get, _sim2dlong.fixedSpringAtom_loc_set)
    __swig_setmethods__["k"] = _sim2dlong.fixedSpringAtom_k_set
    __swig_getmethods__["k"] = _sim2dlong.fixedSpringAtom_k_get
    if _newclass:k = _swig_property(_sim2dlong.fixedSpringAtom_k_get, _sim2dlong.fixedSpringAtom_k_set)
    __swig_setmethods__["usecoord"] = _sim2dlong.fixedSpringAtom_usecoord_set
    __swig_getmethods__["usecoord"] = _sim2dlong.fixedSpringAtom_usecoord_get
    if _newclass:usecoord = _swig_property(_sim2dlong.fixedSpringAtom_usecoord_get, _sim2dlong.fixedSpringAtom_usecoord_set)
    __swig_setmethods__["a"] = _sim2dlong.fixedSpringAtom_a_set
    __swig_getmethods__["a"] = _sim2dlong.fixedSpringAtom_a_get
    if _newclass:a = _swig_property(_sim2dlong.fixedSpringAtom_a_get, _sim2dlong.fixedSpringAtom_a_set)
    def __init__(self, *args): 
        """
        __init__(fixedSpringAtom self, atom a, VecL loc, flt k, bool usex=True, bool usey=True, bool usez=True) -> fixedSpringAtom
        __init__(fixedSpringAtom self, atom a, VecL loc, flt k, bool usex=True, bool usey=True) -> fixedSpringAtom
        __init__(fixedSpringAtom self, atom a, VecL loc, flt k, bool usex=True) -> fixedSpringAtom
        __init__(fixedSpringAtom self, atom a, VecL loc, flt k) -> fixedSpringAtom
        """
        this = _sim2dlong.new_fixedSpringAtom(*args)
        try: self.this.append(this)
        except: self.this = this
    def energy(self, *args) -> "flt" :
        """energy(fixedSpringAtom self, Box box) -> flt"""
        return _sim2dlong.fixedSpringAtom_energy(self, *args)

    def setForce(self, *args) -> "void" :
        """setForce(fixedSpringAtom self, Box box)"""
        return _sim2dlong.fixedSpringAtom_setForce(self, *args)

    __swig_destroy__ = _sim2dlong.delete_fixedSpringAtom
    __del__ = lambda self : None;
fixedSpringAtom_swigregister = _sim2dlong.fixedSpringAtom_swigregister
fixedSpringAtom_swigregister(fixedSpringAtom)

class fixedSpring(interaction):
    """Proxy of C++ fixedSpring class"""
    __swig_setmethods__ = {}
    for _s in [interaction]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, fixedSpring, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, fixedSpring, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(fixedSpring self, std::vector< fixedSpringAtom > atoms=std::vector< fixedSpringAtom >()) -> fixedSpring
        __init__(fixedSpring self) -> fixedSpring
        """
        this = _sim2dlong.new_fixedSpring(*args)
        try: self.this.append(this)
        except: self.this = this
    def add(self, *args) -> "void" :
        """
        add(fixedSpring self, fixedSpringAtom a)
        add(fixedSpring self, atom a, VecL loc, flt k, bool usex=True, bool usey=True, bool usez=True)
        add(fixedSpring self, atom a, VecL loc, flt k, bool usex=True, bool usey=True)
        add(fixedSpring self, atom a, VecL loc, flt k, bool usex=True)
        add(fixedSpring self, atom a, VecL loc, flt k)
        """
        return _sim2dlong.fixedSpring_add(self, *args)

    def size(self) -> "uint" :
        """size(fixedSpring self) -> uint"""
        return _sim2dlong.fixedSpring_size(self)

    def energy(self, *args) -> "flt" :
        """energy(fixedSpring self, Box box) -> flt"""
        return _sim2dlong.fixedSpring_energy(self, *args)

    def setForces(self, *args) -> "void" :
        """setForces(fixedSpring self, Box box)"""
        return _sim2dlong.fixedSpring_setForces(self, *args)

    def pressure(self, *args) -> "flt" :
        """pressure(fixedSpring self, Box box) -> flt"""
        return _sim2dlong.fixedSpring_pressure(self, *args)

    __swig_destroy__ = _sim2dlong.delete_fixedSpring
    __del__ = lambda self : None;
fixedSpring_swigregister = _sim2dlong.fixedSpring_swigregister
fixedSpring_swigregister(fixedSpring)

class COMSpring(interaction):
    """Proxy of C++ COMSpring class"""
    __swig_setmethods__ = {}
    for _s in [interaction]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, COMSpring, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, COMSpring, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(COMSpring self, atomgroup g1, atomgroup g2, flt k, flt x0=0) -> COMSpring
        __init__(COMSpring self, atomgroup g1, atomgroup g2, flt k) -> COMSpring
        """
        this = _sim2dlong.new_COMSpring(*args)
        try: self.this.append(this)
        except: self.this = this
    def energy(self, *args) -> "flt" :
        """energy(COMSpring self, Box box) -> flt"""
        return _sim2dlong.COMSpring_energy(self, *args)

    def setForces(self, *args) -> "void" :
        """setForces(COMSpring self, Box box)"""
        return _sim2dlong.COMSpring_setForces(self, *args)

    def pressure(self, *args) -> "flt" :
        """pressure(COMSpring self, Box box) -> flt"""
        return _sim2dlong.COMSpring_pressure(self, *args)

    __swig_destroy__ = _sim2dlong.delete_COMSpring
    __del__ = lambda self : None;
COMSpring_swigregister = _sim2dlong.COMSpring_swigregister
COMSpring_swigregister(COMSpring)

class bondgrouping(_object):
    """Proxy of C++ bondgrouping class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, bondgrouping, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, bondgrouping, name)
    __repr__ = _swig_repr
    __swig_setmethods__["k"] = _sim2dlong.bondgrouping_k_set
    __swig_getmethods__["k"] = _sim2dlong.bondgrouping_k_get
    if _newclass:k = _swig_property(_sim2dlong.bondgrouping_k_get, _sim2dlong.bondgrouping_k_set)
    __swig_setmethods__["x0"] = _sim2dlong.bondgrouping_x0_set
    __swig_getmethods__["x0"] = _sim2dlong.bondgrouping_x0_get
    if _newclass:x0 = _swig_property(_sim2dlong.bondgrouping_x0_get, _sim2dlong.bondgrouping_x0_set)
    __swig_setmethods__["a1"] = _sim2dlong.bondgrouping_a1_set
    __swig_getmethods__["a1"] = _sim2dlong.bondgrouping_a1_get
    if _newclass:a1 = _swig_property(_sim2dlong.bondgrouping_a1_get, _sim2dlong.bondgrouping_a1_set)
    __swig_setmethods__["a2"] = _sim2dlong.bondgrouping_a2_set
    __swig_getmethods__["a2"] = _sim2dlong.bondgrouping_a2_get
    if _newclass:a2 = _swig_property(_sim2dlong.bondgrouping_a2_get, _sim2dlong.bondgrouping_a2_set)
    def __init__(self, *args): 
        """__init__(bondgrouping self, flt k, flt x0, atom a1, atom a2) -> bondgrouping"""
        this = _sim2dlong.new_bondgrouping(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _sim2dlong.delete_bondgrouping
    __del__ = lambda self : None;
bondgrouping_swigregister = _sim2dlong.bondgrouping_swigregister
bondgrouping_swigregister(bondgrouping)

class bondpairs(interaction):
    """Proxy of C++ bondpairs class"""
    __swig_setmethods__ = {}
    for _s in [interaction]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, bondpairs, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, bondpairs, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(bondpairs self, std::vector< bondgrouping > pairs=std::vector< bondgrouping >()) -> bondpairs
        __init__(bondpairs self) -> bondpairs
        """
        this = _sim2dlong.new_bondpairs(*args)
        try: self.this.append(this)
        except: self.this = this
    def add(self, *args) -> "void" :
        """
        add(bondpairs self, bondgrouping b)
        add(bondpairs self, flt k, flt x0, atom a1, atom a2)
        """
        return _sim2dlong.bondpairs_add(self, *args)

    def size(self) -> "uint" :
        """size(bondpairs self) -> uint"""
        return _sim2dlong.bondpairs_size(self)

    def mean_dists(self) -> "flt" :
        """mean_dists(bondpairs self) -> flt"""
        return _sim2dlong.bondpairs_mean_dists(self)

    def std_dists(self) -> "flt" :
        """std_dists(bondpairs self) -> flt"""
        return _sim2dlong.bondpairs_std_dists(self)

    def energy(self, *args) -> "flt" :
        """energy(bondpairs self, Box box) -> flt"""
        return _sim2dlong.bondpairs_energy(self, *args)

    def setForces(self, *args) -> "void" :
        """setForces(bondpairs self, Box box)"""
        return _sim2dlong.bondpairs_setForces(self, *args)

    def pressure(self, *args) -> "flt" :
        """pressure(bondpairs self, Box box) -> flt"""
        return _sim2dlong.bondpairs_pressure(self, *args)

    __swig_destroy__ = _sim2dlong.delete_bondpairs
    __del__ = lambda self : None;
bondpairs_swigregister = _sim2dlong.bondpairs_swigregister
bondpairs_swigregister(bondpairs)

class anglegrouping(_object):
    """Proxy of C++ anglegrouping class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, anglegrouping, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, anglegrouping, name)
    __repr__ = _swig_repr
    __swig_setmethods__["k"] = _sim2dlong.anglegrouping_k_set
    __swig_getmethods__["k"] = _sim2dlong.anglegrouping_k_get
    if _newclass:k = _swig_property(_sim2dlong.anglegrouping_k_get, _sim2dlong.anglegrouping_k_set)
    __swig_setmethods__["x0"] = _sim2dlong.anglegrouping_x0_set
    __swig_getmethods__["x0"] = _sim2dlong.anglegrouping_x0_get
    if _newclass:x0 = _swig_property(_sim2dlong.anglegrouping_x0_get, _sim2dlong.anglegrouping_x0_set)
    __swig_setmethods__["a1"] = _sim2dlong.anglegrouping_a1_set
    __swig_getmethods__["a1"] = _sim2dlong.anglegrouping_a1_get
    if _newclass:a1 = _swig_property(_sim2dlong.anglegrouping_a1_get, _sim2dlong.anglegrouping_a1_set)
    __swig_setmethods__["a2"] = _sim2dlong.anglegrouping_a2_set
    __swig_getmethods__["a2"] = _sim2dlong.anglegrouping_a2_get
    if _newclass:a2 = _swig_property(_sim2dlong.anglegrouping_a2_get, _sim2dlong.anglegrouping_a2_set)
    __swig_setmethods__["a3"] = _sim2dlong.anglegrouping_a3_set
    __swig_getmethods__["a3"] = _sim2dlong.anglegrouping_a3_get
    if _newclass:a3 = _swig_property(_sim2dlong.anglegrouping_a3_get, _sim2dlong.anglegrouping_a3_set)
    def __init__(self, *args): 
        """__init__(anglegrouping self, flt k, flt x0, atom a1, atom a2, atom a3) -> anglegrouping"""
        this = _sim2dlong.new_anglegrouping(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _sim2dlong.delete_anglegrouping
    __del__ = lambda self : None;
anglegrouping_swigregister = _sim2dlong.anglegrouping_swigregister
anglegrouping_swigregister(anglegrouping)

class angletriples(interaction):
    """Proxy of C++ angletriples class"""
    __swig_setmethods__ = {}
    for _s in [interaction]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, angletriples, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, angletriples, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(angletriples self, std::vector< anglegrouping > triples=std::vector< anglegrouping >()) -> angletriples
        __init__(angletriples self) -> angletriples
        """
        this = _sim2dlong.new_angletriples(*args)
        try: self.this.append(this)
        except: self.this = this
    def add(self, *args) -> "void" :
        """
        add(angletriples self, anglegrouping b)
        add(angletriples self, flt k, flt x0, atom a1, atom a2, atom a3)
        """
        return _sim2dlong.angletriples_add(self, *args)

    def energy(self, *args) -> "flt" :
        """energy(angletriples self, Box box) -> flt"""
        return _sim2dlong.angletriples_energy(self, *args)

    def pressure(self, *args) -> "flt" :
        """pressure(angletriples self, Box box) -> flt"""
        return _sim2dlong.angletriples_pressure(self, *args)

    def setForces(self, *args) -> "void" :
        """setForces(angletriples self, Box box)"""
        return _sim2dlong.angletriples_setForces(self, *args)

    def size(self) -> "uint" :
        """size(angletriples self) -> uint"""
        return _sim2dlong.angletriples_size(self)

    def mean_dists(self) -> "flt" :
        """mean_dists(angletriples self) -> flt"""
        return _sim2dlong.angletriples_mean_dists(self)

    def std_dists(self) -> "flt" :
        """std_dists(angletriples self) -> flt"""
        return _sim2dlong.angletriples_std_dists(self)

    __swig_destroy__ = _sim2dlong.delete_angletriples
    __del__ = lambda self : None;
angletriples_swigregister = _sim2dlong.angletriples_swigregister
angletriples_swigregister(angletriples)

class forcepair(_object):
    """Proxy of C++ forcepair class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, forcepair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, forcepair, name)
    __repr__ = _swig_repr
    __swig_setmethods__["a1"] = _sim2dlong.forcepair_a1_set
    __swig_getmethods__["a1"] = _sim2dlong.forcepair_a1_get
    if _newclass:a1 = _swig_property(_sim2dlong.forcepair_a1_get, _sim2dlong.forcepair_a1_set)
    __swig_setmethods__["a2"] = _sim2dlong.forcepair_a2_set
    __swig_getmethods__["a2"] = _sim2dlong.forcepair_a2_get
    if _newclass:a2 = _swig_property(_sim2dlong.forcepair_a2_get, _sim2dlong.forcepair_a2_set)
    __swig_setmethods__["fij"] = _sim2dlong.forcepair_fij_set
    __swig_getmethods__["fij"] = _sim2dlong.forcepair_fij_get
    if _newclass:fij = _swig_property(_sim2dlong.forcepair_fij_get, _sim2dlong.forcepair_fij_set)
    def __init__(self): 
        """__init__(forcepair self) -> forcepair"""
        this = _sim2dlong.new_forcepair()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _sim2dlong.delete_forcepair
    __del__ = lambda self : None;
forcepair_swigregister = _sim2dlong.forcepair_swigregister
forcepair_swigregister(forcepair)

class forcepairx(_object):
    """Proxy of C++ forcepairx class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, forcepairx, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, forcepairx, name)
    __repr__ = _swig_repr
    __swig_setmethods__["a1"] = _sim2dlong.forcepairx_a1_set
    __swig_getmethods__["a1"] = _sim2dlong.forcepairx_a1_get
    if _newclass:a1 = _swig_property(_sim2dlong.forcepairx_a1_get, _sim2dlong.forcepairx_a1_set)
    __swig_setmethods__["a2"] = _sim2dlong.forcepairx_a2_set
    __swig_getmethods__["a2"] = _sim2dlong.forcepairx_a2_get
    if _newclass:a2 = _swig_property(_sim2dlong.forcepairx_a2_get, _sim2dlong.forcepairx_a2_set)
    __swig_setmethods__["xij"] = _sim2dlong.forcepairx_xij_set
    __swig_getmethods__["xij"] = _sim2dlong.forcepairx_xij_get
    if _newclass:xij = _swig_property(_sim2dlong.forcepairx_xij_get, _sim2dlong.forcepairx_xij_set)
    __swig_setmethods__["fij"] = _sim2dlong.forcepairx_fij_set
    __swig_getmethods__["fij"] = _sim2dlong.forcepairx_fij_get
    if _newclass:fij = _swig_property(_sim2dlong.forcepairx_fij_get, _sim2dlong.forcepairx_fij_set)
    def __init__(self): 
        """__init__(forcepairx self) -> forcepairx"""
        this = _sim2dlong.new_forcepairx()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _sim2dlong.delete_forcepairx
    __del__ = lambda self : None;
forcepairx_swigregister = _sim2dlong.forcepairx_swigregister
forcepairx_swigregister(forcepairx)

class fpairxFunct(_object):
    """Proxy of C++ fpairxFunct class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, fpairxFunct, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, fpairxFunct, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def run(self, *args) -> "void" :
        """run(fpairxFunct self, forcepairx arg2)"""
        return _sim2dlong.fpairxFunct_run(self, *args)

    __swig_destroy__ = _sim2dlong.delete_fpairxFunct
    __del__ = lambda self : None;
fpairxFunct_swigregister = _sim2dlong.fpairxFunct_swigregister
fpairxFunct_swigregister(fpairxFunct)

class interactionpairsx(interaction):
    """Proxy of C++ interactionpairsx class"""
    __swig_setmethods__ = {}
    for _s in [interaction]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, interactionpairsx, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, interactionpairsx, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def setForces(self, *args) -> "void" :
        """
        setForces(interactionpairsx self, Box box)
        setForces(interactionpairsx self, Box box, fpairxFunct arg3)
        """
        return _sim2dlong.interactionpairsx_setForces(self, *args)

    __swig_destroy__ = _sim2dlong.delete_interactionpairsx
    __del__ = lambda self : None;
interactionpairsx_swigregister = _sim2dlong.interactionpairsx_swigregister
interactionpairsx_swigregister(interactionpairsx)

class atompaircomp(_object):
    """Proxy of C++ atompaircomp class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, atompaircomp, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, atompaircomp, name)
    __repr__ = _swig_repr
    def __call__(self, *args) -> "bool" :
        """__call__(atompaircomp self, atompair lhs, atompair rhs) -> bool"""
        return _sim2dlong.atompaircomp___call__(self, *args)

    def __init__(self): 
        """__init__(atompaircomp self) -> atompaircomp"""
        this = _sim2dlong.new_atompaircomp()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _sim2dlong.delete_atompaircomp
    __del__ = lambda self : None;
atompaircomp_swigregister = _sim2dlong.atompaircomp_swigregister
atompaircomp_swigregister(atompaircomp)

class pairlist(_object):
    """Proxy of C++ pairlist class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, pairlist, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, pairlist, name)
    __repr__ = _swig_repr
    def __init__(self): 
        """__init__(pairlist self) -> pairlist"""
        this = _sim2dlong.new_pairlist()
        try: self.this.append(this)
        except: self.this = this
    def ensure(self, *args) -> "void" :
        """
        ensure(pairlist self, atomid a)
        ensure(pairlist self, std::vector< atomid > ps)
        ensure(pairlist self, atomgroup group)
        """
        return _sim2dlong.pairlist_ensure(self, *args)

    def has_pair(self, *args) -> "bool" :
        """has_pair(pairlist self, atomid a1, atomid a2) -> bool"""
        return _sim2dlong.pairlist_has_pair(self, *args)

    def add_pair(self, *args) -> "void" :
        """add_pair(pairlist self, atomid a1, atomid a2)"""
        return _sim2dlong.pairlist_add_pair(self, *args)

    def erase_pair(self, *args) -> "void" :
        """erase_pair(pairlist self, atomid a1, atomid a2)"""
        return _sim2dlong.pairlist_erase_pair(self, *args)

    def get_pairs(self, *args) -> "set< atomid >" :
        """get_pairs(pairlist self, atomid a) -> set< atomid >"""
        return _sim2dlong.pairlist_get_pairs(self, *args)

    def begin(self, *args) -> "set< atomid >::iterator" :
        """begin(pairlist self, atomid a) -> set< atomid >::iterator"""
        return _sim2dlong.pairlist_begin(self, *args)

    def end(self, *args) -> "set< atomid >::iterator" :
        """end(pairlist self, atomid a) -> set< atomid >::iterator"""
        return _sim2dlong.pairlist_end(self, *args)

    def size(self) -> "uint" :
        """size(pairlist self) -> uint"""
        return _sim2dlong.pairlist_size(self)

    def clear(self) -> "void" :
        """clear(pairlist self)"""
        return _sim2dlong.pairlist_clear(self)

    __swig_destroy__ = _sim2dlong.delete_pairlist
    __del__ = lambda self : None;
pairlist_swigregister = _sim2dlong.pairlist_swigregister
pairlist_swigregister(pairlist)

class neighborlist(statetracker):
    """Proxy of C++ neighborlist class"""
    __swig_setmethods__ = {}
    for _s in [statetracker]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, neighborlist, name, value)
    __swig_getmethods__ = {}
    for _s in [statetracker]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, neighborlist, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(neighborlist self, Box box, flt const innerradius, flt const outerradius) -> neighborlist
        __init__(neighborlist self, Box box, atomgroup vec, flt const innerradius, flt const outerradius, pairlist ignore=pairlist()) -> neighborlist
        __init__(neighborlist self, Box box, atomgroup vec, flt const innerradius, flt const outerradius) -> neighborlist
        """
        this = _sim2dlong.new_neighborlist(*args)
        try: self.this.append(this)
        except: self.this = this
    def update(self, *args) -> "void" :
        """update(neighborlist self, Box newbox)"""
        return _sim2dlong.neighborlist_update(self, *args)

    def update_list(self, force : 'bool'=True) -> "bool" :
        """
        update_list(neighborlist self, bool force=True) -> bool
        update_list(neighborlist self) -> bool
        """
        return _sim2dlong.neighborlist_update_list(self, force)

    def which(self) -> "uint" :
        """which(neighborlist self) -> uint"""
        return _sim2dlong.neighborlist_which(self)

    def numpairs(self) -> "uint" :
        """numpairs(neighborlist self) -> uint"""
        return _sim2dlong.neighborlist_numpairs(self)

    def ignore(self, *args) -> "void" :
        """
        ignore(neighborlist self, atomid a, atomid b)
        ignore(neighborlist self, atom arg2, atom arg3)
        """
        return _sim2dlong.neighborlist_ignore(self, *args)

    def add(self, *args) -> "atomid" :
        """add(neighborlist self, atom a) -> atomid"""
        return _sim2dlong.neighborlist_add(self, *args)

    def changesize(self, *args) -> "void" :
        """
        changesize(neighborlist self, flt inner, flt outer)
        changesize(neighborlist self, flt ratio)
        """
        return _sim2dlong.neighborlist_changesize(self, *args)

    def ignore_size(self) -> "uint" :
        """ignore_size(neighborlist self) -> uint"""
        return _sim2dlong.neighborlist_ignore_size(self)

    def size(self) -> "uint" :
        """size(neighborlist self) -> uint"""
        return _sim2dlong.neighborlist_size(self)

    def begin(self) -> "std::vector< idpair,std::allocator< idpair > >::iterator" :
        """begin(neighborlist self) -> std::vector< idpair,std::allocator< idpair > >::iterator"""
        return _sim2dlong.neighborlist_begin(self)

    def end(self) -> "std::vector< idpair,std::allocator< idpair > >::iterator" :
        """end(neighborlist self) -> std::vector< idpair,std::allocator< idpair > >::iterator"""
        return _sim2dlong.neighborlist_end(self)

    def get(self, *args) -> "idpair" :
        """get(neighborlist self, uint i) -> idpair"""
        return _sim2dlong.neighborlist_get(self, *args)

    __swig_destroy__ = _sim2dlong.delete_neighborlist
    __del__ = lambda self : None;
    def __getitem__(self, *args) -> "idpair" :
        """__getitem__(neighborlist self, size_t i) -> idpair"""
        return _sim2dlong.neighborlist___getitem__(self, *args)

    def __iter__(self):
        for i in range(self.numpairs()):
            yield self[i]

neighborlist_swigregister = _sim2dlong.neighborlist_swigregister
neighborlist_swigregister(neighborlist)


def neighborlistL(*args) -> "neighborlist *" :
  """neighborlistL(Box box, double const innerradius, double const outerradius) -> neighborlist"""
  return _sim2dlong.neighborlistL(*args)
class ContactTracker(statetracker):
    """Proxy of C++ ContactTracker class"""
    __swig_setmethods__ = {}
    for _s in [statetracker]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ContactTracker, name, value)
    __swig_getmethods__ = {}
    for _s in [statetracker]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ContactTracker, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(ContactTracker self, Box box, atomgroup atoms, ldvector dists) -> ContactTracker"""
        this = _sim2dlong.new_ContactTracker(*args)
        try: self.this.append(this)
        except: self.this = this
    def update(self, *args) -> "void" :
        """update(ContactTracker self, Box box)"""
        return _sim2dlong.ContactTracker_update(self, *args)

    def broken(self) -> "unsigned long long" :
        """broken(ContactTracker self) -> unsigned long long"""
        return _sim2dlong.ContactTracker_broken(self)

    def formed(self) -> "unsigned long long" :
        """formed(ContactTracker self) -> unsigned long long"""
        return _sim2dlong.ContactTracker_formed(self)

    def number(self) -> "unsigned long long" :
        """number(ContactTracker self) -> unsigned long long"""
        return _sim2dlong.ContactTracker_number(self)

    __swig_destroy__ = _sim2dlong.delete_ContactTracker
    __del__ = lambda self : None;
ContactTracker_swigregister = _sim2dlong.ContactTracker_swigregister
ContactTracker_swigregister(ContactTracker)


def ContactTrackerD(*args) -> "ContactTracker *" :
  """ContactTrackerD(Box box, atomgroup atoms, dvector dists) -> ContactTracker"""
  return _sim2dlong.ContactTrackerD(*args)
class EnergyTracker(statetracker):
    """Proxy of C++ EnergyTracker class"""
    __swig_setmethods__ = {}
    for _s in [statetracker]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, EnergyTracker, name, value)
    __swig_getmethods__ = {}
    for _s in [statetracker]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, EnergyTracker, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(EnergyTracker self, atomgroup atoms, ivector interactions, uint nskip=1) -> EnergyTracker
        __init__(EnergyTracker self, atomgroup atoms, ivector interactions) -> EnergyTracker
        """
        this = _sim2dlong.new_EnergyTracker(*args)
        try: self.this.append(this)
        except: self.this = this
    def update(self, *args) -> "void" :
        """update(EnergyTracker self, Box box)"""
        return _sim2dlong.EnergyTracker_update(self, *args)

    def reset(self) -> "void" :
        """reset(EnergyTracker self)"""
        return _sim2dlong.EnergyTracker_reset(self)

    def setU0(self, *args) -> "void" :
        """
        setU0(EnergyTracker self, flt newU0)
        setU0(EnergyTracker self, Box box)
        """
        return _sim2dlong.EnergyTracker_setU0(self, *args)

    def getU0(self) -> "flt" :
        """getU0(EnergyTracker self) -> flt"""
        return _sim2dlong.EnergyTracker_getU0(self)

    def E(self) -> "flt" :
        """E(EnergyTracker self) -> flt"""
        return _sim2dlong.EnergyTracker_E(self)

    def U(self) -> "flt" :
        """U(EnergyTracker self) -> flt"""
        return _sim2dlong.EnergyTracker_U(self)

    def K(self) -> "flt" :
        """K(EnergyTracker self) -> flt"""
        return _sim2dlong.EnergyTracker_K(self)

    def Estd(self) -> "flt" :
        """Estd(EnergyTracker self) -> flt"""
        return _sim2dlong.EnergyTracker_Estd(self)

    def Kstd(self) -> "flt" :
        """Kstd(EnergyTracker self) -> flt"""
        return _sim2dlong.EnergyTracker_Kstd(self)

    def Ustd(self) -> "flt" :
        """Ustd(EnergyTracker self) -> flt"""
        return _sim2dlong.EnergyTracker_Ustd(self)

    def Esqmean(self) -> "flt" :
        """Esqmean(EnergyTracker self) -> flt"""
        return _sim2dlong.EnergyTracker_Esqmean(self)

    def Ksqmean(self) -> "flt" :
        """Ksqmean(EnergyTracker self) -> flt"""
        return _sim2dlong.EnergyTracker_Ksqmean(self)

    def Usqmean(self) -> "flt" :
        """Usqmean(EnergyTracker self) -> flt"""
        return _sim2dlong.EnergyTracker_Usqmean(self)

    def n(self) -> "uint" :
        """n(EnergyTracker self) -> uint"""
        return _sim2dlong.EnergyTracker_n(self)

    __swig_destroy__ = _sim2dlong.delete_EnergyTracker
    __del__ = lambda self : None;
EnergyTracker_swigregister = _sim2dlong.EnergyTracker_swigregister
EnergyTracker_swigregister(EnergyTracker)

class Charged(atomid):
    """Proxy of C++ Charged class"""
    __swig_setmethods__ = {}
    for _s in [atomid]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Charged, name, value)
    __swig_getmethods__ = {}
    for _s in [atomid]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Charged, name)
    __repr__ = _swig_repr
    __swig_setmethods__["q"] = _sim2dlong.Charged_q_set
    __swig_getmethods__["q"] = _sim2dlong.Charged_q_get
    if _newclass:q = _swig_property(_sim2dlong.Charged_q_get, _sim2dlong.Charged_q_set)
    def __init__(self, *args): 
        """
        __init__(Charged self) -> Charged
        __init__(Charged self, flt q, atom a) -> Charged
        """
        this = _sim2dlong.new_Charged(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _sim2dlong.delete_Charged
    __del__ = lambda self : None;
Charged_swigregister = _sim2dlong.Charged_swigregister
Charged_swigregister(Charged)

class ChargePair(_object):
    """Proxy of C++ ChargePair class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ChargePair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ChargePair, name)
    __repr__ = _swig_repr
    __swig_setmethods__["q1q2"] = _sim2dlong.ChargePair_q1q2_set
    __swig_getmethods__["q1q2"] = _sim2dlong.ChargePair_q1q2_get
    if _newclass:q1q2 = _swig_property(_sim2dlong.ChargePair_q1q2_get, _sim2dlong.ChargePair_q1q2_set)
    __swig_setmethods__["atom1"] = _sim2dlong.ChargePair_atom1_set
    __swig_getmethods__["atom1"] = _sim2dlong.ChargePair_atom1_get
    if _newclass:atom1 = _swig_property(_sim2dlong.ChargePair_atom1_get, _sim2dlong.ChargePair_atom1_set)
    __swig_setmethods__["atom2"] = _sim2dlong.ChargePair_atom2_set
    __swig_getmethods__["atom2"] = _sim2dlong.ChargePair_atom2_get
    if _newclass:atom2 = _swig_property(_sim2dlong.ChargePair_atom2_get, _sim2dlong.ChargePair_atom2_set)
    def __init__(self, *args): 
        """__init__(ChargePair self, Charged a1, Charged a2) -> ChargePair"""
        this = _sim2dlong.new_ChargePair(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _sim2dlong.delete_ChargePair
    __del__ = lambda self : None;
ChargePair_swigregister = _sim2dlong.ChargePair_swigregister
ChargePair_swigregister(ChargePair)

class LJatom(atomid):
    """Proxy of C++ LJatom class"""
    __swig_setmethods__ = {}
    for _s in [atomid]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJatom, name, value)
    __swig_getmethods__ = {}
    for _s in [atomid]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LJatom, name)
    __repr__ = _swig_repr
    __swig_setmethods__["epsilon"] = _sim2dlong.LJatom_epsilon_set
    __swig_getmethods__["epsilon"] = _sim2dlong.LJatom_epsilon_get
    if _newclass:epsilon = _swig_property(_sim2dlong.LJatom_epsilon_get, _sim2dlong.LJatom_epsilon_set)
    __swig_setmethods__["sigma"] = _sim2dlong.LJatom_sigma_set
    __swig_getmethods__["sigma"] = _sim2dlong.LJatom_sigma_get
    if _newclass:sigma = _swig_property(_sim2dlong.LJatom_sigma_get, _sim2dlong.LJatom_sigma_set)
    def __init__(self, *args): 
        """
        __init__(LJatom self, flt epsilon, flt sigma, atom a) -> LJatom
        __init__(LJatom self, atomid a, LJatom other) -> LJatom
        """
        this = _sim2dlong.new_LJatom(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _sim2dlong.delete_LJatom
    __del__ = lambda self : None;
LJatom_swigregister = _sim2dlong.LJatom_swigregister
LJatom_swigregister(LJatom)

class LJpair(_object):
    """Proxy of C++ LJpair class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJpair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LJpair, name)
    __repr__ = _swig_repr
    __swig_setmethods__["epsilon"] = _sim2dlong.LJpair_epsilon_set
    __swig_getmethods__["epsilon"] = _sim2dlong.LJpair_epsilon_get
    if _newclass:epsilon = _swig_property(_sim2dlong.LJpair_epsilon_get, _sim2dlong.LJpair_epsilon_set)
    __swig_setmethods__["sigma"] = _sim2dlong.LJpair_sigma_set
    __swig_getmethods__["sigma"] = _sim2dlong.LJpair_sigma_get
    if _newclass:sigma = _swig_property(_sim2dlong.LJpair_sigma_get, _sim2dlong.LJpair_sigma_set)
    __swig_setmethods__["atom1"] = _sim2dlong.LJpair_atom1_set
    __swig_getmethods__["atom1"] = _sim2dlong.LJpair_atom1_get
    if _newclass:atom1 = _swig_property(_sim2dlong.LJpair_atom1_get, _sim2dlong.LJpair_atom1_set)
    __swig_setmethods__["atom2"] = _sim2dlong.LJpair_atom2_set
    __swig_getmethods__["atom2"] = _sim2dlong.LJpair_atom2_get
    if _newclass:atom2 = _swig_property(_sim2dlong.LJpair_atom2_get, _sim2dlong.LJpair_atom2_set)
    def __init__(self, *args): 
        """__init__(LJpair self, LJatom LJ1, LJatom LJ2) -> LJpair"""
        this = _sim2dlong.new_LJpair(*args)
        try: self.this.append(this)
        except: self.this = this
    def energy(self, *args) -> "flt" :
        """energy(LJpair self, Box box) -> flt"""
        return _sim2dlong.LJpair_energy(self, *args)

    def forces(self, *args) -> "Vec" :
        """forces(LJpair self, Box box) -> VecL"""
        return _sim2dlong.LJpair_forces(self, *args)

    __swig_destroy__ = _sim2dlong.delete_LJpair
    __del__ = lambda self : None;
LJpair_swigregister = _sim2dlong.LJpair_swigregister
LJpair_swigregister(LJpair)

class LJatomcut(LJatom):
    """Proxy of C++ LJatomcut class"""
    __swig_setmethods__ = {}
    for _s in [LJatom]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJatomcut, name, value)
    __swig_getmethods__ = {}
    for _s in [LJatom]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LJatomcut, name)
    __repr__ = _swig_repr
    __swig_setmethods__["sigcut"] = _sim2dlong.LJatomcut_sigcut_set
    __swig_getmethods__["sigcut"] = _sim2dlong.LJatomcut_sigcut_get
    if _newclass:sigcut = _swig_property(_sim2dlong.LJatomcut_sigcut_get, _sim2dlong.LJatomcut_sigcut_set)
    def __init__(self, *args): 
        """
        __init__(LJatomcut self, flt epsilon, flt sigma, atom a, flt cut) -> LJatomcut
        __init__(LJatomcut self, atomid a, LJatomcut other) -> LJatomcut
        """
        this = _sim2dlong.new_LJatomcut(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _sim2dlong.delete_LJatomcut
    __del__ = lambda self : None;
LJatomcut_swigregister = _sim2dlong.LJatomcut_swigregister
LJatomcut_swigregister(LJatomcut)

class LJAttractPair(_object):
    """Proxy of C++ LJAttractPair class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJAttractPair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LJAttractPair, name)
    __repr__ = _swig_repr
    __swig_setmethods__["inter"] = _sim2dlong.LJAttractPair_inter_set
    __swig_getmethods__["inter"] = _sim2dlong.LJAttractPair_inter_get
    if _newclass:inter = _swig_property(_sim2dlong.LJAttractPair_inter_get, _sim2dlong.LJAttractPair_inter_set)
    __swig_setmethods__["atom1"] = _sim2dlong.LJAttractPair_atom1_set
    __swig_getmethods__["atom1"] = _sim2dlong.LJAttractPair_atom1_get
    if _newclass:atom1 = _swig_property(_sim2dlong.LJAttractPair_atom1_get, _sim2dlong.LJAttractPair_atom1_set)
    __swig_setmethods__["atom2"] = _sim2dlong.LJAttractPair_atom2_set
    __swig_getmethods__["atom2"] = _sim2dlong.LJAttractPair_atom2_get
    if _newclass:atom2 = _swig_property(_sim2dlong.LJAttractPair_atom2_get, _sim2dlong.LJAttractPair_atom2_set)
    def __init__(self, *args): 
        """__init__(LJAttractPair self, LJatomcut a1, LJatomcut a2) -> LJAttractPair"""
        this = _sim2dlong.new_LJAttractPair(*args)
        try: self.this.append(this)
        except: self.this = this
    def energy(self, *args) -> "flt" :
        """energy(LJAttractPair self, Box box) -> flt"""
        return _sim2dlong.LJAttractPair_energy(self, *args)

    def forces(self, *args) -> "Vec" :
        """forces(LJAttractPair self, Box box) -> VecL"""
        return _sim2dlong.LJAttractPair_forces(self, *args)

    __swig_destroy__ = _sim2dlong.delete_LJAttractPair
    __del__ = lambda self : None;
LJAttractPair_swigregister = _sim2dlong.LJAttractPair_swigregister
LJAttractPair_swigregister(LJAttractPair)

class HydroAtom(atomid):
    """Proxy of C++ HydroAtom class"""
    __swig_setmethods__ = {}
    for _s in [atomid]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HydroAtom, name, value)
    __swig_getmethods__ = {}
    for _s in [atomid]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, HydroAtom, name)
    __repr__ = _swig_repr
    __swig_setmethods__["epsilons"] = _sim2dlong.HydroAtom_epsilons_set
    __swig_getmethods__["epsilons"] = _sim2dlong.HydroAtom_epsilons_get
    if _newclass:epsilons = _swig_property(_sim2dlong.HydroAtom_epsilons_get, _sim2dlong.HydroAtom_epsilons_set)
    __swig_setmethods__["indx"] = _sim2dlong.HydroAtom_indx_set
    __swig_getmethods__["indx"] = _sim2dlong.HydroAtom_indx_get
    if _newclass:indx = _swig_property(_sim2dlong.HydroAtom_indx_get, _sim2dlong.HydroAtom_indx_set)
    __swig_setmethods__["sigma"] = _sim2dlong.HydroAtom_sigma_set
    __swig_getmethods__["sigma"] = _sim2dlong.HydroAtom_sigma_get
    if _newclass:sigma = _swig_property(_sim2dlong.HydroAtom_sigma_get, _sim2dlong.HydroAtom_sigma_set)
    __swig_setmethods__["sigcut"] = _sim2dlong.HydroAtom_sigcut_set
    __swig_getmethods__["sigcut"] = _sim2dlong.HydroAtom_sigcut_get
    if _newclass:sigcut = _swig_property(_sim2dlong.HydroAtom_sigcut_get, _sim2dlong.HydroAtom_sigcut_set)
    def __init__(self, *args): 
        """
        __init__(HydroAtom self, ldvector epsilons, uint indx, flt sigma, atom a, flt cut) -> HydroAtom
        __init__(HydroAtom self, atomid a, HydroAtom other) -> HydroAtom
        """
        this = _sim2dlong.new_HydroAtom(*args)
        try: self.this.append(this)
        except: self.this = this
    def getEpsilon(self, *args) -> "flt" :
        """getEpsilon(HydroAtom self, HydroAtom other) -> flt"""
        return _sim2dlong.HydroAtom_getEpsilon(self, *args)

    __swig_destroy__ = _sim2dlong.delete_HydroAtom
    __del__ = lambda self : None;
HydroAtom_swigregister = _sim2dlong.HydroAtom_swigregister
HydroAtom_swigregister(HydroAtom)

class HydroPair(_object):
    """Proxy of C++ HydroPair class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, HydroPair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, HydroPair, name)
    __repr__ = _swig_repr
    __swig_setmethods__["inter"] = _sim2dlong.HydroPair_inter_set
    __swig_getmethods__["inter"] = _sim2dlong.HydroPair_inter_get
    if _newclass:inter = _swig_property(_sim2dlong.HydroPair_inter_get, _sim2dlong.HydroPair_inter_set)
    __swig_setmethods__["atom1"] = _sim2dlong.HydroPair_atom1_set
    __swig_getmethods__["atom1"] = _sim2dlong.HydroPair_atom1_get
    if _newclass:atom1 = _swig_property(_sim2dlong.HydroPair_atom1_get, _sim2dlong.HydroPair_atom1_set)
    __swig_setmethods__["atom2"] = _sim2dlong.HydroPair_atom2_set
    __swig_getmethods__["atom2"] = _sim2dlong.HydroPair_atom2_get
    if _newclass:atom2 = _swig_property(_sim2dlong.HydroPair_atom2_get, _sim2dlong.HydroPair_atom2_set)
    def __init__(self, *args): 
        """__init__(HydroPair self, HydroAtom a1, HydroAtom a2) -> HydroPair"""
        this = _sim2dlong.new_HydroPair(*args)
        try: self.this.append(this)
        except: self.this = this
    def energy(self, *args) -> "flt" :
        """energy(HydroPair self, Box box) -> flt"""
        return _sim2dlong.HydroPair_energy(self, *args)

    def forces(self, *args) -> "Vec" :
        """forces(HydroPair self, Box box) -> VecL"""
        return _sim2dlong.HydroPair_forces(self, *args)

    __swig_destroy__ = _sim2dlong.delete_HydroPair
    __del__ = lambda self : None;
HydroPair_swigregister = _sim2dlong.HydroPair_swigregister
HydroPair_swigregister(HydroPair)

class LJAtomIndexed(atomid):
    """Proxy of C++ LJAtomIndexed class"""
    __swig_setmethods__ = {}
    for _s in [atomid]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJAtomIndexed, name, value)
    __swig_getmethods__ = {}
    for _s in [atomid]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LJAtomIndexed, name)
    __repr__ = _swig_repr
    __swig_setmethods__["epsilons"] = _sim2dlong.LJAtomIndexed_epsilons_set
    __swig_getmethods__["epsilons"] = _sim2dlong.LJAtomIndexed_epsilons_get
    if _newclass:epsilons = _swig_property(_sim2dlong.LJAtomIndexed_epsilons_get, _sim2dlong.LJAtomIndexed_epsilons_set)
    __swig_setmethods__["sigmas"] = _sim2dlong.LJAtomIndexed_sigmas_set
    __swig_getmethods__["sigmas"] = _sim2dlong.LJAtomIndexed_sigmas_get
    if _newclass:sigmas = _swig_property(_sim2dlong.LJAtomIndexed_sigmas_get, _sim2dlong.LJAtomIndexed_sigmas_set)
    __swig_setmethods__["indx"] = _sim2dlong.LJAtomIndexed_indx_set
    __swig_getmethods__["indx"] = _sim2dlong.LJAtomIndexed_indx_get
    if _newclass:indx = _swig_property(_sim2dlong.LJAtomIndexed_indx_get, _sim2dlong.LJAtomIndexed_indx_set)
    __swig_setmethods__["sigcut"] = _sim2dlong.LJAtomIndexed_sigcut_set
    __swig_getmethods__["sigcut"] = _sim2dlong.LJAtomIndexed_sigcut_get
    if _newclass:sigcut = _swig_property(_sim2dlong.LJAtomIndexed_sigcut_get, _sim2dlong.LJAtomIndexed_sigcut_set)
    def __init__(self, *args): 
        """
        __init__(LJAtomIndexed self, ldvector epsilons, ldvector sigmas, uint indx, atom a, flt cut) -> LJAtomIndexed
        __init__(LJAtomIndexed self, atomid a, LJAtomIndexed other) -> LJAtomIndexed
        """
        this = _sim2dlong.new_LJAtomIndexed(*args)
        try: self.this.append(this)
        except: self.this = this
    def getEpsilon(self, *args) -> "flt" :
        """getEpsilon(LJAtomIndexed self, LJAtomIndexed other) -> flt"""
        return _sim2dlong.LJAtomIndexed_getEpsilon(self, *args)

    def getSigma(self, *args) -> "flt" :
        """getSigma(LJAtomIndexed self, LJAtomIndexed other) -> flt"""
        return _sim2dlong.LJAtomIndexed_getSigma(self, *args)

    __swig_destroy__ = _sim2dlong.delete_LJAtomIndexed
    __del__ = lambda self : None;
LJAtomIndexed_swigregister = _sim2dlong.LJAtomIndexed_swigregister
LJAtomIndexed_swigregister(LJAtomIndexed)

class LJFullPair(_object):
    """Proxy of C++ LJFullPair class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJFullPair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LJFullPair, name)
    __repr__ = _swig_repr
    __swig_setmethods__["inter"] = _sim2dlong.LJFullPair_inter_set
    __swig_getmethods__["inter"] = _sim2dlong.LJFullPair_inter_get
    if _newclass:inter = _swig_property(_sim2dlong.LJFullPair_inter_get, _sim2dlong.LJFullPair_inter_set)
    __swig_setmethods__["atom1"] = _sim2dlong.LJFullPair_atom1_set
    __swig_getmethods__["atom1"] = _sim2dlong.LJFullPair_atom1_get
    if _newclass:atom1 = _swig_property(_sim2dlong.LJFullPair_atom1_get, _sim2dlong.LJFullPair_atom1_set)
    __swig_setmethods__["atom2"] = _sim2dlong.LJFullPair_atom2_set
    __swig_getmethods__["atom2"] = _sim2dlong.LJFullPair_atom2_get
    if _newclass:atom2 = _swig_property(_sim2dlong.LJFullPair_atom2_get, _sim2dlong.LJFullPair_atom2_set)
    def __init__(self, *args): 
        """__init__(LJFullPair self, LJAtomIndexed a1, LJAtomIndexed a2) -> LJFullPair"""
        this = _sim2dlong.new_LJFullPair(*args)
        try: self.this.append(this)
        except: self.this = this
    def energy(self, *args) -> "flt" :
        """energy(LJFullPair self, Box box) -> flt"""
        return _sim2dlong.LJFullPair_energy(self, *args)

    def forces(self, *args) -> "Vec" :
        """forces(LJFullPair self, Box box) -> VecL"""
        return _sim2dlong.LJFullPair_forces(self, *args)

    __swig_destroy__ = _sim2dlong.delete_LJFullPair
    __del__ = lambda self : None;
LJFullPair_swigregister = _sim2dlong.LJFullPair_swigregister
LJFullPair_swigregister(LJFullPair)

class LJishAtom(atomid):
    """Proxy of C++ LJishAtom class"""
    __swig_setmethods__ = {}
    for _s in [atomid]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJishAtom, name, value)
    __swig_getmethods__ = {}
    for _s in [atomid]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LJishAtom, name)
    __repr__ = _swig_repr
    __swig_setmethods__["epsilons"] = _sim2dlong.LJishAtom_epsilons_set
    __swig_getmethods__["epsilons"] = _sim2dlong.LJishAtom_epsilons_get
    if _newclass:epsilons = _swig_property(_sim2dlong.LJishAtom_epsilons_get, _sim2dlong.LJishAtom_epsilons_set)
    __swig_setmethods__["repeps"] = _sim2dlong.LJishAtom_repeps_set
    __swig_getmethods__["repeps"] = _sim2dlong.LJishAtom_repeps_get
    if _newclass:repeps = _swig_property(_sim2dlong.LJishAtom_repeps_get, _sim2dlong.LJishAtom_repeps_set)
    __swig_setmethods__["sigma"] = _sim2dlong.LJishAtom_sigma_set
    __swig_getmethods__["sigma"] = _sim2dlong.LJishAtom_sigma_get
    if _newclass:sigma = _swig_property(_sim2dlong.LJishAtom_sigma_get, _sim2dlong.LJishAtom_sigma_set)
    __swig_setmethods__["exponent"] = _sim2dlong.LJishAtom_exponent_set
    __swig_getmethods__["exponent"] = _sim2dlong.LJishAtom_exponent_get
    if _newclass:exponent = _swig_property(_sim2dlong.LJishAtom_exponent_get, _sim2dlong.LJishAtom_exponent_set)
    __swig_setmethods__["indx"] = _sim2dlong.LJishAtom_indx_set
    __swig_getmethods__["indx"] = _sim2dlong.LJishAtom_indx_get
    if _newclass:indx = _swig_property(_sim2dlong.LJishAtom_indx_get, _sim2dlong.LJishAtom_indx_set)
    __swig_setmethods__["sigcut"] = _sim2dlong.LJishAtom_sigcut_set
    __swig_getmethods__["sigcut"] = _sim2dlong.LJishAtom_sigcut_get
    if _newclass:sigcut = _swig_property(_sim2dlong.LJishAtom_sigcut_get, _sim2dlong.LJishAtom_sigcut_set)
    def __init__(self, *args): 
        """
        __init__(LJishAtom self, atom a, ldvector epsilons, flt repeps, flt sigma, flt n, uint indx, flt cut) -> LJishAtom
        __init__(LJishAtom self, atomid a, LJishAtom other) -> LJishAtom
        """
        this = _sim2dlong.new_LJishAtom(*args)
        try: self.this.append(this)
        except: self.this = this
    def getEpsilon(self, *args) -> "flt" :
        """getEpsilon(LJishAtom self, LJishAtom other) -> flt"""
        return _sim2dlong.LJishAtom_getEpsilon(self, *args)

    def getSigma(self, *args) -> "flt" :
        """getSigma(LJishAtom self, LJishAtom other) -> flt"""
        return _sim2dlong.LJishAtom_getSigma(self, *args)

    __swig_destroy__ = _sim2dlong.delete_LJishAtom
    __del__ = lambda self : None;
LJishAtom_swigregister = _sim2dlong.LJishAtom_swigregister
LJishAtom_swigregister(LJishAtom)

class LJishPair(_object):
    """Proxy of C++ LJishPair class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJishPair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LJishPair, name)
    __repr__ = _swig_repr
    __swig_setmethods__["epsilon"] = _sim2dlong.LJishPair_epsilon_set
    __swig_getmethods__["epsilon"] = _sim2dlong.LJishPair_epsilon_get
    if _newclass:epsilon = _swig_property(_sim2dlong.LJishPair_epsilon_get, _sim2dlong.LJishPair_epsilon_set)
    __swig_setmethods__["repeps"] = _sim2dlong.LJishPair_repeps_set
    __swig_getmethods__["repeps"] = _sim2dlong.LJishPair_repeps_get
    if _newclass:repeps = _swig_property(_sim2dlong.LJishPair_repeps_get, _sim2dlong.LJishPair_repeps_set)
    __swig_setmethods__["sigma"] = _sim2dlong.LJishPair_sigma_set
    __swig_getmethods__["sigma"] = _sim2dlong.LJishPair_sigma_get
    if _newclass:sigma = _swig_property(_sim2dlong.LJishPair_sigma_get, _sim2dlong.LJishPair_sigma_set)
    __swig_setmethods__["n"] = _sim2dlong.LJishPair_n_set
    __swig_getmethods__["n"] = _sim2dlong.LJishPair_n_get
    if _newclass:n = _swig_property(_sim2dlong.LJishPair_n_get, _sim2dlong.LJishPair_n_set)
    __swig_setmethods__["cutR"] = _sim2dlong.LJishPair_cutR_set
    __swig_getmethods__["cutR"] = _sim2dlong.LJishPair_cutR_get
    if _newclass:cutR = _swig_property(_sim2dlong.LJishPair_cutR_get, _sim2dlong.LJishPair_cutR_set)
    __swig_setmethods__["cutE"] = _sim2dlong.LJishPair_cutE_set
    __swig_getmethods__["cutE"] = _sim2dlong.LJishPair_cutE_get
    if _newclass:cutE = _swig_property(_sim2dlong.LJishPair_cutE_get, _sim2dlong.LJishPair_cutE_set)
    __swig_setmethods__["atom1"] = _sim2dlong.LJishPair_atom1_set
    __swig_getmethods__["atom1"] = _sim2dlong.LJishPair_atom1_get
    if _newclass:atom1 = _swig_property(_sim2dlong.LJishPair_atom1_get, _sim2dlong.LJishPair_atom1_set)
    __swig_setmethods__["atom2"] = _sim2dlong.LJishPair_atom2_set
    __swig_getmethods__["atom2"] = _sim2dlong.LJishPair_atom2_get
    if _newclass:atom2 = _swig_property(_sim2dlong.LJishPair_atom2_get, _sim2dlong.LJishPair_atom2_set)
    def __init__(self, *args): 
        """__init__(LJishPair self, LJishAtom LJ1, LJishAtom LJ2) -> LJishPair"""
        this = _sim2dlong.new_LJishPair(*args)
        try: self.this.append(this)
        except: self.this = this
    def energy(self, *args) -> "flt" :
        """energy(LJishPair self, Box box) -> flt"""
        return _sim2dlong.LJishPair_energy(self, *args)

    def forces(self, *args) -> "Vec" :
        """forces(LJishPair self, Box box) -> VecL"""
        return _sim2dlong.LJishPair_forces(self, *args)

    __swig_destroy__ = _sim2dlong.delete_LJishPair
    __del__ = lambda self : None;
LJishPair_swigregister = _sim2dlong.LJishPair_swigregister
LJishPair_swigregister(LJishPair)

class LJAttractRepulseAtom(atomid):
    """Proxy of C++ LJAttractRepulseAtom class"""
    __swig_setmethods__ = {}
    for _s in [atomid]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJAttractRepulseAtom, name, value)
    __swig_getmethods__ = {}
    for _s in [atomid]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LJAttractRepulseAtom, name)
    __repr__ = _swig_repr
    __swig_setmethods__["epsilons"] = _sim2dlong.LJAttractRepulseAtom_epsilons_set
    __swig_getmethods__["epsilons"] = _sim2dlong.LJAttractRepulseAtom_epsilons_get
    if _newclass:epsilons = _swig_property(_sim2dlong.LJAttractRepulseAtom_epsilons_get, _sim2dlong.LJAttractRepulseAtom_epsilons_set)
    __swig_setmethods__["sig"] = _sim2dlong.LJAttractRepulseAtom_sig_set
    __swig_getmethods__["sig"] = _sim2dlong.LJAttractRepulseAtom_sig_get
    if _newclass:sig = _swig_property(_sim2dlong.LJAttractRepulseAtom_sig_get, _sim2dlong.LJAttractRepulseAtom_sig_set)
    __swig_setmethods__["indx"] = _sim2dlong.LJAttractRepulseAtom_indx_set
    __swig_getmethods__["indx"] = _sim2dlong.LJAttractRepulseAtom_indx_get
    if _newclass:indx = _swig_property(_sim2dlong.LJAttractRepulseAtom_indx_get, _sim2dlong.LJAttractRepulseAtom_indx_set)
    __swig_setmethods__["sigcut"] = _sim2dlong.LJAttractRepulseAtom_sigcut_set
    __swig_getmethods__["sigcut"] = _sim2dlong.LJAttractRepulseAtom_sigcut_get
    if _newclass:sigcut = _swig_property(_sim2dlong.LJAttractRepulseAtom_sigcut_get, _sim2dlong.LJAttractRepulseAtom_sigcut_set)
    def __init__(self, *args): 
        """
        __init__(LJAttractRepulseAtom self, atom a, ldvector epsilons, flt sigma, uint indx, flt cut) -> LJAttractRepulseAtom
        __init__(LJAttractRepulseAtom self, atomid a, LJAttractRepulseAtom other) -> LJAttractRepulseAtom
        """
        this = _sim2dlong.new_LJAttractRepulseAtom(*args)
        try: self.this.append(this)
        except: self.this = this
    def getEpsilon(self, *args) -> "flt" :
        """getEpsilon(LJAttractRepulseAtom self, LJAttractRepulseAtom other) -> flt"""
        return _sim2dlong.LJAttractRepulseAtom_getEpsilon(self, *args)

    __swig_destroy__ = _sim2dlong.delete_LJAttractRepulseAtom
    __del__ = lambda self : None;
LJAttractRepulseAtom_swigregister = _sim2dlong.LJAttractRepulseAtom_swigregister
LJAttractRepulseAtom_swigregister(LJAttractRepulseAtom)

class LJAttractRepulsePair(_object):
    """Proxy of C++ LJAttractRepulsePair class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJAttractRepulsePair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LJAttractRepulsePair, name)
    __repr__ = _swig_repr
    __swig_setmethods__["eps"] = _sim2dlong.LJAttractRepulsePair_eps_set
    __swig_getmethods__["eps"] = _sim2dlong.LJAttractRepulsePair_eps_get
    if _newclass:eps = _swig_property(_sim2dlong.LJAttractRepulsePair_eps_get, _sim2dlong.LJAttractRepulsePair_eps_set)
    __swig_setmethods__["sig"] = _sim2dlong.LJAttractRepulsePair_sig_set
    __swig_getmethods__["sig"] = _sim2dlong.LJAttractRepulsePair_sig_get
    if _newclass:sig = _swig_property(_sim2dlong.LJAttractRepulsePair_sig_get, _sim2dlong.LJAttractRepulsePair_sig_set)
    __swig_setmethods__["cutR"] = _sim2dlong.LJAttractRepulsePair_cutR_set
    __swig_getmethods__["cutR"] = _sim2dlong.LJAttractRepulsePair_cutR_get
    if _newclass:cutR = _swig_property(_sim2dlong.LJAttractRepulsePair_cutR_get, _sim2dlong.LJAttractRepulsePair_cutR_set)
    __swig_setmethods__["cutE"] = _sim2dlong.LJAttractRepulsePair_cutE_set
    __swig_getmethods__["cutE"] = _sim2dlong.LJAttractRepulsePair_cutE_get
    if _newclass:cutE = _swig_property(_sim2dlong.LJAttractRepulsePair_cutE_get, _sim2dlong.LJAttractRepulsePair_cutE_set)
    __swig_setmethods__["atom1"] = _sim2dlong.LJAttractRepulsePair_atom1_set
    __swig_getmethods__["atom1"] = _sim2dlong.LJAttractRepulsePair_atom1_get
    if _newclass:atom1 = _swig_property(_sim2dlong.LJAttractRepulsePair_atom1_get, _sim2dlong.LJAttractRepulsePair_atom1_set)
    __swig_setmethods__["atom2"] = _sim2dlong.LJAttractRepulsePair_atom2_set
    __swig_getmethods__["atom2"] = _sim2dlong.LJAttractRepulsePair_atom2_get
    if _newclass:atom2 = _swig_property(_sim2dlong.LJAttractRepulsePair_atom2_get, _sim2dlong.LJAttractRepulsePair_atom2_set)
    def __init__(self, *args): 
        """__init__(LJAttractRepulsePair self, LJAttractRepulseAtom a1, LJAttractRepulseAtom a2) -> LJAttractRepulsePair"""
        this = _sim2dlong.new_LJAttractRepulsePair(*args)
        try: self.this.append(this)
        except: self.this = this
    def energy(self, *args) -> "flt" :
        """energy(LJAttractRepulsePair self, Box box) -> flt"""
        return _sim2dlong.LJAttractRepulsePair_energy(self, *args)

    def forces(self, *args) -> "Vec" :
        """forces(LJAttractRepulsePair self, Box box) -> VecL"""
        return _sim2dlong.LJAttractRepulsePair_forces(self, *args)

    __swig_destroy__ = _sim2dlong.delete_LJAttractRepulsePair
    __del__ = lambda self : None;
LJAttractRepulsePair_swigregister = _sim2dlong.LJAttractRepulsePair_swigregister
LJAttractRepulsePair_swigregister(LJAttractRepulsePair)

class LJAttractFixedRepulseAtom(atomid):
    """Proxy of C++ LJAttractFixedRepulseAtom class"""
    __swig_setmethods__ = {}
    for _s in [atomid]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJAttractFixedRepulseAtom, name, value)
    __swig_getmethods__ = {}
    for _s in [atomid]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LJAttractFixedRepulseAtom, name)
    __repr__ = _swig_repr
    __swig_setmethods__["epsilons"] = _sim2dlong.LJAttractFixedRepulseAtom_epsilons_set
    __swig_getmethods__["epsilons"] = _sim2dlong.LJAttractFixedRepulseAtom_epsilons_get
    if _newclass:epsilons = _swig_property(_sim2dlong.LJAttractFixedRepulseAtom_epsilons_get, _sim2dlong.LJAttractFixedRepulseAtom_epsilons_set)
    __swig_setmethods__["repeps"] = _sim2dlong.LJAttractFixedRepulseAtom_repeps_set
    __swig_getmethods__["repeps"] = _sim2dlong.LJAttractFixedRepulseAtom_repeps_get
    if _newclass:repeps = _swig_property(_sim2dlong.LJAttractFixedRepulseAtom_repeps_get, _sim2dlong.LJAttractFixedRepulseAtom_repeps_set)
    __swig_setmethods__["sig"] = _sim2dlong.LJAttractFixedRepulseAtom_sig_set
    __swig_getmethods__["sig"] = _sim2dlong.LJAttractFixedRepulseAtom_sig_get
    if _newclass:sig = _swig_property(_sim2dlong.LJAttractFixedRepulseAtom_sig_get, _sim2dlong.LJAttractFixedRepulseAtom_sig_set)
    __swig_setmethods__["indx"] = _sim2dlong.LJAttractFixedRepulseAtom_indx_set
    __swig_getmethods__["indx"] = _sim2dlong.LJAttractFixedRepulseAtom_indx_get
    if _newclass:indx = _swig_property(_sim2dlong.LJAttractFixedRepulseAtom_indx_get, _sim2dlong.LJAttractFixedRepulseAtom_indx_set)
    __swig_setmethods__["sigcut"] = _sim2dlong.LJAttractFixedRepulseAtom_sigcut_set
    __swig_getmethods__["sigcut"] = _sim2dlong.LJAttractFixedRepulseAtom_sigcut_get
    if _newclass:sigcut = _swig_property(_sim2dlong.LJAttractFixedRepulseAtom_sigcut_get, _sim2dlong.LJAttractFixedRepulseAtom_sigcut_set)
    def __init__(self, *args): 
        """
        __init__(LJAttractFixedRepulseAtom self, atom a, ldvector epsilons, flt repeps, flt sigma, uint indx, flt cut) -> LJAttractFixedRepulseAtom
        __init__(LJAttractFixedRepulseAtom self, atomid a, LJAttractFixedRepulseAtom other) -> LJAttractFixedRepulseAtom
        """
        this = _sim2dlong.new_LJAttractFixedRepulseAtom(*args)
        try: self.this.append(this)
        except: self.this = this
    def getEpsilon(self, *args) -> "flt" :
        """getEpsilon(LJAttractFixedRepulseAtom self, LJAttractFixedRepulseAtom other) -> flt"""
        return _sim2dlong.LJAttractFixedRepulseAtom_getEpsilon(self, *args)

    __swig_destroy__ = _sim2dlong.delete_LJAttractFixedRepulseAtom
    __del__ = lambda self : None;
LJAttractFixedRepulseAtom_swigregister = _sim2dlong.LJAttractFixedRepulseAtom_swigregister
LJAttractFixedRepulseAtom_swigregister(LJAttractFixedRepulseAtom)

class LJAttractFixedRepulsePair(_object):
    """Proxy of C++ LJAttractFixedRepulsePair class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJAttractFixedRepulsePair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LJAttractFixedRepulsePair, name)
    __repr__ = _swig_repr
    __swig_setmethods__["eps"] = _sim2dlong.LJAttractFixedRepulsePair_eps_set
    __swig_getmethods__["eps"] = _sim2dlong.LJAttractFixedRepulsePair_eps_get
    if _newclass:eps = _swig_property(_sim2dlong.LJAttractFixedRepulsePair_eps_get, _sim2dlong.LJAttractFixedRepulsePair_eps_set)
    __swig_setmethods__["repeps"] = _sim2dlong.LJAttractFixedRepulsePair_repeps_set
    __swig_getmethods__["repeps"] = _sim2dlong.LJAttractFixedRepulsePair_repeps_get
    if _newclass:repeps = _swig_property(_sim2dlong.LJAttractFixedRepulsePair_repeps_get, _sim2dlong.LJAttractFixedRepulsePair_repeps_set)
    __swig_setmethods__["sig"] = _sim2dlong.LJAttractFixedRepulsePair_sig_set
    __swig_getmethods__["sig"] = _sim2dlong.LJAttractFixedRepulsePair_sig_get
    if _newclass:sig = _swig_property(_sim2dlong.LJAttractFixedRepulsePair_sig_get, _sim2dlong.LJAttractFixedRepulsePair_sig_set)
    __swig_setmethods__["cutR"] = _sim2dlong.LJAttractFixedRepulsePair_cutR_set
    __swig_getmethods__["cutR"] = _sim2dlong.LJAttractFixedRepulsePair_cutR_get
    if _newclass:cutR = _swig_property(_sim2dlong.LJAttractFixedRepulsePair_cutR_get, _sim2dlong.LJAttractFixedRepulsePair_cutR_set)
    __swig_setmethods__["cutE"] = _sim2dlong.LJAttractFixedRepulsePair_cutE_set
    __swig_getmethods__["cutE"] = _sim2dlong.LJAttractFixedRepulsePair_cutE_get
    if _newclass:cutE = _swig_property(_sim2dlong.LJAttractFixedRepulsePair_cutE_get, _sim2dlong.LJAttractFixedRepulsePair_cutE_set)
    __swig_setmethods__["attract"] = _sim2dlong.LJAttractFixedRepulsePair_attract_set
    __swig_getmethods__["attract"] = _sim2dlong.LJAttractFixedRepulsePair_attract_get
    if _newclass:attract = _swig_property(_sim2dlong.LJAttractFixedRepulsePair_attract_get, _sim2dlong.LJAttractFixedRepulsePair_attract_set)
    __swig_setmethods__["atom1"] = _sim2dlong.LJAttractFixedRepulsePair_atom1_set
    __swig_getmethods__["atom1"] = _sim2dlong.LJAttractFixedRepulsePair_atom1_get
    if _newclass:atom1 = _swig_property(_sim2dlong.LJAttractFixedRepulsePair_atom1_get, _sim2dlong.LJAttractFixedRepulsePair_atom1_set)
    __swig_setmethods__["atom2"] = _sim2dlong.LJAttractFixedRepulsePair_atom2_set
    __swig_getmethods__["atom2"] = _sim2dlong.LJAttractFixedRepulsePair_atom2_get
    if _newclass:atom2 = _swig_property(_sim2dlong.LJAttractFixedRepulsePair_atom2_get, _sim2dlong.LJAttractFixedRepulsePair_atom2_set)
    def __init__(self, *args): 
        """
        __init__(LJAttractFixedRepulsePair self) -> LJAttractFixedRepulsePair
        __init__(LJAttractFixedRepulsePair self, LJAttractFixedRepulseAtom a1, LJAttractFixedRepulseAtom a2) -> LJAttractFixedRepulsePair
        """
        this = _sim2dlong.new_LJAttractFixedRepulsePair(*args)
        try: self.this.append(this)
        except: self.this = this
    def energy(self, *args) -> "flt" :
        """energy(LJAttractFixedRepulsePair self, Box box) -> flt"""
        return _sim2dlong.LJAttractFixedRepulsePair_energy(self, *args)

    def forces(self, *args) -> "Vec" :
        """forces(LJAttractFixedRepulsePair self, Box box) -> VecL"""
        return _sim2dlong.LJAttractFixedRepulsePair_forces(self, *args)

    __swig_destroy__ = _sim2dlong.delete_LJAttractFixedRepulsePair
    __del__ = lambda self : None;
LJAttractFixedRepulsePair_swigregister = _sim2dlong.LJAttractFixedRepulsePair_swigregister
LJAttractFixedRepulsePair_swigregister(LJAttractFixedRepulsePair)

class LJDoubleAtom(LJatom):
    """Proxy of C++ LJDoubleAtom class"""
    __swig_setmethods__ = {}
    for _s in [LJatom]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJDoubleAtom, name, value)
    __swig_getmethods__ = {}
    for _s in [LJatom]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LJDoubleAtom, name)
    __repr__ = _swig_repr
    __swig_setmethods__["epsrep"] = _sim2dlong.LJDoubleAtom_epsrep_set
    __swig_getmethods__["epsrep"] = _sim2dlong.LJDoubleAtom_epsrep_get
    if _newclass:epsrep = _swig_property(_sim2dlong.LJDoubleAtom_epsrep_get, _sim2dlong.LJDoubleAtom_epsrep_set)
    __swig_setmethods__["sigcut"] = _sim2dlong.LJDoubleAtom_sigcut_set
    __swig_getmethods__["sigcut"] = _sim2dlong.LJDoubleAtom_sigcut_get
    if _newclass:sigcut = _swig_property(_sim2dlong.LJDoubleAtom_sigcut_get, _sim2dlong.LJDoubleAtom_sigcut_set)
    def __init__(self, *args): 
        """
        __init__(LJDoubleAtom self, flt epsilon, flt epsrep, flt sigma, atom a, flt cut) -> LJDoubleAtom
        __init__(LJDoubleAtom self, atomid a, LJDoubleAtom other) -> LJDoubleAtom
        """
        this = _sim2dlong.new_LJDoubleAtom(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _sim2dlong.delete_LJDoubleAtom
    __del__ = lambda self : None;
LJDoubleAtom_swigregister = _sim2dlong.LJDoubleAtom_swigregister
LJDoubleAtom_swigregister(LJDoubleAtom)

class LJDoublePair(LJAttractFixedRepulsePair):
    """Proxy of C++ LJDoublePair class"""
    __swig_setmethods__ = {}
    for _s in [LJAttractFixedRepulsePair]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJDoublePair, name, value)
    __swig_getmethods__ = {}
    for _s in [LJAttractFixedRepulsePair]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LJDoublePair, name)
    __repr__ = _swig_repr
    __swig_setmethods__["eps"] = _sim2dlong.LJDoublePair_eps_set
    __swig_getmethods__["eps"] = _sim2dlong.LJDoublePair_eps_get
    if _newclass:eps = _swig_property(_sim2dlong.LJDoublePair_eps_get, _sim2dlong.LJDoublePair_eps_set)
    __swig_setmethods__["repeps"] = _sim2dlong.LJDoublePair_repeps_set
    __swig_getmethods__["repeps"] = _sim2dlong.LJDoublePair_repeps_get
    if _newclass:repeps = _swig_property(_sim2dlong.LJDoublePair_repeps_get, _sim2dlong.LJDoublePair_repeps_set)
    __swig_setmethods__["sig"] = _sim2dlong.LJDoublePair_sig_set
    __swig_getmethods__["sig"] = _sim2dlong.LJDoublePair_sig_get
    if _newclass:sig = _swig_property(_sim2dlong.LJDoublePair_sig_get, _sim2dlong.LJDoublePair_sig_set)
    __swig_setmethods__["cutR"] = _sim2dlong.LJDoublePair_cutR_set
    __swig_getmethods__["cutR"] = _sim2dlong.LJDoublePair_cutR_get
    if _newclass:cutR = _swig_property(_sim2dlong.LJDoublePair_cutR_get, _sim2dlong.LJDoublePair_cutR_set)
    __swig_setmethods__["cutE"] = _sim2dlong.LJDoublePair_cutE_set
    __swig_getmethods__["cutE"] = _sim2dlong.LJDoublePair_cutE_get
    if _newclass:cutE = _swig_property(_sim2dlong.LJDoublePair_cutE_get, _sim2dlong.LJDoublePair_cutE_set)
    __swig_setmethods__["attract"] = _sim2dlong.LJDoublePair_attract_set
    __swig_getmethods__["attract"] = _sim2dlong.LJDoublePair_attract_get
    if _newclass:attract = _swig_property(_sim2dlong.LJDoublePair_attract_get, _sim2dlong.LJDoublePair_attract_set)
    __swig_setmethods__["atom1"] = _sim2dlong.LJDoublePair_atom1_set
    __swig_getmethods__["atom1"] = _sim2dlong.LJDoublePair_atom1_get
    if _newclass:atom1 = _swig_property(_sim2dlong.LJDoublePair_atom1_get, _sim2dlong.LJDoublePair_atom1_set)
    __swig_setmethods__["atom2"] = _sim2dlong.LJDoublePair_atom2_set
    __swig_getmethods__["atom2"] = _sim2dlong.LJDoublePair_atom2_get
    if _newclass:atom2 = _swig_property(_sim2dlong.LJDoublePair_atom2_get, _sim2dlong.LJDoublePair_atom2_set)
    def __init__(self, *args): 
        """__init__(LJDoublePair self, LJDoubleAtom a1, LJDoubleAtom a2) -> LJDoublePair"""
        this = _sim2dlong.new_LJDoublePair(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _sim2dlong.delete_LJDoublePair
    __del__ = lambda self : None;
LJDoublePair_swigregister = _sim2dlong.LJDoublePair_swigregister
LJDoublePair_swigregister(LJDoublePair)

class EisMclachlanAtom(atomid):
    """Proxy of C++ EisMclachlanAtom class"""
    __swig_setmethods__ = {}
    for _s in [atomid]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, EisMclachlanAtom, name, value)
    __swig_getmethods__ = {}
    for _s in [atomid]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, EisMclachlanAtom, name)
    __repr__ = _swig_repr
    __swig_setmethods__["dist"] = _sim2dlong.EisMclachlanAtom_dist_set
    __swig_getmethods__["dist"] = _sim2dlong.EisMclachlanAtom_dist_get
    if _newclass:dist = _swig_property(_sim2dlong.EisMclachlanAtom_dist_get, _sim2dlong.EisMclachlanAtom_dist_set)
    __swig_setmethods__["sigmai"] = _sim2dlong.EisMclachlanAtom_sigmai_set
    __swig_getmethods__["sigmai"] = _sim2dlong.EisMclachlanAtom_sigmai_get
    if _newclass:sigmai = _swig_property(_sim2dlong.EisMclachlanAtom_sigmai_get, _sim2dlong.EisMclachlanAtom_sigmai_set)
    def __init__(self, *args): 
        """
        __init__(EisMclachlanAtom self, flt dist, flt sigmai, atom a) -> EisMclachlanAtom
        __init__(EisMclachlanAtom self, atomid a, EisMclachlanAtom other) -> EisMclachlanAtom
        """
        this = _sim2dlong.new_EisMclachlanAtom(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _sim2dlong.delete_EisMclachlanAtom
    __del__ = lambda self : None;
EisMclachlanAtom_swigregister = _sim2dlong.EisMclachlanAtom_swigregister
EisMclachlanAtom_swigregister(EisMclachlanAtom)

class EisMclachlanPair(_object):
    """Proxy of C++ EisMclachlanPair class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, EisMclachlanPair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, EisMclachlanPair, name)
    __repr__ = _swig_repr
    __swig_setmethods__["c0"] = _sim2dlong.EisMclachlanPair_c0_set
    __swig_getmethods__["c0"] = _sim2dlong.EisMclachlanPair_c0_get
    if _newclass:c0 = _swig_property(_sim2dlong.EisMclachlanPair_c0_get, _sim2dlong.EisMclachlanPair_c0_set)
    __swig_setmethods__["c1"] = _sim2dlong.EisMclachlanPair_c1_set
    __swig_getmethods__["c1"] = _sim2dlong.EisMclachlanPair_c1_get
    if _newclass:c1 = _swig_property(_sim2dlong.EisMclachlanPair_c1_get, _sim2dlong.EisMclachlanPair_c1_set)
    __swig_setmethods__["c2"] = _sim2dlong.EisMclachlanPair_c2_set
    __swig_getmethods__["c2"] = _sim2dlong.EisMclachlanPair_c2_get
    if _newclass:c2 = _swig_property(_sim2dlong.EisMclachlanPair_c2_get, _sim2dlong.EisMclachlanPair_c2_set)
    __swig_setmethods__["cutoff"] = _sim2dlong.EisMclachlanPair_cutoff_set
    __swig_getmethods__["cutoff"] = _sim2dlong.EisMclachlanPair_cutoff_get
    if _newclass:cutoff = _swig_property(_sim2dlong.EisMclachlanPair_cutoff_get, _sim2dlong.EisMclachlanPair_cutoff_set)
    __swig_setmethods__["atom1"] = _sim2dlong.EisMclachlanPair_atom1_set
    __swig_getmethods__["atom1"] = _sim2dlong.EisMclachlanPair_atom1_get
    if _newclass:atom1 = _swig_property(_sim2dlong.EisMclachlanPair_atom1_get, _sim2dlong.EisMclachlanPair_atom1_set)
    __swig_setmethods__["atom2"] = _sim2dlong.EisMclachlanPair_atom2_set
    __swig_getmethods__["atom2"] = _sim2dlong.EisMclachlanPair_atom2_get
    if _newclass:atom2 = _swig_property(_sim2dlong.EisMclachlanPair_atom2_get, _sim2dlong.EisMclachlanPair_atom2_set)
    def __init__(self, *args): 
        """__init__(EisMclachlanPair self, EisMclachlanAtom a1, EisMclachlanAtom a2) -> EisMclachlanPair"""
        this = _sim2dlong.new_EisMclachlanPair(*args)
        try: self.this.append(this)
        except: self.this = this
    def energy(self, *args) -> "flt" :
        """energy(EisMclachlanPair self, Box box) -> flt"""
        return _sim2dlong.EisMclachlanPair_energy(self, *args)

    def forces(self, *args) -> "Vec" :
        """forces(EisMclachlanPair self, Box box) -> VecL"""
        return _sim2dlong.EisMclachlanPair_forces(self, *args)

    __swig_destroy__ = _sim2dlong.delete_EisMclachlanPair
    __del__ = lambda self : None;
EisMclachlanPair_swigregister = _sim2dlong.EisMclachlanPair_swigregister
EisMclachlanPair_swigregister(EisMclachlanPair)

class HertzianAtom(atomid):
    """Proxy of C++ HertzianAtom class"""
    __swig_setmethods__ = {}
    for _s in [atomid]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HertzianAtom, name, value)
    __swig_getmethods__ = {}
    for _s in [atomid]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, HertzianAtom, name)
    __repr__ = _swig_repr
    __swig_setmethods__["eps"] = _sim2dlong.HertzianAtom_eps_set
    __swig_getmethods__["eps"] = _sim2dlong.HertzianAtom_eps_get
    if _newclass:eps = _swig_property(_sim2dlong.HertzianAtom_eps_get, _sim2dlong.HertzianAtom_eps_set)
    __swig_setmethods__["sigma"] = _sim2dlong.HertzianAtom_sigma_set
    __swig_getmethods__["sigma"] = _sim2dlong.HertzianAtom_sigma_get
    if _newclass:sigma = _swig_property(_sim2dlong.HertzianAtom_sigma_get, _sim2dlong.HertzianAtom_sigma_set)
    __swig_setmethods__["exponent"] = _sim2dlong.HertzianAtom_exponent_set
    __swig_getmethods__["exponent"] = _sim2dlong.HertzianAtom_exponent_get
    if _newclass:exponent = _swig_property(_sim2dlong.HertzianAtom_exponent_get, _sim2dlong.HertzianAtom_exponent_set)
    def __init__(self, *args): 
        """
        __init__(HertzianAtom self, atom a, flt eps, flt sigma, flt exponent=2.5) -> HertzianAtom
        __init__(HertzianAtom self, atom a, flt eps, flt sigma) -> HertzianAtom
        __init__(HertzianAtom self, atomid a, HertzianAtom other) -> HertzianAtom
        """
        this = _sim2dlong.new_HertzianAtom(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _sim2dlong.delete_HertzianAtom
    __del__ = lambda self : None;
HertzianAtom_swigregister = _sim2dlong.HertzianAtom_swigregister
HertzianAtom_swigregister(HertzianAtom)


def hertzd(*args) -> "HertzianAtom" :
  """
    hertzd(atom a, double eps, double sigma, double exponent=2.5) -> HertzianAtom
    hertzd(atom a, double eps, double sigma) -> HertzianAtom
    """
  return _sim2dlong.hertzd(*args)
class EnergyForce(_object):
    """Proxy of C++ EnergyForce class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, EnergyForce, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, EnergyForce, name)
    __repr__ = _swig_repr
    __swig_setmethods__["f"] = _sim2dlong.EnergyForce_f_set
    __swig_getmethods__["f"] = _sim2dlong.EnergyForce_f_get
    if _newclass:f = _swig_property(_sim2dlong.EnergyForce_f_get, _sim2dlong.EnergyForce_f_set)
    __swig_setmethods__["E"] = _sim2dlong.EnergyForce_E_set
    __swig_getmethods__["E"] = _sim2dlong.EnergyForce_E_get
    if _newclass:E = _swig_property(_sim2dlong.EnergyForce_E_get, _sim2dlong.EnergyForce_E_set)
    def __init__(self, *args): 
        """__init__(EnergyForce self, VecL f, flt E) -> EnergyForce"""
        this = _sim2dlong.new_EnergyForce(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _sim2dlong.delete_EnergyForce
    __del__ = lambda self : None;
EnergyForce_swigregister = _sim2dlong.EnergyForce_swigregister
EnergyForce_swigregister(EnergyForce)

class HertzianPair(_object):
    """Proxy of C++ HertzianPair class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, HertzianPair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, HertzianPair, name)
    __repr__ = _swig_repr
    __swig_setmethods__["eps"] = _sim2dlong.HertzianPair_eps_set
    __swig_getmethods__["eps"] = _sim2dlong.HertzianPair_eps_get
    if _newclass:eps = _swig_property(_sim2dlong.HertzianPair_eps_get, _sim2dlong.HertzianPair_eps_set)
    __swig_setmethods__["sig"] = _sim2dlong.HertzianPair_sig_set
    __swig_getmethods__["sig"] = _sim2dlong.HertzianPair_sig_get
    if _newclass:sig = _swig_property(_sim2dlong.HertzianPair_sig_get, _sim2dlong.HertzianPair_sig_set)
    __swig_setmethods__["exponent"] = _sim2dlong.HertzianPair_exponent_set
    __swig_getmethods__["exponent"] = _sim2dlong.HertzianPair_exponent_get
    if _newclass:exponent = _swig_property(_sim2dlong.HertzianPair_exponent_get, _sim2dlong.HertzianPair_exponent_set)
    __swig_setmethods__["atom1"] = _sim2dlong.HertzianPair_atom1_set
    __swig_getmethods__["atom1"] = _sim2dlong.HertzianPair_atom1_get
    if _newclass:atom1 = _swig_property(_sim2dlong.HertzianPair_atom1_get, _sim2dlong.HertzianPair_atom1_set)
    __swig_setmethods__["atom2"] = _sim2dlong.HertzianPair_atom2_set
    __swig_getmethods__["atom2"] = _sim2dlong.HertzianPair_atom2_get
    if _newclass:atom2 = _swig_property(_sim2dlong.HertzianPair_atom2_get, _sim2dlong.HertzianPair_atom2_set)
    def __init__(self, *args): 
        """__init__(HertzianPair self, HertzianAtom a1, HertzianAtom a2) -> HertzianPair"""
        this = _sim2dlong.new_HertzianPair(*args)
        try: self.this.append(this)
        except: self.this = this
    def energy(self, *args) -> "flt" :
        """energy(HertzianPair self, Box box) -> flt"""
        return _sim2dlong.HertzianPair_energy(self, *args)

    def forces(self, *args) -> "Vec" :
        """forces(HertzianPair self, Box box) -> VecL"""
        return _sim2dlong.HertzianPair_forces(self, *args)

    def EnergyForces(self, *args) -> "EnergyForce" :
        """EnergyForces(HertzianPair self, Box box) -> EnergyForce"""
        return _sim2dlong.HertzianPair_EnergyForces(self, *args)

    def fill(self, *args) -> "void" :
        """fill(HertzianPair self, Box box, forcepairx fpair)"""
        return _sim2dlong.HertzianPair_fill(self, *args)

    __swig_destroy__ = _sim2dlong.delete_HertzianPair
    __del__ = lambda self : None;
HertzianPair_swigregister = _sim2dlong.HertzianPair_swigregister
HertzianPair_swigregister(HertzianPair)

class LoisOhernAtom(atomid):
    """Proxy of C++ LoisOhernAtom class"""
    __swig_setmethods__ = {}
    for _s in [atomid]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LoisOhernAtom, name, value)
    __swig_getmethods__ = {}
    for _s in [atomid]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LoisOhernAtom, name)
    __repr__ = _swig_repr
    __swig_setmethods__["eps"] = _sim2dlong.LoisOhernAtom_eps_set
    __swig_getmethods__["eps"] = _sim2dlong.LoisOhernAtom_eps_get
    if _newclass:eps = _swig_property(_sim2dlong.LoisOhernAtom_eps_get, _sim2dlong.LoisOhernAtom_eps_set)
    __swig_setmethods__["sigma"] = _sim2dlong.LoisOhernAtom_sigma_set
    __swig_getmethods__["sigma"] = _sim2dlong.LoisOhernAtom_sigma_get
    if _newclass:sigma = _swig_property(_sim2dlong.LoisOhernAtom_sigma_get, _sim2dlong.LoisOhernAtom_sigma_set)
    __swig_setmethods__["C"] = _sim2dlong.LoisOhernAtom_C_set
    __swig_getmethods__["C"] = _sim2dlong.LoisOhernAtom_C_get
    if _newclass:C = _swig_property(_sim2dlong.LoisOhernAtom_C_get, _sim2dlong.LoisOhernAtom_C_set)
    __swig_setmethods__["l"] = _sim2dlong.LoisOhernAtom_l_set
    __swig_getmethods__["l"] = _sim2dlong.LoisOhernAtom_l_get
    if _newclass:l = _swig_property(_sim2dlong.LoisOhernAtom_l_get, _sim2dlong.LoisOhernAtom_l_set)
    def __init__(self, *args): 
        """
        __init__(LoisOhernAtom self, atom a, flt eps, flt sigma, flt C, flt l) -> LoisOhernAtom
        __init__(LoisOhernAtom self, atomid a, LoisOhernAtom other) -> LoisOhernAtom
        """
        this = _sim2dlong.new_LoisOhernAtom(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _sim2dlong.delete_LoisOhernAtom
    __del__ = lambda self : None;
LoisOhernAtom_swigregister = _sim2dlong.LoisOhernAtom_swigregister
LoisOhernAtom_swigregister(LoisOhernAtom)

class LoisOhernPair(_object):
    """Proxy of C++ LoisOhernPair class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LoisOhernPair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LoisOhernPair, name)
    __repr__ = _swig_repr
    __swig_setmethods__["eps"] = _sim2dlong.LoisOhernPair_eps_set
    __swig_getmethods__["eps"] = _sim2dlong.LoisOhernPair_eps_get
    if _newclass:eps = _swig_property(_sim2dlong.LoisOhernPair_eps_get, _sim2dlong.LoisOhernPair_eps_set)
    __swig_setmethods__["sig"] = _sim2dlong.LoisOhernPair_sig_set
    __swig_getmethods__["sig"] = _sim2dlong.LoisOhernPair_sig_get
    if _newclass:sig = _swig_property(_sim2dlong.LoisOhernPair_sig_get, _sim2dlong.LoisOhernPair_sig_set)
    __swig_setmethods__["C"] = _sim2dlong.LoisOhernPair_C_set
    __swig_getmethods__["C"] = _sim2dlong.LoisOhernPair_C_get
    if _newclass:C = _swig_property(_sim2dlong.LoisOhernPair_C_get, _sim2dlong.LoisOhernPair_C_set)
    __swig_setmethods__["l"] = _sim2dlong.LoisOhernPair_l_set
    __swig_getmethods__["l"] = _sim2dlong.LoisOhernPair_l_get
    if _newclass:l = _swig_property(_sim2dlong.LoisOhernPair_l_get, _sim2dlong.LoisOhernPair_l_set)
    __swig_setmethods__["sigcut"] = _sim2dlong.LoisOhernPair_sigcut_set
    __swig_getmethods__["sigcut"] = _sim2dlong.LoisOhernPair_sigcut_get
    if _newclass:sigcut = _swig_property(_sim2dlong.LoisOhernPair_sigcut_get, _sim2dlong.LoisOhernPair_sigcut_set)
    __swig_setmethods__["atom1"] = _sim2dlong.LoisOhernPair_atom1_set
    __swig_getmethods__["atom1"] = _sim2dlong.LoisOhernPair_atom1_get
    if _newclass:atom1 = _swig_property(_sim2dlong.LoisOhernPair_atom1_get, _sim2dlong.LoisOhernPair_atom1_set)
    __swig_setmethods__["atom2"] = _sim2dlong.LoisOhernPair_atom2_set
    __swig_getmethods__["atom2"] = _sim2dlong.LoisOhernPair_atom2_get
    if _newclass:atom2 = _swig_property(_sim2dlong.LoisOhernPair_atom2_get, _sim2dlong.LoisOhernPair_atom2_set)
    def __init__(self, *args): 
        """__init__(LoisOhernPair self, LoisOhernAtom a1, LoisOhernAtom a2) -> LoisOhernPair"""
        this = _sim2dlong.new_LoisOhernPair(*args)
        try: self.this.append(this)
        except: self.this = this
    def energy(self, *args) -> "flt" :
        """energy(LoisOhernPair self, Box box) -> flt"""
        return _sim2dlong.LoisOhernPair_energy(self, *args)

    def forces(self, *args) -> "Vec" :
        """forces(LoisOhernPair self, Box box) -> VecL"""
        return _sim2dlong.LoisOhernPair_forces(self, *args)

    __swig_destroy__ = _sim2dlong.delete_LoisOhernPair
    __del__ = lambda self : None;
LoisOhernPair_swigregister = _sim2dlong.LoisOhernPair_swigregister
LoisOhernPair_swigregister(LoisOhernPair)

class LJsimple(interaction):
    """Proxy of C++ LJsimple class"""
    __swig_setmethods__ = {}
    for _s in [interaction]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJsimple, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LJsimple, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(LJsimple self, flt cutoffdist, std::vector< LJatom > atms=std::vector< LJatom >()) -> LJsimple
        __init__(LJsimple self, flt cutoffdist) -> LJsimple
        """
        this = _sim2dlong.new_LJsimple(*args)
        try: self.this.append(this)
        except: self.this = this
    def add(self, *args) -> "void" :
        """
        add(LJsimple self, LJatom a)
        add(LJsimple self, atom a, flt epsilon, flt sigma)
        """
        return _sim2dlong.LJsimple_add(self, *args)

    def ignore(self, *args) -> "void" :
        """
        ignore(LJsimple self, atomid a, atomid b)
        ignore(LJsimple self, atom a, atom b)
        """
        return _sim2dlong.LJsimple_ignore(self, *args)

    def ignore_size(self) -> "uint" :
        """ignore_size(LJsimple self) -> uint"""
        return _sim2dlong.LJsimple_ignore_size(self)

    def atoms_size(self) -> "uint" :
        """atoms_size(LJsimple self) -> uint"""
        return _sim2dlong.LJsimple_atoms_size(self)

    def energy(self, *args) -> "flt" :
        """energy(LJsimple self, Box box) -> flt"""
        return _sim2dlong.LJsimple_energy(self, *args)

    def pressure(self, *args) -> "flt" :
        """pressure(LJsimple self, Box box) -> flt"""
        return _sim2dlong.LJsimple_pressure(self, *args)

    def setForces(self, *args) -> "void" :
        """setForces(LJsimple self, Box box)"""
        return _sim2dlong.LJsimple_setForces(self, *args)

    __swig_destroy__ = _sim2dlong.delete_LJsimple
    __del__ = lambda self : None;
LJsimple_swigregister = _sim2dlong.LJsimple_swigregister
LJsimple_swigregister(LJsimple)

class Charges(interaction):
    """Proxy of C++ Charges class"""
    __swig_setmethods__ = {}
    for _s in [interaction]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Charges, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Charges, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(Charges self, flt screenlength, flt k=1, std::vector< Charged > atms=std::vector< Charged >()) -> Charges
        __init__(Charges self, flt screenlength, flt k=1) -> Charges
        __init__(Charges self, flt screenlength) -> Charges
        """
        this = _sim2dlong.new_Charges(*args)
        try: self.this.append(this)
        except: self.this = this
    def add(self, *args) -> "void" :
        """
        add(Charges self, Charged a)
        add(Charges self, atom a, flt q)
        """
        return _sim2dlong.Charges_add(self, *args)

    def ignore(self, *args) -> "void" :
        """
        ignore(Charges self, atomid a, atomid b)
        ignore(Charges self, atom a, atom b)
        """
        return _sim2dlong.Charges_ignore(self, *args)

    def ignore_size(self) -> "uint" :
        """ignore_size(Charges self) -> uint"""
        return _sim2dlong.Charges_ignore_size(self)

    def size(self) -> "uint" :
        """size(Charges self) -> uint"""
        return _sim2dlong.Charges_size(self)

    def energy(self, *args) -> "flt" :
        """energy(Charges self, Box box) -> flt"""
        return _sim2dlong.Charges_energy(self, *args)

    def pressure(self, *args) -> "flt" :
        """pressure(Charges self, Box box) -> flt"""
        return _sim2dlong.Charges_pressure(self, *args)

    def setForces(self, *args) -> "void" :
        """setForces(Charges self, Box box)"""
        return _sim2dlong.Charges_setForces(self, *args)

    __swig_destroy__ = _sim2dlong.delete_Charges
    __del__ = lambda self : None;
Charges_swigregister = _sim2dlong.Charges_swigregister
Charges_swigregister(Charges)


def toBuffer(*args) -> "bool" :
  """toBuffer(vecptrvectorL arr, double * buffer) -> bool"""
  return _sim2dlong.toBuffer(*args)
class jamminglist(_object):
    """Proxy of C++ jamminglist class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, jamminglist, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, jamminglist, name)
    __repr__ = _swig_repr
    __swig_setmethods__["assigned"] = _sim2dlong.jamminglist_assigned_set
    __swig_getmethods__["assigned"] = _sim2dlong.jamminglist_assigned_get
    if _newclass:assigned = _swig_property(_sim2dlong.jamminglist_assigned_get, _sim2dlong.jamminglist_assigned_set)
    __swig_setmethods__["distsq"] = _sim2dlong.jamminglist_distsq_set
    __swig_getmethods__["distsq"] = _sim2dlong.jamminglist_distsq_get
    if _newclass:distsq = _swig_property(_sim2dlong.jamminglist_distsq_get, _sim2dlong.jamminglist_distsq_set)
    def __init__(self, *args): 
        """
        __init__(jamminglist self) -> jamminglist
        __init__(jamminglist self, jamminglist other) -> jamminglist
        __init__(jamminglist self, jamminglist other, uint expand, flt addeddist) -> jamminglist
        """
        this = _sim2dlong.new_jamminglist(*args)
        try: self.this.append(this)
        except: self.this = this
    def size(self) -> "uint" :
        """size(jamminglist self) -> uint"""
        return _sim2dlong.jamminglist_size(self)

    def __lt__(self, *args) -> "bool" :
        """__lt__(jamminglist self, jamminglist other) -> bool"""
        return _sim2dlong.jamminglist___lt__(self, *args)

    __swig_destroy__ = _sim2dlong.delete_jamminglist
    __del__ = lambda self : None;
jamminglist_swigregister = _sim2dlong.jamminglist_swigregister
jamminglist_swigregister(jamminglist)

class jammingtree(_object):
    """Proxy of C++ jammingtree class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, jammingtree, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, jammingtree, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(jammingtree self, Box box, vecvectorL A, vecvectorL B) -> jammingtree"""
        this = _sim2dlong.new_jammingtree(*args)
        try: self.this.append(this)
        except: self.this = this
    def expand(self, *args) -> "bool" :
        """
        expand(jammingtree self) -> bool
        expand(jammingtree self, uint n) -> bool
        """
        return _sim2dlong.jammingtree_expand(self, *args)

    def mylist(self) -> "std::list< jamminglist > &" :
        """mylist(jammingtree self) -> _jamminglist"""
        return _sim2dlong.jammingtree_mylist(self)

    def copylist(self) -> "std::list< jamminglist >" :
        """copylist(jammingtree self) -> _jamminglist"""
        return _sim2dlong.jammingtree_copylist(self)

    def curbest(self) -> "jamminglist" :
        """curbest(jammingtree self) -> jamminglist"""
        return _sim2dlong.jammingtree_curbest(self)

    def size(self) -> "uint" :
        """size(jammingtree self) -> uint"""
        return _sim2dlong.jammingtree_size(self)

    __swig_destroy__ = _sim2dlong.delete_jammingtree
    __del__ = lambda self : None;
jammingtree_swigregister = _sim2dlong.jammingtree_swigregister
jammingtree_swigregister(jammingtree)

class jamminglistrot(jamminglist):
    """Proxy of C++ jamminglistrot class"""
    __swig_setmethods__ = {}
    for _s in [jamminglist]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, jamminglistrot, name, value)
    __swig_getmethods__ = {}
    for _s in [jamminglist]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, jamminglistrot, name)
    __repr__ = _swig_repr
    __swig_setmethods__["rotation"] = _sim2dlong.jamminglistrot_rotation_set
    __swig_getmethods__["rotation"] = _sim2dlong.jamminglistrot_rotation_get
    if _newclass:rotation = _swig_property(_sim2dlong.jamminglistrot_rotation_get, _sim2dlong.jamminglistrot_rotation_set)
    def __init__(self, *args): 
        """
        __init__(jamminglistrot self) -> jamminglistrot
        __init__(jamminglistrot self, uint rot) -> jamminglistrot
        __init__(jamminglistrot self, jamminglistrot other) -> jamminglistrot
        __init__(jamminglistrot self, jamminglistrot other, uint expand, flt addeddist) -> jamminglistrot
        """
        this = _sim2dlong.new_jamminglistrot(*args)
        try: self.this.append(this)
        except: self.this = this
    def __lt__(self, *args) -> "bool" :
        """__lt__(jamminglistrot self, jamminglistrot other) -> bool"""
        return _sim2dlong.jamminglistrot___lt__(self, *args)

    __swig_destroy__ = _sim2dlong.delete_jamminglistrot
    __del__ = lambda self : None;
jamminglistrot_swigregister = _sim2dlong.jamminglistrot_swigregister
jamminglistrot_swigregister(jamminglistrot)

class jammingtree2(_object):
    """Proxy of C++ jammingtree2 class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, jammingtree2, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, jammingtree2, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(jammingtree2 self, Box box, vecvectorL A, vecvectorL B) -> jammingtree2"""
        this = _sim2dlong.new_jammingtree2(*args)
        try: self.this.append(this)
        except: self.this = this
    def distance(self, *args) -> "flt" :
        """distance(jammingtree2 self, jamminglistrot jlist) -> flt"""
        return _sim2dlong.jammingtree2_distance(self, *args)

    def expand(self, *args) -> "bool" :
        """
        expand(jammingtree2 self, jamminglistrot curjlist) -> _jamminglistrot
        expand(jammingtree2 self) -> bool
        expand(jammingtree2 self, uint n) -> bool
        """
        return _sim2dlong.jammingtree2_expand(self, *args)

    def expandto(self, *args) -> "bool" :
        """expandto(jammingtree2 self, flt maxdistsq) -> bool"""
        return _sim2dlong.jammingtree2_expandto(self, *args)

    def straight_diff(*args) -> "Vec" :
        """straight_diff(Box bx, vecvectorL A, vecvectorL B) -> VecL"""
        return _sim2dlong.jammingtree2_straight_diff(*args)

    if _newclass:straight_diff = staticmethod(straight_diff)
    __swig_getmethods__["straight_diff"] = lambda x: straight_diff
    def straight_distsq(*args) -> "flt" :
        """straight_distsq(Box bx, vecvectorL A, vecvectorL B) -> flt"""
        return _sim2dlong.jammingtree2_straight_distsq(*args)

    if _newclass:straight_distsq = staticmethod(straight_distsq)
    __swig_getmethods__["straight_distsq"] = lambda x: straight_distsq
    def mylist(self) -> "std::list< jamminglistrot > &" :
        """mylist(jammingtree2 self) -> _jamminglistrot"""
        return _sim2dlong.jammingtree2_mylist(self)

    def copylist(self, *args) -> "std::list< jamminglistrot >" :
        """
        copylist(jammingtree2 self) -> _jamminglistrot
        copylist(jammingtree2 self, uint n) -> _jamminglistrot
        """
        return _sim2dlong.jammingtree2_copylist(self, *args)

    def curbest(self) -> "jamminglistrot" :
        """curbest(jammingtree2 self) -> jamminglistrot"""
        return _sim2dlong.jammingtree2_curbest(self)

    def size(self) -> "uint" :
        """size(jammingtree2 self) -> uint"""
        return _sim2dlong.jammingtree2_size(self)

    def locationsB(self, *args) -> "std::vector< Vec >" :
        """
        locationsB(jammingtree2 self, jamminglistrot jlist) -> vecvectorL
        locationsB(jammingtree2 self) -> vecvectorL
        """
        return _sim2dlong.jammingtree2_locationsB(self, *args)

    def locationsA(self, *args) -> "std::vector< Vec >" :
        """
        locationsA(jammingtree2 self, jamminglistrot jlist) -> vecvectorL
        locationsA(jammingtree2 self) -> vecvectorL
        """
        return _sim2dlong.jammingtree2_locationsA(self, *args)

    __swig_destroy__ = _sim2dlong.delete_jammingtree2
    __del__ = lambda self : None;
jammingtree2_swigregister = _sim2dlong.jammingtree2_swigregister
jammingtree2_swigregister(jammingtree2)

def jammingtree2_straight_diff(*args) -> "Vec" :
  """jammingtree2_straight_diff(Box bx, vecvectorL A, vecvectorL B) -> VecL"""
  return _sim2dlong.jammingtree2_straight_diff(*args)

def jammingtree2_straight_distsq(*args) -> "flt" :
  """jammingtree2_straight_distsq(Box bx, vecvectorL A, vecvectorL B) -> flt"""
  return _sim2dlong.jammingtree2_straight_distsq(*args)

class jammingtreeBD(jammingtree2):
    """Proxy of C++ jammingtreeBD class"""
    __swig_setmethods__ = {}
    for _s in [jammingtree2]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, jammingtreeBD, name, value)
    __swig_getmethods__ = {}
    for _s in [jammingtree2]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, jammingtreeBD, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(jammingtreeBD self, Box box, vecvectorL A, vecvectorL B, uint cutoff) -> jammingtreeBD
        __init__(jammingtreeBD self, Box box, vecvectorL A, vecvectorL B, uint cutoffA, uint cutoffB) -> jammingtreeBD
        """
        this = _sim2dlong.new_jammingtreeBD(*args)
        try: self.this.append(this)
        except: self.this = this
    def expand(self, *args) -> "bool" :
        """
        expand(jammingtreeBD self, jamminglistrot curjlist) -> _jamminglistrot
        expand(jammingtreeBD self) -> bool
        expand(jammingtreeBD self, uint n) -> bool
        """
        return _sim2dlong.jammingtreeBD_expand(self, *args)

    __swig_destroy__ = _sim2dlong.delete_jammingtreeBD
    __del__ = lambda self : None;
jammingtreeBD_swigregister = _sim2dlong.jammingtreeBD_swigregister
jammingtreeBD_swigregister(jammingtreeBD)


def confineRange(*args) -> "flt" :
  """confineRange(flt minimum, flt val, flt maximum) -> flt"""
  return _sim2dlong.confineRange(*args)
class SpheroCylinderDiff(_object):
    """Proxy of C++ SpheroCylinderDiff class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SpheroCylinderDiff, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SpheroCylinderDiff, name)
    __repr__ = _swig_repr
    __swig_setmethods__["delta"] = _sim2dlong.SpheroCylinderDiff_delta_set
    __swig_getmethods__["delta"] = _sim2dlong.SpheroCylinderDiff_delta_get
    if _newclass:delta = _swig_property(_sim2dlong.SpheroCylinderDiff_delta_get, _sim2dlong.SpheroCylinderDiff_delta_set)
    __swig_setmethods__["lambda1"] = _sim2dlong.SpheroCylinderDiff_lambda1_set
    __swig_getmethods__["lambda1"] = _sim2dlong.SpheroCylinderDiff_lambda1_get
    if _newclass:lambda1 = _swig_property(_sim2dlong.SpheroCylinderDiff_lambda1_get, _sim2dlong.SpheroCylinderDiff_lambda1_set)
    __swig_setmethods__["lambda2"] = _sim2dlong.SpheroCylinderDiff_lambda2_set
    __swig_getmethods__["lambda2"] = _sim2dlong.SpheroCylinderDiff_lambda2_get
    if _newclass:lambda2 = _swig_property(_sim2dlong.SpheroCylinderDiff_lambda2_get, _sim2dlong.SpheroCylinderDiff_lambda2_set)
    def __init__(self): 
        """__init__(SpheroCylinderDiff self) -> SpheroCylinderDiff"""
        this = _sim2dlong.new_SpheroCylinderDiff()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _sim2dlong.delete_SpheroCylinderDiff
    __del__ = lambda self : None;
SpheroCylinderDiff_swigregister = _sim2dlong.SpheroCylinderDiff_swigregister
SpheroCylinderDiff_swigregister(SpheroCylinderDiff)


def nearestLoc(*args) -> "SpheroCylinderDiff" :
  """nearestLoc(VecL x1, VecL x1p, VecL x2, VecL x2p) -> SpheroCylinderDiff"""
  return _sim2dlong.nearestLoc(*args)
class constraint(_object):
    """Proxy of C++ constraint class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, constraint, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, constraint, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def apply(self, *args) -> "void" :
        """apply(constraint self, Box box)"""
        return _sim2dlong.constraint_apply(self, *args)

    def ndof(self) -> "int" :
        """ndof(constraint self) -> int"""
        return _sim2dlong.constraint_ndof(self)

    __swig_destroy__ = _sim2dlong.delete_constraint
    __del__ = lambda self : None;
constraint_swigregister = _sim2dlong.constraint_swigregister
constraint_swigregister(constraint)

class coordConstraint(constraint):
    """Proxy of C++ coordConstraint class"""
    __swig_setmethods__ = {}
    for _s in [constraint]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, coordConstraint, name, value)
    __swig_getmethods__ = {}
    for _s in [constraint]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, coordConstraint, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(coordConstraint self, atom atm, bool fixx, bool fixy, bool fixz, VecL loc) -> coordConstraint
        __init__(coordConstraint self, atom atm, bool fixx, bool fixy, bool fixz) -> coordConstraint
        __init__(coordConstraint self, atom atm) -> coordConstraint
        """
        this = _sim2dlong.new_coordConstraint(*args)
        try: self.this.append(this)
        except: self.this = this
    def ndof(self) -> "int" :
        """ndof(coordConstraint self) -> int"""
        return _sim2dlong.coordConstraint_ndof(self)

    def apply(self, *args) -> "void" :
        """apply(coordConstraint self, Box box)"""
        return _sim2dlong.coordConstraint_apply(self, *args)

    __swig_destroy__ = _sim2dlong.delete_coordConstraint
    __del__ = lambda self : None;
coordConstraint_swigregister = _sim2dlong.coordConstraint_swigregister
coordConstraint_swigregister(coordConstraint)

class coordCOMConstraint(constraint):
    """Proxy of C++ coordCOMConstraint class"""
    __swig_setmethods__ = {}
    for _s in [constraint]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, coordCOMConstraint, name, value)
    __swig_getmethods__ = {}
    for _s in [constraint]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, coordCOMConstraint, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(coordCOMConstraint self, atomgroup atm, bool fixx, bool fixy, bool fixz, VecL loc) -> coordCOMConstraint
        __init__(coordCOMConstraint self, atomgroup atm, bool fixx, bool fixy, bool fixz) -> coordCOMConstraint
        __init__(coordCOMConstraint self, atomgroup atm) -> coordCOMConstraint
        """
        this = _sim2dlong.new_coordCOMConstraint(*args)
        try: self.this.append(this)
        except: self.this = this
    def ndof(self) -> "int" :
        """ndof(coordCOMConstraint self) -> int"""
        return _sim2dlong.coordCOMConstraint_ndof(self)

    def apply(self, *args) -> "void" :
        """apply(coordCOMConstraint self, Box box)"""
        return _sim2dlong.coordCOMConstraint_apply(self, *args)

    __swig_destroy__ = _sim2dlong.delete_coordCOMConstraint
    __del__ = lambda self : None;
coordCOMConstraint_swigregister = _sim2dlong.coordCOMConstraint_swigregister
coordCOMConstraint_swigregister(coordCOMConstraint)

class relativeConstraint(constraint):
    """Proxy of C++ relativeConstraint class"""
    __swig_setmethods__ = {}
    for _s in [constraint]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, relativeConstraint, name, value)
    __swig_getmethods__ = {}
    for _s in [constraint]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, relativeConstraint, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(relativeConstraint self, atom atm1, atom atm2, bool fixx, bool fixy, bool fixz, VecL loc) -> relativeConstraint
        __init__(relativeConstraint self, atom atm1, atom atm2, bool fixx, bool fixy, bool fixz) -> relativeConstraint
        __init__(relativeConstraint self, atom atm1, atom atm2) -> relativeConstraint
        """
        this = _sim2dlong.new_relativeConstraint(*args)
        try: self.this.append(this)
        except: self.this = this
    def ndof(self) -> "int" :
        """ndof(relativeConstraint self) -> int"""
        return _sim2dlong.relativeConstraint_ndof(self)

    def apply(self, *args) -> "void" :
        """apply(relativeConstraint self, Box box)"""
        return _sim2dlong.relativeConstraint_apply(self, *args)

    __swig_destroy__ = _sim2dlong.delete_relativeConstraint
    __del__ = lambda self : None;
relativeConstraint_swigregister = _sim2dlong.relativeConstraint_swigregister
relativeConstraint_swigregister(relativeConstraint)

class NPHGaussianConstraint(constraint):
    """Proxy of C++ NPHGaussianConstraint class"""
    __swig_setmethods__ = {}
    for _s in [constraint]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, NPHGaussianConstraint, name, value)
    __swig_getmethods__ = {}
    for _s in [constraint]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, NPHGaussianConstraint, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(NPHGaussianConstraint self, OriginBox box, avector groups) -> NPHGaussianConstraint"""
        this = _sim2dlong.new_NPHGaussianConstraint(*args)
        try: self.this.append(this)
        except: self.this = this
    def ndof(self) -> "int" :
        """ndof(NPHGaussianConstraint self) -> int"""
        return _sim2dlong.NPHGaussianConstraint_ndof(self)

    def apply(self, *args) -> "void" :
        """apply(NPHGaussianConstraint self, Box box2)"""
        return _sim2dlong.NPHGaussianConstraint_apply(self, *args)

    __swig_destroy__ = _sim2dlong.delete_NPHGaussianConstraint
    __del__ = lambda self : None;
NPHGaussianConstraint_swigregister = _sim2dlong.NPHGaussianConstraint_swigregister
NPHGaussianConstraint_swigregister(NPHGaussianConstraint)

class LJgroup(interaction):
    """Proxy of C++ NListed<(LJatom,LJpair)> class"""
    __swig_setmethods__ = {}
    for _s in [interaction]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJgroup, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LJgroup, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(NListed<(LJatom,LJpair)> self, neighborlist neighbors) -> LJgroup"""
        this = _sim2dlong.new_LJgroup(*args)
        try: self.this.append(this)
        except: self.this = this
    def add(self, *args) -> "void" :
        """add(LJgroup self, LJatom atm)"""
        return _sim2dlong.LJgroup_add(self, *args)

    def update_pairs(self) -> "void" :
        """update_pairs(LJgroup self)"""
        return _sim2dlong.LJgroup_update_pairs(self)

    def getpair(self, *args) -> "LJpair" :
        """getpair(LJgroup self, idpair pair) -> LJpair"""
        return _sim2dlong.LJgroup_getpair(self, *args)

    def getatom(self, *args) -> "LJatom &" :
        """getatom(LJgroup self, uint n) -> LJatom"""
        return _sim2dlong.LJgroup_getatom(self, *args)

    def energy(self, *args) -> "flt" :
        """
        energy(LJgroup self, Box box, idpair pair) -> flt
        energy(LJgroup self, Box box) -> flt
        """
        return _sim2dlong.LJgroup_energy(self, *args)

    def pressure(self, *args) -> "flt" :
        """pressure(LJgroup self, Box box) -> flt"""
        return _sim2dlong.LJgroup_pressure(self, *args)

    def size(self) -> "uint" :
        """size(LJgroup self) -> uint"""
        return _sim2dlong.LJgroup_size(self)

    def energy_pair(self, *args) -> "flt" :
        """energy_pair(LJgroup self, LJpair pair, Box box) -> flt"""
        return _sim2dlong.LJgroup_energy_pair(self, *args)

    def setForces(self, *args) -> "void" :
        """setForces(LJgroup self, Box box)"""
        return _sim2dlong.LJgroup_setForces(self, *args)

    def setForcesGetPressure(self, *args) -> "flt" :
        """setForcesGetPressure(LJgroup self, Box box) -> flt"""
        return _sim2dlong.LJgroup_setForcesGetPressure(self, *args)

    def forces_pair(self, *args) -> "Vec" :
        """forces_pair(LJgroup self, LJpair pair, Box box) -> VecL"""
        return _sim2dlong.LJgroup_forces_pair(self, *args)

    def atom_list(self) -> "std::vector< LJatom > &" :
        """atom_list(LJgroup self) -> std::vector< LJatom > &"""
        return _sim2dlong.LJgroup_atom_list(self)

    def nlist(self) -> "neighborlist *" :
        """nlist(LJgroup self) -> neighborlist"""
        return _sim2dlong.LJgroup_nlist(self)

    __swig_destroy__ = _sim2dlong.delete_LJgroup
    __del__ = lambda self : None;
    def add_atom(self, epsilon, sigma, a):
        self.add(LJatom(epsilon, sigma, a))

LJgroup_swigregister = _sim2dlong.LJgroup_swigregister
LJgroup_swigregister(LJgroup)

class LJfull(interaction):
    """Proxy of C++ NListed<(LJatomcut,LJAttractPair)> class"""
    __swig_setmethods__ = {}
    for _s in [interaction]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJfull, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LJfull, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(NListed<(LJatomcut,LJAttractPair)> self, neighborlist neighbors) -> LJfull"""
        this = _sim2dlong.new_LJfull(*args)
        try: self.this.append(this)
        except: self.this = this
    def add(self, *args) -> "void" :
        """add(LJfull self, LJatomcut atm)"""
        return _sim2dlong.LJfull_add(self, *args)

    def update_pairs(self) -> "void" :
        """update_pairs(LJfull self)"""
        return _sim2dlong.LJfull_update_pairs(self)

    def getpair(self, *args) -> "LJAttractPair" :
        """getpair(LJfull self, idpair pair) -> LJAttractPair"""
        return _sim2dlong.LJfull_getpair(self, *args)

    def getatom(self, *args) -> "LJatomcut &" :
        """getatom(LJfull self, uint n) -> LJatomcut"""
        return _sim2dlong.LJfull_getatom(self, *args)

    def energy(self, *args) -> "flt" :
        """
        energy(LJfull self, Box box, idpair pair) -> flt
        energy(LJfull self, Box box) -> flt
        """
        return _sim2dlong.LJfull_energy(self, *args)

    def pressure(self, *args) -> "flt" :
        """pressure(LJfull self, Box box) -> flt"""
        return _sim2dlong.LJfull_pressure(self, *args)

    def size(self) -> "uint" :
        """size(LJfull self) -> uint"""
        return _sim2dlong.LJfull_size(self)

    def energy_pair(self, *args) -> "flt" :
        """energy_pair(LJfull self, LJAttractPair pair, Box box) -> flt"""
        return _sim2dlong.LJfull_energy_pair(self, *args)

    def setForces(self, *args) -> "void" :
        """setForces(LJfull self, Box box)"""
        return _sim2dlong.LJfull_setForces(self, *args)

    def setForcesGetPressure(self, *args) -> "flt" :
        """setForcesGetPressure(LJfull self, Box box) -> flt"""
        return _sim2dlong.LJfull_setForcesGetPressure(self, *args)

    def forces_pair(self, *args) -> "Vec" :
        """forces_pair(LJfull self, LJAttractPair pair, Box box) -> VecL"""
        return _sim2dlong.LJfull_forces_pair(self, *args)

    def atom_list(self) -> "std::vector< LJatomcut > &" :
        """atom_list(LJfull self) -> std::vector< LJatomcut > &"""
        return _sim2dlong.LJfull_atom_list(self)

    def nlist(self) -> "neighborlist *" :
        """nlist(LJfull self) -> neighborlist"""
        return _sim2dlong.LJfull_nlist(self)

    __swig_destroy__ = _sim2dlong.delete_LJfull
    __del__ = lambda self : None;
    def add_atom(self, epsilon, sigma, a, cut):
        self.add(LJatomcut(epsilon, sigma, a, cut))

LJfull_swigregister = _sim2dlong.LJfull_swigregister
LJfull_swigregister(LJfull)

class Hydrophobicity(interaction):
    """Proxy of C++ NListed<(HydroAtom,HydroPair)> class"""
    __swig_setmethods__ = {}
    for _s in [interaction]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Hydrophobicity, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Hydrophobicity, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(NListed<(HydroAtom,HydroPair)> self, neighborlist neighbors) -> Hydrophobicity"""
        this = _sim2dlong.new_Hydrophobicity(*args)
        try: self.this.append(this)
        except: self.this = this
    def add(self, *args) -> "void" :
        """add(Hydrophobicity self, HydroAtom atm)"""
        return _sim2dlong.Hydrophobicity_add(self, *args)

    def update_pairs(self) -> "void" :
        """update_pairs(Hydrophobicity self)"""
        return _sim2dlong.Hydrophobicity_update_pairs(self)

    def getpair(self, *args) -> "HydroPair" :
        """getpair(Hydrophobicity self, idpair pair) -> HydroPair"""
        return _sim2dlong.Hydrophobicity_getpair(self, *args)

    def getatom(self, *args) -> "HydroAtom &" :
        """getatom(Hydrophobicity self, uint n) -> HydroAtom"""
        return _sim2dlong.Hydrophobicity_getatom(self, *args)

    def energy(self, *args) -> "flt" :
        """
        energy(Hydrophobicity self, Box box, idpair pair) -> flt
        energy(Hydrophobicity self, Box box) -> flt
        """
        return _sim2dlong.Hydrophobicity_energy(self, *args)

    def pressure(self, *args) -> "flt" :
        """pressure(Hydrophobicity self, Box box) -> flt"""
        return _sim2dlong.Hydrophobicity_pressure(self, *args)

    def size(self) -> "uint" :
        """size(Hydrophobicity self) -> uint"""
        return _sim2dlong.Hydrophobicity_size(self)

    def energy_pair(self, *args) -> "flt" :
        """energy_pair(Hydrophobicity self, HydroPair pair, Box box) -> flt"""
        return _sim2dlong.Hydrophobicity_energy_pair(self, *args)

    def setForces(self, *args) -> "void" :
        """setForces(Hydrophobicity self, Box box)"""
        return _sim2dlong.Hydrophobicity_setForces(self, *args)

    def setForcesGetPressure(self, *args) -> "flt" :
        """setForcesGetPressure(Hydrophobicity self, Box box) -> flt"""
        return _sim2dlong.Hydrophobicity_setForcesGetPressure(self, *args)

    def forces_pair(self, *args) -> "Vec" :
        """forces_pair(Hydrophobicity self, HydroPair pair, Box box) -> VecL"""
        return _sim2dlong.Hydrophobicity_forces_pair(self, *args)

    def atom_list(self) -> "std::vector< HydroAtom > &" :
        """atom_list(Hydrophobicity self) -> std::vector< HydroAtom > &"""
        return _sim2dlong.Hydrophobicity_atom_list(self)

    def nlist(self) -> "neighborlist *" :
        """nlist(Hydrophobicity self) -> neighborlist"""
        return _sim2dlong.Hydrophobicity_nlist(self)

    __swig_destroy__ = _sim2dlong.delete_Hydrophobicity
    __del__ = lambda self : None;
Hydrophobicity_swigregister = _sim2dlong.Hydrophobicity_swigregister
Hydrophobicity_swigregister(Hydrophobicity)

class LJdetailed(interaction):
    """Proxy of C++ NListed<(LJAtomIndexed,LJFullPair)> class"""
    __swig_setmethods__ = {}
    for _s in [interaction]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJdetailed, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LJdetailed, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(NListed<(LJAtomIndexed,LJFullPair)> self, neighborlist neighbors) -> LJdetailed"""
        this = _sim2dlong.new_LJdetailed(*args)
        try: self.this.append(this)
        except: self.this = this
    def add(self, *args) -> "void" :
        """add(LJdetailed self, LJAtomIndexed atm)"""
        return _sim2dlong.LJdetailed_add(self, *args)

    def update_pairs(self) -> "void" :
        """update_pairs(LJdetailed self)"""
        return _sim2dlong.LJdetailed_update_pairs(self)

    def getpair(self, *args) -> "LJFullPair" :
        """getpair(LJdetailed self, idpair pair) -> LJFullPair"""
        return _sim2dlong.LJdetailed_getpair(self, *args)

    def getatom(self, *args) -> "LJAtomIndexed &" :
        """getatom(LJdetailed self, uint n) -> LJAtomIndexed"""
        return _sim2dlong.LJdetailed_getatom(self, *args)

    def energy(self, *args) -> "flt" :
        """
        energy(LJdetailed self, Box box, idpair pair) -> flt
        energy(LJdetailed self, Box box) -> flt
        """
        return _sim2dlong.LJdetailed_energy(self, *args)

    def pressure(self, *args) -> "flt" :
        """pressure(LJdetailed self, Box box) -> flt"""
        return _sim2dlong.LJdetailed_pressure(self, *args)

    def size(self) -> "uint" :
        """size(LJdetailed self) -> uint"""
        return _sim2dlong.LJdetailed_size(self)

    def energy_pair(self, *args) -> "flt" :
        """energy_pair(LJdetailed self, LJFullPair pair, Box box) -> flt"""
        return _sim2dlong.LJdetailed_energy_pair(self, *args)

    def setForces(self, *args) -> "void" :
        """setForces(LJdetailed self, Box box)"""
        return _sim2dlong.LJdetailed_setForces(self, *args)

    def setForcesGetPressure(self, *args) -> "flt" :
        """setForcesGetPressure(LJdetailed self, Box box) -> flt"""
        return _sim2dlong.LJdetailed_setForcesGetPressure(self, *args)

    def forces_pair(self, *args) -> "Vec" :
        """forces_pair(LJdetailed self, LJFullPair pair, Box box) -> VecL"""
        return _sim2dlong.LJdetailed_forces_pair(self, *args)

    def atom_list(self) -> "std::vector< LJAtomIndexed > &" :
        """atom_list(LJdetailed self) -> std::vector< LJAtomIndexed > &"""
        return _sim2dlong.LJdetailed_atom_list(self)

    def nlist(self) -> "neighborlist *" :
        """nlist(LJdetailed self) -> neighborlist"""
        return _sim2dlong.LJdetailed_nlist(self)

    __swig_destroy__ = _sim2dlong.delete_LJdetailed
    __del__ = lambda self : None;
LJdetailed_swigregister = _sim2dlong.LJdetailed_swigregister
LJdetailed_swigregister(LJdetailed)

class LJAttractRepulse(interaction):
    """Proxy of C++ NListed<(LJAttractRepulseAtom,LJAttractRepulsePair)> class"""
    __swig_setmethods__ = {}
    for _s in [interaction]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJAttractRepulse, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LJAttractRepulse, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(NListed<(LJAttractRepulseAtom,LJAttractRepulsePair)> self, neighborlist neighbors) -> LJAttractRepulse"""
        this = _sim2dlong.new_LJAttractRepulse(*args)
        try: self.this.append(this)
        except: self.this = this
    def add(self, *args) -> "void" :
        """add(LJAttractRepulse self, LJAttractRepulseAtom atm)"""
        return _sim2dlong.LJAttractRepulse_add(self, *args)

    def update_pairs(self) -> "void" :
        """update_pairs(LJAttractRepulse self)"""
        return _sim2dlong.LJAttractRepulse_update_pairs(self)

    def getpair(self, *args) -> "LJAttractRepulsePair" :
        """getpair(LJAttractRepulse self, idpair pair) -> LJAttractRepulsePair"""
        return _sim2dlong.LJAttractRepulse_getpair(self, *args)

    def getatom(self, *args) -> "LJAttractRepulseAtom &" :
        """getatom(LJAttractRepulse self, uint n) -> LJAttractRepulseAtom"""
        return _sim2dlong.LJAttractRepulse_getatom(self, *args)

    def energy(self, *args) -> "flt" :
        """
        energy(LJAttractRepulse self, Box box, idpair pair) -> flt
        energy(LJAttractRepulse self, Box box) -> flt
        """
        return _sim2dlong.LJAttractRepulse_energy(self, *args)

    def pressure(self, *args) -> "flt" :
        """pressure(LJAttractRepulse self, Box box) -> flt"""
        return _sim2dlong.LJAttractRepulse_pressure(self, *args)

    def size(self) -> "uint" :
        """size(LJAttractRepulse self) -> uint"""
        return _sim2dlong.LJAttractRepulse_size(self)

    def energy_pair(self, *args) -> "flt" :
        """energy_pair(LJAttractRepulse self, LJAttractRepulsePair pair, Box box) -> flt"""
        return _sim2dlong.LJAttractRepulse_energy_pair(self, *args)

    def setForces(self, *args) -> "void" :
        """setForces(LJAttractRepulse self, Box box)"""
        return _sim2dlong.LJAttractRepulse_setForces(self, *args)

    def setForcesGetPressure(self, *args) -> "flt" :
        """setForcesGetPressure(LJAttractRepulse self, Box box) -> flt"""
        return _sim2dlong.LJAttractRepulse_setForcesGetPressure(self, *args)

    def forces_pair(self, *args) -> "Vec" :
        """forces_pair(LJAttractRepulse self, LJAttractRepulsePair pair, Box box) -> VecL"""
        return _sim2dlong.LJAttractRepulse_forces_pair(self, *args)

    def atom_list(self) -> "std::vector< LJAttractRepulseAtom > &" :
        """atom_list(LJAttractRepulse self) -> std::vector< LJAttractRepulseAtom > &"""
        return _sim2dlong.LJAttractRepulse_atom_list(self)

    def nlist(self) -> "neighborlist *" :
        """nlist(LJAttractRepulse self) -> neighborlist"""
        return _sim2dlong.LJAttractRepulse_nlist(self)

    __swig_destroy__ = _sim2dlong.delete_LJAttractRepulse
    __del__ = lambda self : None;
LJAttractRepulse_swigregister = _sim2dlong.LJAttractRepulse_swigregister
LJAttractRepulse_swigregister(LJAttractRepulse)

class LJAttractFixedRepulse(interaction):
    """Proxy of C++ NListed<(LJAttractFixedRepulseAtom,LJAttractFixedRepulsePair)> class"""
    __swig_setmethods__ = {}
    for _s in [interaction]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJAttractFixedRepulse, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LJAttractFixedRepulse, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(NListed<(LJAttractFixedRepulseAtom,LJAttractFixedRepulsePair)> self, neighborlist neighbors) -> LJAttractFixedRepulse"""
        this = _sim2dlong.new_LJAttractFixedRepulse(*args)
        try: self.this.append(this)
        except: self.this = this
    def add(self, *args) -> "void" :
        """add(LJAttractFixedRepulse self, LJAttractFixedRepulseAtom atm)"""
        return _sim2dlong.LJAttractFixedRepulse_add(self, *args)

    def update_pairs(self) -> "void" :
        """update_pairs(LJAttractFixedRepulse self)"""
        return _sim2dlong.LJAttractFixedRepulse_update_pairs(self)

    def getpair(self, *args) -> "LJAttractFixedRepulsePair" :
        """getpair(LJAttractFixedRepulse self, idpair pair) -> LJAttractFixedRepulsePair"""
        return _sim2dlong.LJAttractFixedRepulse_getpair(self, *args)

    def getatom(self, *args) -> "LJAttractFixedRepulseAtom &" :
        """getatom(LJAttractFixedRepulse self, uint n) -> LJAttractFixedRepulseAtom"""
        return _sim2dlong.LJAttractFixedRepulse_getatom(self, *args)

    def energy(self, *args) -> "flt" :
        """
        energy(LJAttractFixedRepulse self, Box box, idpair pair) -> flt
        energy(LJAttractFixedRepulse self, Box box) -> flt
        """
        return _sim2dlong.LJAttractFixedRepulse_energy(self, *args)

    def pressure(self, *args) -> "flt" :
        """pressure(LJAttractFixedRepulse self, Box box) -> flt"""
        return _sim2dlong.LJAttractFixedRepulse_pressure(self, *args)

    def size(self) -> "uint" :
        """size(LJAttractFixedRepulse self) -> uint"""
        return _sim2dlong.LJAttractFixedRepulse_size(self)

    def energy_pair(self, *args) -> "flt" :
        """energy_pair(LJAttractFixedRepulse self, LJAttractFixedRepulsePair pair, Box box) -> flt"""
        return _sim2dlong.LJAttractFixedRepulse_energy_pair(self, *args)

    def setForces(self, *args) -> "void" :
        """setForces(LJAttractFixedRepulse self, Box box)"""
        return _sim2dlong.LJAttractFixedRepulse_setForces(self, *args)

    def setForcesGetPressure(self, *args) -> "flt" :
        """setForcesGetPressure(LJAttractFixedRepulse self, Box box) -> flt"""
        return _sim2dlong.LJAttractFixedRepulse_setForcesGetPressure(self, *args)

    def forces_pair(self, *args) -> "Vec" :
        """forces_pair(LJAttractFixedRepulse self, LJAttractFixedRepulsePair pair, Box box) -> VecL"""
        return _sim2dlong.LJAttractFixedRepulse_forces_pair(self, *args)

    def atom_list(self) -> "std::vector< LJAttractFixedRepulseAtom > &" :
        """atom_list(LJAttractFixedRepulse self) -> std::vector< LJAttractFixedRepulseAtom > &"""
        return _sim2dlong.LJAttractFixedRepulse_atom_list(self)

    def nlist(self) -> "neighborlist *" :
        """nlist(LJAttractFixedRepulse self) -> neighborlist"""
        return _sim2dlong.LJAttractFixedRepulse_nlist(self)

    __swig_destroy__ = _sim2dlong.delete_LJAttractFixedRepulse
    __del__ = lambda self : None;
LJAttractFixedRepulse_swigregister = _sim2dlong.LJAttractFixedRepulse_swigregister
LJAttractFixedRepulse_swigregister(LJAttractFixedRepulse)

class LJDouble(interaction):
    """Proxy of C++ NListed<(LJDoubleAtom,LJDoublePair)> class"""
    __swig_setmethods__ = {}
    for _s in [interaction]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJDouble, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LJDouble, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(NListed<(LJDoubleAtom,LJDoublePair)> self, neighborlist neighbors) -> LJDouble"""
        this = _sim2dlong.new_LJDouble(*args)
        try: self.this.append(this)
        except: self.this = this
    def add(self, *args) -> "void" :
        """add(LJDouble self, LJDoubleAtom atm)"""
        return _sim2dlong.LJDouble_add(self, *args)

    def update_pairs(self) -> "void" :
        """update_pairs(LJDouble self)"""
        return _sim2dlong.LJDouble_update_pairs(self)

    def getpair(self, *args) -> "LJDoublePair" :
        """getpair(LJDouble self, idpair pair) -> LJDoublePair"""
        return _sim2dlong.LJDouble_getpair(self, *args)

    def getatom(self, *args) -> "LJDoubleAtom &" :
        """getatom(LJDouble self, uint n) -> LJDoubleAtom"""
        return _sim2dlong.LJDouble_getatom(self, *args)

    def energy(self, *args) -> "flt" :
        """
        energy(LJDouble self, Box box, idpair pair) -> flt
        energy(LJDouble self, Box box) -> flt
        """
        return _sim2dlong.LJDouble_energy(self, *args)

    def pressure(self, *args) -> "flt" :
        """pressure(LJDouble self, Box box) -> flt"""
        return _sim2dlong.LJDouble_pressure(self, *args)

    def size(self) -> "uint" :
        """size(LJDouble self) -> uint"""
        return _sim2dlong.LJDouble_size(self)

    def energy_pair(self, *args) -> "flt" :
        """energy_pair(LJDouble self, LJDoublePair pair, Box box) -> flt"""
        return _sim2dlong.LJDouble_energy_pair(self, *args)

    def setForces(self, *args) -> "void" :
        """setForces(LJDouble self, Box box)"""
        return _sim2dlong.LJDouble_setForces(self, *args)

    def setForcesGetPressure(self, *args) -> "flt" :
        """setForcesGetPressure(LJDouble self, Box box) -> flt"""
        return _sim2dlong.LJDouble_setForcesGetPressure(self, *args)

    def forces_pair(self, *args) -> "Vec" :
        """forces_pair(LJDouble self, LJDoublePair pair, Box box) -> VecL"""
        return _sim2dlong.LJDouble_forces_pair(self, *args)

    def atom_list(self) -> "std::vector< LJDoubleAtom > &" :
        """atom_list(LJDouble self) -> std::vector< LJDoubleAtom > &"""
        return _sim2dlong.LJDouble_atom_list(self)

    def nlist(self) -> "neighborlist *" :
        """nlist(LJDouble self) -> neighborlist"""
        return _sim2dlong.LJDouble_nlist(self)

    __swig_destroy__ = _sim2dlong.delete_LJDouble
    __del__ = lambda self : None;
LJDouble_swigregister = _sim2dlong.LJDouble_swigregister
LJDouble_swigregister(LJDouble)

class EisMclachlan(interaction):
    """Proxy of C++ NListed<(EisMclachlanAtom,EisMclachlanPair)> class"""
    __swig_setmethods__ = {}
    for _s in [interaction]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, EisMclachlan, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, EisMclachlan, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(NListed<(EisMclachlanAtom,EisMclachlanPair)> self, neighborlist neighbors) -> EisMclachlan"""
        this = _sim2dlong.new_EisMclachlan(*args)
        try: self.this.append(this)
        except: self.this = this
    def add(self, *args) -> "void" :
        """add(EisMclachlan self, EisMclachlanAtom atm)"""
        return _sim2dlong.EisMclachlan_add(self, *args)

    def update_pairs(self) -> "void" :
        """update_pairs(EisMclachlan self)"""
        return _sim2dlong.EisMclachlan_update_pairs(self)

    def getpair(self, *args) -> "EisMclachlanPair" :
        """getpair(EisMclachlan self, idpair pair) -> EisMclachlanPair"""
        return _sim2dlong.EisMclachlan_getpair(self, *args)

    def getatom(self, *args) -> "EisMclachlanAtom &" :
        """getatom(EisMclachlan self, uint n) -> EisMclachlanAtom"""
        return _sim2dlong.EisMclachlan_getatom(self, *args)

    def energy(self, *args) -> "flt" :
        """
        energy(EisMclachlan self, Box box, idpair pair) -> flt
        energy(EisMclachlan self, Box box) -> flt
        """
        return _sim2dlong.EisMclachlan_energy(self, *args)

    def pressure(self, *args) -> "flt" :
        """pressure(EisMclachlan self, Box box) -> flt"""
        return _sim2dlong.EisMclachlan_pressure(self, *args)

    def size(self) -> "uint" :
        """size(EisMclachlan self) -> uint"""
        return _sim2dlong.EisMclachlan_size(self)

    def energy_pair(self, *args) -> "flt" :
        """energy_pair(EisMclachlan self, EisMclachlanPair pair, Box box) -> flt"""
        return _sim2dlong.EisMclachlan_energy_pair(self, *args)

    def setForces(self, *args) -> "void" :
        """setForces(EisMclachlan self, Box box)"""
        return _sim2dlong.EisMclachlan_setForces(self, *args)

    def setForcesGetPressure(self, *args) -> "flt" :
        """setForcesGetPressure(EisMclachlan self, Box box) -> flt"""
        return _sim2dlong.EisMclachlan_setForcesGetPressure(self, *args)

    def forces_pair(self, *args) -> "Vec" :
        """forces_pair(EisMclachlan self, EisMclachlanPair pair, Box box) -> VecL"""
        return _sim2dlong.EisMclachlan_forces_pair(self, *args)

    def atom_list(self) -> "std::vector< EisMclachlanAtom > &" :
        """atom_list(EisMclachlan self) -> std::vector< EisMclachlanAtom > &"""
        return _sim2dlong.EisMclachlan_atom_list(self)

    def nlist(self) -> "neighborlist *" :
        """nlist(EisMclachlan self) -> neighborlist"""
        return _sim2dlong.EisMclachlan_nlist(self)

    __swig_destroy__ = _sim2dlong.delete_EisMclachlan
    __del__ = lambda self : None;
EisMclachlan_swigregister = _sim2dlong.EisMclachlan_swigregister
EisMclachlan_swigregister(EisMclachlan)

class LJish(interaction):
    """Proxy of C++ NListed<(LJishAtom,LJishPair)> class"""
    __swig_setmethods__ = {}
    for _s in [interaction]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJish, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LJish, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(NListed<(LJishAtom,LJishPair)> self, neighborlist neighbors) -> LJish"""
        this = _sim2dlong.new_LJish(*args)
        try: self.this.append(this)
        except: self.this = this
    def add(self, *args) -> "void" :
        """add(LJish self, LJishAtom atm)"""
        return _sim2dlong.LJish_add(self, *args)

    def update_pairs(self) -> "void" :
        """update_pairs(LJish self)"""
        return _sim2dlong.LJish_update_pairs(self)

    def getpair(self, *args) -> "LJishPair" :
        """getpair(LJish self, idpair pair) -> LJishPair"""
        return _sim2dlong.LJish_getpair(self, *args)

    def getatom(self, *args) -> "LJishAtom &" :
        """getatom(LJish self, uint n) -> LJishAtom"""
        return _sim2dlong.LJish_getatom(self, *args)

    def energy(self, *args) -> "flt" :
        """
        energy(LJish self, Box box, idpair pair) -> flt
        energy(LJish self, Box box) -> flt
        """
        return _sim2dlong.LJish_energy(self, *args)

    def pressure(self, *args) -> "flt" :
        """pressure(LJish self, Box box) -> flt"""
        return _sim2dlong.LJish_pressure(self, *args)

    def size(self) -> "uint" :
        """size(LJish self) -> uint"""
        return _sim2dlong.LJish_size(self)

    def energy_pair(self, *args) -> "flt" :
        """energy_pair(LJish self, LJishPair pair, Box box) -> flt"""
        return _sim2dlong.LJish_energy_pair(self, *args)

    def setForces(self, *args) -> "void" :
        """setForces(LJish self, Box box)"""
        return _sim2dlong.LJish_setForces(self, *args)

    def setForcesGetPressure(self, *args) -> "flt" :
        """setForcesGetPressure(LJish self, Box box) -> flt"""
        return _sim2dlong.LJish_setForcesGetPressure(self, *args)

    def forces_pair(self, *args) -> "Vec" :
        """forces_pair(LJish self, LJishPair pair, Box box) -> VecL"""
        return _sim2dlong.LJish_forces_pair(self, *args)

    def atom_list(self) -> "std::vector< LJishAtom > &" :
        """atom_list(LJish self) -> std::vector< LJishAtom > &"""
        return _sim2dlong.LJish_atom_list(self)

    def nlist(self) -> "neighborlist *" :
        """nlist(LJish self) -> neighborlist"""
        return _sim2dlong.LJish_nlist(self)

    __swig_destroy__ = _sim2dlong.delete_LJish
    __del__ = lambda self : None;
LJish_swigregister = _sim2dlong.LJish_swigregister
LJish_swigregister(LJish)

class HertzianSimple(interaction):
    """Proxy of C++ SimpleListed<(HertzianAtom,HertzianPair)> class"""
    __swig_setmethods__ = {}
    for _s in [interaction]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HertzianSimple, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, HertzianSimple, name)
    __repr__ = _swig_repr
    def __init__(self): 
        """__init__(SimpleListed<(HertzianAtom,HertzianPair)> self) -> HertzianSimple"""
        this = _sim2dlong.new_HertzianSimple()
        try: self.this.append(this)
        except: self.this = this
    def add(self, *args) -> "void" :
        """add(HertzianSimple self, HertzianAtom atm)"""
        return _sim2dlong.HertzianSimple_add(self, *args)

    def energy(self, *args) -> "flt" :
        """energy(HertzianSimple self, Box box) -> flt"""
        return _sim2dlong.HertzianSimple_energy(self, *args)

    def pressure(self, *args) -> "flt" :
        """pressure(HertzianSimple self, Box box) -> flt"""
        return _sim2dlong.HertzianSimple_pressure(self, *args)

    def size(self) -> "uint" :
        """size(HertzianSimple self) -> uint"""
        return _sim2dlong.HertzianSimple_size(self)

    def setForces(self, *args) -> "void" :
        """setForces(HertzianSimple self, Box box)"""
        return _sim2dlong.HertzianSimple_setForces(self, *args)

    def setForcesGetPressure(self, *args) -> "flt" :
        """setForcesGetPressure(HertzianSimple self, Box box) -> flt"""
        return _sim2dlong.HertzianSimple_setForcesGetPressure(self, *args)

    def atom_list(self) -> "std::vector< HertzianAtom > &" :
        """atom_list(HertzianSimple self) -> std::vector< HertzianAtom > &"""
        return _sim2dlong.HertzianSimple_atom_list(self)

    __swig_destroy__ = _sim2dlong.delete_HertzianSimple
    __del__ = lambda self : None;
HertzianSimple_swigregister = _sim2dlong.HertzianSimple_swigregister
HertzianSimple_swigregister(HertzianSimple)

class HertzianPlain(interaction):
    """Proxy of C++ NListed<(HertzianAtom,HertzianPair)> class"""
    __swig_setmethods__ = {}
    for _s in [interaction]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HertzianPlain, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, HertzianPlain, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(NListed<(HertzianAtom,HertzianPair)> self, neighborlist neighbors) -> HertzianPlain"""
        this = _sim2dlong.new_HertzianPlain(*args)
        try: self.this.append(this)
        except: self.this = this
    def add(self, *args) -> "void" :
        """add(HertzianPlain self, HertzianAtom atm)"""
        return _sim2dlong.HertzianPlain_add(self, *args)

    def update_pairs(self) -> "void" :
        """update_pairs(HertzianPlain self)"""
        return _sim2dlong.HertzianPlain_update_pairs(self)

    def getpair(self, *args) -> "HertzianPair" :
        """getpair(HertzianPlain self, idpair pair) -> HertzianPair"""
        return _sim2dlong.HertzianPlain_getpair(self, *args)

    def getatom(self, *args) -> "HertzianAtom &" :
        """getatom(HertzianPlain self, uint n) -> HertzianAtom"""
        return _sim2dlong.HertzianPlain_getatom(self, *args)

    def energy(self, *args) -> "flt" :
        """
        energy(HertzianPlain self, Box box, idpair pair) -> flt
        energy(HertzianPlain self, Box box) -> flt
        """
        return _sim2dlong.HertzianPlain_energy(self, *args)

    def pressure(self, *args) -> "flt" :
        """pressure(HertzianPlain self, Box box) -> flt"""
        return _sim2dlong.HertzianPlain_pressure(self, *args)

    def size(self) -> "uint" :
        """size(HertzianPlain self) -> uint"""
        return _sim2dlong.HertzianPlain_size(self)

    def energy_pair(self, *args) -> "flt" :
        """energy_pair(HertzianPlain self, HertzianPair pair, Box box) -> flt"""
        return _sim2dlong.HertzianPlain_energy_pair(self, *args)

    def setForces(self, *args) -> "void" :
        """setForces(HertzianPlain self, Box box)"""
        return _sim2dlong.HertzianPlain_setForces(self, *args)

    def setForcesGetPressure(self, *args) -> "flt" :
        """setForcesGetPressure(HertzianPlain self, Box box) -> flt"""
        return _sim2dlong.HertzianPlain_setForcesGetPressure(self, *args)

    def forces_pair(self, *args) -> "Vec" :
        """forces_pair(HertzianPlain self, HertzianPair pair, Box box) -> VecL"""
        return _sim2dlong.HertzianPlain_forces_pair(self, *args)

    def atom_list(self) -> "std::vector< HertzianAtom > &" :
        """atom_list(HertzianPlain self) -> std::vector< HertzianAtom > &"""
        return _sim2dlong.HertzianPlain_atom_list(self)

    def nlist(self) -> "neighborlist *" :
        """nlist(HertzianPlain self) -> neighborlist"""
        return _sim2dlong.HertzianPlain_nlist(self)

    __swig_destroy__ = _sim2dlong.delete_HertzianPlain
    __del__ = lambda self : None;
HertzianPlain_swigregister = _sim2dlong.HertzianPlain_swigregister
HertzianPlain_swigregister(HertzianPlain)

class Hertzian(interactionpairsx,HertzianPlain):
    """Proxy of C++ NListedVirial<(HertzianAtom,HertzianPair)> class"""
    __swig_setmethods__ = {}
    for _s in [interactionpairsx,HertzianPlain]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Hertzian, name, value)
    __swig_getmethods__ = {}
    for _s in [interactionpairsx,HertzianPlain]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Hertzian, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(NListedVirial<(HertzianAtom,HertzianPair)> self, neighborlist neighbors) -> Hertzian"""
        this = _sim2dlong.new_Hertzian(*args)
        try: self.this.append(this)
        except: self.this = this
    def setForces(self, *args) -> "void" :
        """
        setForces(Hertzian self, Box box)
        setForces(Hertzian self, Box box, fpairxFunct arg3)
        """
        return _sim2dlong.Hertzian_setForces(self, *args)

    def setForcesGetPressure(self, *args) -> "flt" :
        """setForcesGetPressure(Hertzian self, Box box) -> flt"""
        return _sim2dlong.Hertzian_setForcesGetPressure(self, *args)

    def setForcesGetEnergy(self, *args) -> "flt" :
        """setForcesGetEnergy(Hertzian self, Box box) -> flt"""
        return _sim2dlong.Hertzian_setForcesGetEnergy(self, *args)

    def energy(self, *args) -> "flt" :
        """energy(Hertzian self, Box box) -> flt"""
        return _sim2dlong.Hertzian_energy(self, *args)

    def pressure(self, *args) -> "flt" :
        """pressure(Hertzian self, Box box) -> flt"""
        return _sim2dlong.Hertzian_pressure(self, *args)

    __swig_destroy__ = _sim2dlong.delete_Hertzian
    __del__ = lambda self : None;
Hertzian_swigregister = _sim2dlong.Hertzian_swigregister
Hertzian_swigregister(Hertzian)

class LoisOhern(interaction):
    """Proxy of C++ NListed<(LoisOhernAtom,LoisOhernPair)> class"""
    __swig_setmethods__ = {}
    for _s in [interaction]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LoisOhern, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LoisOhern, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(NListed<(LoisOhernAtom,LoisOhernPair)> self, neighborlist neighbors) -> LoisOhern"""
        this = _sim2dlong.new_LoisOhern(*args)
        try: self.this.append(this)
        except: self.this = this
    def add(self, *args) -> "void" :
        """add(LoisOhern self, LoisOhernAtom atm)"""
        return _sim2dlong.LoisOhern_add(self, *args)

    def update_pairs(self) -> "void" :
        """update_pairs(LoisOhern self)"""
        return _sim2dlong.LoisOhern_update_pairs(self)

    def getpair(self, *args) -> "LoisOhernPair" :
        """getpair(LoisOhern self, idpair pair) -> LoisOhernPair"""
        return _sim2dlong.LoisOhern_getpair(self, *args)

    def getatom(self, *args) -> "LoisOhernAtom &" :
        """getatom(LoisOhern self, uint n) -> LoisOhernAtom"""
        return _sim2dlong.LoisOhern_getatom(self, *args)

    def energy(self, *args) -> "flt" :
        """
        energy(LoisOhern self, Box box, idpair pair) -> flt
        energy(LoisOhern self, Box box) -> flt
        """
        return _sim2dlong.LoisOhern_energy(self, *args)

    def pressure(self, *args) -> "flt" :
        """pressure(LoisOhern self, Box box) -> flt"""
        return _sim2dlong.LoisOhern_pressure(self, *args)

    def size(self) -> "uint" :
        """size(LoisOhern self) -> uint"""
        return _sim2dlong.LoisOhern_size(self)

    def energy_pair(self, *args) -> "flt" :
        """energy_pair(LoisOhern self, LoisOhernPair pair, Box box) -> flt"""
        return _sim2dlong.LoisOhern_energy_pair(self, *args)

    def setForces(self, *args) -> "void" :
        """setForces(LoisOhern self, Box box)"""
        return _sim2dlong.LoisOhern_setForces(self, *args)

    def setForcesGetPressure(self, *args) -> "flt" :
        """setForcesGetPressure(LoisOhern self, Box box) -> flt"""
        return _sim2dlong.LoisOhern_setForcesGetPressure(self, *args)

    def forces_pair(self, *args) -> "Vec" :
        """forces_pair(LoisOhern self, LoisOhernPair pair, Box box) -> VecL"""
        return _sim2dlong.LoisOhern_forces_pair(self, *args)

    def atom_list(self) -> "std::vector< LoisOhernAtom > &" :
        """atom_list(LoisOhern self) -> std::vector< LoisOhernAtom > &"""
        return _sim2dlong.LoisOhern_atom_list(self)

    def nlist(self) -> "neighborlist *" :
        """nlist(LoisOhern self) -> neighborlist"""
        return _sim2dlong.LoisOhern_nlist(self)

    __swig_destroy__ = _sim2dlong.delete_LoisOhern
    __del__ = lambda self : None;
LoisOhern_swigregister = _sim2dlong.LoisOhern_swigregister
LoisOhern_swigregister(LoisOhern)

class collection(_object):
    """Proxy of C++ collection class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, collection, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, collection, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def setForces(self, seta : 'bool'=True) -> "void" :
        """
        setForces(collection self, bool seta=True)
        setForces(collection self)
        """
        return _sim2dlong.collection_setForces(self, seta)

    def timestep(self) -> "void" :
        """timestep(collection self)"""
        return _sim2dlong.collection_timestep(self)

    def dof(self) -> "flt" :
        """dof(collection self) -> flt"""
        return _sim2dlong.collection_dof(self)

    def potentialenergy(self) -> "flt" :
        """potentialenergy(collection self) -> flt"""
        return _sim2dlong.collection_potentialenergy(self)

    def energy(self) -> "flt" :
        """energy(collection self) -> flt"""
        return _sim2dlong.collection_energy(self)

    def temp(self, minuscomv : 'bool'=True) -> "flt" :
        """
        temp(collection self, bool minuscomv=True) -> flt
        temp(collection self) -> flt
        """
        return _sim2dlong.collection_temp(self, minuscomv)

    def kinetic(self) -> "flt" :
        """kinetic(collection self) -> flt"""
        return _sim2dlong.collection_kinetic(self)

    def virial(self) -> "flt" :
        """virial(collection self) -> flt"""
        return _sim2dlong.collection_virial(self)

    def pressure(self) -> "flt" :
        """pressure(collection self) -> flt"""
        return _sim2dlong.collection_pressure(self)

    def getbox(self) -> "Box *" :
        """getbox(collection self) -> Box"""
        return _sim2dlong.collection_getbox(self)

    def com(self) -> "Vec" :
        """com(collection self) -> VecL"""
        return _sim2dlong.collection_com(self)

    def comv(self) -> "Vec" :
        """comv(collection self) -> VecL"""
        return _sim2dlong.collection_comv(self)

    def angmomentum(self, *args) -> "flt" :
        """
        angmomentum(collection self, VecL loc) -> flt
        angmomentum(collection self) -> flt
        """
        return _sim2dlong.collection_angmomentum(self, *args)

    def gyradius(self) -> "flt" :
        """gyradius(collection self) -> flt"""
        return _sim2dlong.collection_gyradius(self)

    __swig_destroy__ = _sim2dlong.delete_collection
    __del__ = lambda self : None;
    def resetcomv(self) -> "void" :
        """resetcomv(collection self)"""
        return _sim2dlong.collection_resetcomv(self)

    def resetL(self) -> "void" :
        """resetL(collection self)"""
        return _sim2dlong.collection_resetL(self)

    def scaleVs(self, *args) -> "void" :
        """scaleVs(collection self, flt scaleby)"""
        return _sim2dlong.collection_scaleVs(self, *args)

    def scaleVelocitiesT(self, *args) -> "void" :
        """scaleVelocitiesT(collection self, flt T)"""
        return _sim2dlong.collection_scaleVelocitiesT(self, *args)

    def scaleVelocitiesE(self, *args) -> "void" :
        """scaleVelocitiesE(collection self, flt E)"""
        return _sim2dlong.collection_scaleVelocitiesE(self, *args)

    def addInteraction(self, *args) -> "void" :
        """addInteraction(collection self, interaction inter)"""
        return _sim2dlong.collection_addInteraction(self, *args)

    def addTracker(self, *args) -> "void" :
        """addTracker(collection self, statetracker track)"""
        return _sim2dlong.collection_addTracker(self, *args)

    def getInteractions(self) -> "std::vector< interaction * >" :
        """getInteractions(collection self) -> ivector"""
        return _sim2dlong.collection_getInteractions(self)

    def numInteraction(self) -> "uint" :
        """numInteraction(collection self) -> uint"""
        return _sim2dlong.collection_numInteraction(self)

    def setE0(self, *args) -> "void" :
        """setE0(collection self, flt newE0)"""
        return _sim2dlong.collection_setE0(self, *args)

collection_swigregister = _sim2dlong.collection_swigregister
collection_swigregister(collection)

class StaticCollec(collection):
    """Proxy of C++ StaticCollec class"""
    __swig_setmethods__ = {}
    for _s in [collection]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, StaticCollec, name, value)
    __swig_getmethods__ = {}
    for _s in [collection]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, StaticCollec, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(StaticCollec self, Box box, avector groups, ivector interactions=std::vector< interaction * >(), tvector trackers=std::vector< statetracker * >(), 
            constraintvector constraints=std::vector< constraint * >()) -> StaticCollec
        __init__(StaticCollec self, Box box, avector groups, ivector interactions=std::vector< interaction * >(), tvector trackers=std::vector< statetracker * >()) -> StaticCollec
        __init__(StaticCollec self, Box box, avector groups, ivector interactions=std::vector< interaction * >()) -> StaticCollec
        __init__(StaticCollec self, Box box, avector groups) -> StaticCollec
        """
        this = _sim2dlong.new_StaticCollec(*args)
        try: self.this.append(this)
        except: self.this = this
    def timestep(self) -> "void" :
        """timestep(StaticCollec self)"""
        return _sim2dlong.StaticCollec_timestep(self)

    def update(self) -> "void" :
        """update(StaticCollec self)"""
        return _sim2dlong.StaticCollec_update(self)

    __swig_destroy__ = _sim2dlong.delete_StaticCollec
    __del__ = lambda self : None;
StaticCollec_swigregister = _sim2dlong.StaticCollec_swigregister
StaticCollec_swigregister(StaticCollec)

class collectionSol(collection):
    """Proxy of C++ collectionSol class"""
    __swig_setmethods__ = {}
    for _s in [collection]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, collectionSol, name, value)
    __swig_getmethods__ = {}
    for _s in [collection]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, collectionSol, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(collectionSol self, Box box, flt const dt, flt const damping, flt const desiredT, avector groups=std::vector< atomgroup * >(), 
            ivector interactions=std::vector< interaction * >(), 
            tvector trackers=std::vector< statetracker * >(), constraintvector constraints=std::vector< constraint * >()) -> collectionSol
        __init__(collectionSol self, Box box, flt const dt, flt const damping, flt const desiredT, avector groups=std::vector< atomgroup * >(), 
            ivector interactions=std::vector< interaction * >(), 
            tvector trackers=std::vector< statetracker * >()) -> collectionSol
        __init__(collectionSol self, Box box, flt const dt, flt const damping, flt const desiredT, avector groups=std::vector< atomgroup * >(), 
            ivector interactions=std::vector< interaction * >()) -> collectionSol
        __init__(collectionSol self, Box box, flt const dt, flt const damping, flt const desiredT, avector groups=std::vector< atomgroup * >()) -> collectionSol
        __init__(collectionSol self, Box box, flt const dt, flt const damping, flt const desiredT) -> collectionSol
        """
        this = _sim2dlong.new_collectionSol(*args)
        try: self.this.append(this)
        except: self.this = this
    def changeT(self, *args) -> "void" :
        """changeT(collectionSol self, flt const newdt, flt const damp, flt const desiredT)"""
        return _sim2dlong.collectionSol_changeT(self, *args)

    def timestep(self) -> "void" :
        """timestep(collectionSol self)"""
        return _sim2dlong.collectionSol_timestep(self)

    __swig_destroy__ = _sim2dlong.delete_collectionSol
    __del__ = lambda self : None;
collectionSol_swigregister = _sim2dlong.collectionSol_swigregister
collectionSol_swigregister(collectionSol)

class collectionSolHT(collection):
    """Proxy of C++ collectionSolHT class"""
    __swig_setmethods__ = {}
    for _s in [collection]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, collectionSolHT, name, value)
    __swig_getmethods__ = {}
    for _s in [collection]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, collectionSolHT, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(collectionSolHT self, Box box, flt const dt, flt const damping, flt const desiredT, avector groups=std::vector< atomgroup * >(), 
            ivector interactions=std::vector< interaction * >(), 
            tvector trackers=std::vector< statetracker * >(), constraintvector constraints=std::vector< constraint * >()) -> collectionSolHT
        __init__(collectionSolHT self, Box box, flt const dt, flt const damping, flt const desiredT, avector groups=std::vector< atomgroup * >(), 
            ivector interactions=std::vector< interaction * >(), 
            tvector trackers=std::vector< statetracker * >()) -> collectionSolHT
        __init__(collectionSolHT self, Box box, flt const dt, flt const damping, flt const desiredT, avector groups=std::vector< atomgroup * >(), 
            ivector interactions=std::vector< interaction * >()) -> collectionSolHT
        __init__(collectionSolHT self, Box box, flt const dt, flt const damping, flt const desiredT, avector groups=std::vector< atomgroup * >()) -> collectionSolHT
        __init__(collectionSolHT self, Box box, flt const dt, flt const damping, flt const desiredT) -> collectionSolHT
        """
        this = _sim2dlong.new_collectionSolHT(*args)
        try: self.this.append(this)
        except: self.this = this
    def changeT(self, *args) -> "void" :
        """changeT(collectionSolHT self, flt const newdt, flt const damp, flt const desiredT)"""
        return _sim2dlong.collectionSolHT_changeT(self, *args)

    def timestep(self) -> "void" :
        """timestep(collectionSolHT self)"""
        return _sim2dlong.collectionSolHT_timestep(self)

    __swig_destroy__ = _sim2dlong.delete_collectionSolHT
    __del__ = lambda self : None;
collectionSolHT_swigregister = _sim2dlong.collectionSolHT_swigregister
collectionSolHT_swigregister(collectionSolHT)

class collectionVerlet(collection):
    """Proxy of C++ collectionVerlet class"""
    __swig_setmethods__ = {}
    for _s in [collection]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, collectionVerlet, name, value)
    __swig_getmethods__ = {}
    for _s in [collection]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, collectionVerlet, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(collectionVerlet self, Box box, flt const dt, avector groups=std::vector< atomgroup * >(), ivector interactions=std::vector< interaction * >(), 
            tvector trackers=std::vector< statetracker * >(), 
            constraintvector constraints=std::vector< constraint * >()) -> collectionVerlet
        __init__(collectionVerlet self, Box box, flt const dt, avector groups=std::vector< atomgroup * >(), ivector interactions=std::vector< interaction * >(), 
            tvector trackers=std::vector< statetracker * >()) -> collectionVerlet
        __init__(collectionVerlet self, Box box, flt const dt, avector groups=std::vector< atomgroup * >(), ivector interactions=std::vector< interaction * >()) -> collectionVerlet
        __init__(collectionVerlet self, Box box, flt const dt, avector groups=std::vector< atomgroup * >()) -> collectionVerlet
        __init__(collectionVerlet self, Box box, flt const dt) -> collectionVerlet
        """
        this = _sim2dlong.new_collectionVerlet(*args)
        try: self.this.append(this)
        except: self.this = this
    def timestep(self) -> "void" :
        """timestep(collectionVerlet self)"""
        return _sim2dlong.collectionVerlet_timestep(self)

    def setdt(self, *args) -> "void" :
        """setdt(collectionVerlet self, flt newdt)"""
        return _sim2dlong.collectionVerlet_setdt(self, *args)

    __swig_destroy__ = _sim2dlong.delete_collectionVerlet
    __del__ = lambda self : None;
collectionVerlet_swigregister = _sim2dlong.collectionVerlet_swigregister
collectionVerlet_swigregister(collectionVerlet)

class collectionOverdamped(collection):
    """Proxy of C++ collectionOverdamped class"""
    __swig_setmethods__ = {}
    for _s in [collection]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, collectionOverdamped, name, value)
    __swig_getmethods__ = {}
    for _s in [collection]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, collectionOverdamped, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(collectionOverdamped self, Box box, flt const dt, float const gamma, avector groups=std::vector< atomgroup * >(), 
            ivector interactions=std::vector< interaction * >(), tvector trackers=std::vector< statetracker * >(), 
            constraintvector constraints=std::vector< constraint * >()) -> collectionOverdamped
        __init__(collectionOverdamped self, Box box, flt const dt, float const gamma, avector groups=std::vector< atomgroup * >(), 
            ivector interactions=std::vector< interaction * >(), tvector trackers=std::vector< statetracker * >()) -> collectionOverdamped
        __init__(collectionOverdamped self, Box box, flt const dt, float const gamma, avector groups=std::vector< atomgroup * >(), 
            ivector interactions=std::vector< interaction * >()) -> collectionOverdamped
        __init__(collectionOverdamped self, Box box, flt const dt, float const gamma, avector groups=std::vector< atomgroup * >()) -> collectionOverdamped
        __init__(collectionOverdamped self, Box box, flt const dt, float const gamma) -> collectionOverdamped
        """
        this = _sim2dlong.new_collectionOverdamped(*args)
        try: self.this.append(this)
        except: self.this = this
    def timestep(self) -> "void" :
        """timestep(collectionOverdamped self)"""
        return _sim2dlong.collectionOverdamped_timestep(self)

    def setdt(self, *args) -> "void" :
        """setdt(collectionOverdamped self, flt newdt)"""
        return _sim2dlong.collectionOverdamped_setdt(self, *args)

    __swig_destroy__ = _sim2dlong.delete_collectionOverdamped
    __del__ = lambda self : None;
collectionOverdamped_swigregister = _sim2dlong.collectionOverdamped_swigregister
collectionOverdamped_swigregister(collectionOverdamped)

class collectionConjGradient(collection):
    """Proxy of C++ collectionConjGradient class"""
    __swig_setmethods__ = {}
    for _s in [collection]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, collectionConjGradient, name, value)
    __swig_getmethods__ = {}
    for _s in [collection]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, collectionConjGradient, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(collectionConjGradient self, Box box, flt const dt, avector groups=std::vector< atomgroup * >(), ivector interactions=std::vector< interaction * >(), 
            tvector trackers=std::vector< statetracker * >(), 
            constraintvector constraints=std::vector< constraint * >()) -> collectionConjGradient
        __init__(collectionConjGradient self, Box box, flt const dt, avector groups=std::vector< atomgroup * >(), ivector interactions=std::vector< interaction * >(), 
            tvector trackers=std::vector< statetracker * >()) -> collectionConjGradient
        __init__(collectionConjGradient self, Box box, flt const dt, avector groups=std::vector< atomgroup * >(), ivector interactions=std::vector< interaction * >()) -> collectionConjGradient
        __init__(collectionConjGradient self, Box box, flt const dt, avector groups=std::vector< atomgroup * >()) -> collectionConjGradient
        __init__(collectionConjGradient self, Box box, flt const dt) -> collectionConjGradient
        """
        this = _sim2dlong.new_collectionConjGradient(*args)
        try: self.this.append(this)
        except: self.this = this
    def timestep(self) -> "void" :
        """timestep(collectionConjGradient self)"""
        return _sim2dlong.collectionConjGradient_timestep(self)

    def timestepNewton(self) -> "void" :
        """timestepNewton(collectionConjGradient self)"""
        return _sim2dlong.collectionConjGradient_timestepNewton(self)

    def reset(self) -> "void" :
        """reset(collectionConjGradient self)"""
        return _sim2dlong.collectionConjGradient_reset(self)

    def setdt(self, *args) -> "void" :
        """setdt(collectionConjGradient self, flt newdt)"""
        return _sim2dlong.collectionConjGradient_setdt(self, *args)

    __swig_destroy__ = _sim2dlong.delete_collectionConjGradient
    __del__ = lambda self : None;
collectionConjGradient_swigregister = _sim2dlong.collectionConjGradient_swigregister
collectionConjGradient_swigregister(collectionConjGradient)

class collectionConjGradientBox(collection):
    """Proxy of C++ collectionConjGradientBox class"""
    __swig_setmethods__ = {}
    for _s in [collection]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, collectionConjGradientBox, name, value)
    __swig_getmethods__ = {}
    for _s in [collection]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, collectionConjGradientBox, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(collectionConjGradientBox self, OriginBox box, flt const dt, flt const P0, flt const kappaV=1, avector groups=std::vector< atomgroup * >(), 
            ivector interactions=std::vector< interaction * >(), 
            tvector trackers=std::vector< statetracker * >(), constraintvector constraints=std::vector< constraint * >()) -> collectionConjGradientBox
        __init__(collectionConjGradientBox self, OriginBox box, flt const dt, flt const P0, flt const kappaV=1, avector groups=std::vector< atomgroup * >(), 
            ivector interactions=std::vector< interaction * >(), 
            tvector trackers=std::vector< statetracker * >()) -> collectionConjGradientBox
        __init__(collectionConjGradientBox self, OriginBox box, flt const dt, flt const P0, flt const kappaV=1, avector groups=std::vector< atomgroup * >(), 
            ivector interactions=std::vector< interaction * >()) -> collectionConjGradientBox
        __init__(collectionConjGradientBox self, OriginBox box, flt const dt, flt const P0, flt const kappaV=1, avector groups=std::vector< atomgroup * >()) -> collectionConjGradientBox
        __init__(collectionConjGradientBox self, OriginBox box, flt const dt, flt const P0, flt const kappaV=1) -> collectionConjGradientBox
        __init__(collectionConjGradientBox self, OriginBox box, flt const dt, flt const P0) -> collectionConjGradientBox
        """
        this = _sim2dlong.new_collectionConjGradientBox(*args)
        try: self.this.append(this)
        except: self.this = this
    def kinetic(self) -> "flt" :
        """kinetic(collectionConjGradientBox self) -> flt"""
        return _sim2dlong.collectionConjGradientBox_kinetic(self)

    def timestep(self) -> "void" :
        """timestep(collectionConjGradientBox self)"""
        return _sim2dlong.collectionConjGradientBox_timestep(self)

    def timestepBox(self) -> "void" :
        """timestepBox(collectionConjGradientBox self)"""
        return _sim2dlong.collectionConjGradientBox_timestepBox(self)

    def timestepAtoms(self) -> "void" :
        """timestepAtoms(collectionConjGradientBox self)"""
        return _sim2dlong.collectionConjGradientBox_timestepAtoms(self)

    def reset(self) -> "void" :
        """reset(collectionConjGradientBox self)"""
        return _sim2dlong.collectionConjGradientBox_reset(self)

    def resize(self, *args) -> "void" :
        """resize(collectionConjGradientBox self, flt V)"""
        return _sim2dlong.collectionConjGradientBox_resize(self, *args)

    def setdt(self, *args) -> "void" :
        """setdt(collectionConjGradientBox self, flt newdt)"""
        return _sim2dlong.collectionConjGradientBox_setdt(self, *args)

    def setP(self, *args) -> "void" :
        """setP(collectionConjGradientBox self, flt P)"""
        return _sim2dlong.collectionConjGradientBox_setP(self, *args)

    def setMaxdV(self, *args) -> "void" :
        """setMaxdV(collectionConjGradientBox self, flt diff)"""
        return _sim2dlong.collectionConjGradientBox_setMaxdV(self, *args)

    __swig_destroy__ = _sim2dlong.delete_collectionConjGradientBox
    __del__ = lambda self : None;
collectionConjGradientBox_swigregister = _sim2dlong.collectionConjGradientBox_swigregister
collectionConjGradientBox_swigregister(collectionConjGradientBox)

class collectionNLCG(collection):
    """Proxy of C++ collectionNLCG class"""
    __swig_setmethods__ = {}
    for _s in [collection]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, collectionNLCG, name, value)
    __swig_getmethods__ = {}
    for _s in [collection]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, collectionNLCG, name)
    __repr__ = _swig_repr
    __swig_setmethods__["dt"] = _sim2dlong.collectionNLCG_dt_set
    __swig_getmethods__["dt"] = _sim2dlong.collectionNLCG_dt_get
    if _newclass:dt = _swig_property(_sim2dlong.collectionNLCG_dt_get, _sim2dlong.collectionNLCG_dt_set)
    __swig_setmethods__["secmax"] = _sim2dlong.collectionNLCG_secmax_set
    __swig_getmethods__["secmax"] = _sim2dlong.collectionNLCG_secmax_get
    if _newclass:secmax = _swig_property(_sim2dlong.collectionNLCG_secmax_get, _sim2dlong.collectionNLCG_secmax_set)
    __swig_setmethods__["seceps"] = _sim2dlong.collectionNLCG_seceps_set
    __swig_getmethods__["seceps"] = _sim2dlong.collectionNLCG_seceps_get
    if _newclass:seceps = _swig_property(_sim2dlong.collectionNLCG_seceps_get, _sim2dlong.collectionNLCG_seceps_set)
    __swig_setmethods__["alphamax"] = _sim2dlong.collectionNLCG_alphamax_set
    __swig_getmethods__["alphamax"] = _sim2dlong.collectionNLCG_alphamax_get
    if _newclass:alphamax = _swig_property(_sim2dlong.collectionNLCG_alphamax_get, _sim2dlong.collectionNLCG_alphamax_set)
    __swig_setmethods__["dxmax"] = _sim2dlong.collectionNLCG_dxmax_set
    __swig_getmethods__["dxmax"] = _sim2dlong.collectionNLCG_dxmax_get
    if _newclass:dxmax = _swig_property(_sim2dlong.collectionNLCG_dxmax_get, _sim2dlong.collectionNLCG_dxmax_set)
    __swig_setmethods__["kappa"] = _sim2dlong.collectionNLCG_kappa_set
    __swig_getmethods__["kappa"] = _sim2dlong.collectionNLCG_kappa_get
    if _newclass:kappa = _swig_property(_sim2dlong.collectionNLCG_kappa_get, _sim2dlong.collectionNLCG_kappa_set)
    __swig_setmethods__["kmax"] = _sim2dlong.collectionNLCG_kmax_set
    __swig_getmethods__["kmax"] = _sim2dlong.collectionNLCG_kmax_get
    if _newclass:kmax = _swig_property(_sim2dlong.collectionNLCG_kmax_get, _sim2dlong.collectionNLCG_kmax_set)
    __swig_setmethods__["P0"] = _sim2dlong.collectionNLCG_P0_set
    __swig_getmethods__["P0"] = _sim2dlong.collectionNLCG_P0_get
    if _newclass:P0 = _swig_property(_sim2dlong.collectionNLCG_P0_get, _sim2dlong.collectionNLCG_P0_set)
    __swig_setmethods__["Knew"] = _sim2dlong.collectionNLCG_Knew_set
    __swig_getmethods__["Knew"] = _sim2dlong.collectionNLCG_Knew_get
    if _newclass:Knew = _swig_property(_sim2dlong.collectionNLCG_Knew_get, _sim2dlong.collectionNLCG_Knew_set)
    __swig_setmethods__["k"] = _sim2dlong.collectionNLCG_k_set
    __swig_getmethods__["k"] = _sim2dlong.collectionNLCG_k_get
    if _newclass:k = _swig_property(_sim2dlong.collectionNLCG_k_get, _sim2dlong.collectionNLCG_k_set)
    __swig_setmethods__["vl"] = _sim2dlong.collectionNLCG_vl_set
    __swig_getmethods__["vl"] = _sim2dlong.collectionNLCG_vl_get
    if _newclass:vl = _swig_property(_sim2dlong.collectionNLCG_vl_get, _sim2dlong.collectionNLCG_vl_set)
    __swig_setmethods__["fl"] = _sim2dlong.collectionNLCG_fl_set
    __swig_getmethods__["fl"] = _sim2dlong.collectionNLCG_fl_get
    if _newclass:fl = _swig_property(_sim2dlong.collectionNLCG_fl_get, _sim2dlong.collectionNLCG_fl_set)
    __swig_setmethods__["al"] = _sim2dlong.collectionNLCG_al_set
    __swig_getmethods__["al"] = _sim2dlong.collectionNLCG_al_get
    if _newclass:al = _swig_property(_sim2dlong.collectionNLCG_al_get, _sim2dlong.collectionNLCG_al_set)
    __swig_setmethods__["alpha"] = _sim2dlong.collectionNLCG_alpha_set
    __swig_getmethods__["alpha"] = _sim2dlong.collectionNLCG_alpha_get
    if _newclass:alpha = _swig_property(_sim2dlong.collectionNLCG_alpha_get, _sim2dlong.collectionNLCG_alpha_set)
    __swig_setmethods__["dxsum"] = _sim2dlong.collectionNLCG_dxsum_set
    __swig_getmethods__["dxsum"] = _sim2dlong.collectionNLCG_dxsum_get
    if _newclass:dxsum = _swig_property(_sim2dlong.collectionNLCG_dxsum_get, _sim2dlong.collectionNLCG_dxsum_set)
    __swig_setmethods__["alphavmax"] = _sim2dlong.collectionNLCG_alphavmax_set
    __swig_getmethods__["alphavmax"] = _sim2dlong.collectionNLCG_alphavmax_get
    if _newclass:alphavmax = _swig_property(_sim2dlong.collectionNLCG_alphavmax_get, _sim2dlong.collectionNLCG_alphavmax_set)
    __swig_setmethods__["maxdV"] = _sim2dlong.collectionNLCG_maxdV_set
    __swig_getmethods__["maxdV"] = _sim2dlong.collectionNLCG_maxdV_get
    if _newclass:maxdV = _swig_property(_sim2dlong.collectionNLCG_maxdV_get, _sim2dlong.collectionNLCG_maxdV_set)
    __swig_setmethods__["sec"] = _sim2dlong.collectionNLCG_sec_set
    __swig_getmethods__["sec"] = _sim2dlong.collectionNLCG_sec_get
    if _newclass:sec = _swig_property(_sim2dlong.collectionNLCG_sec_get, _sim2dlong.collectionNLCG_sec_set)
    def stepx(self, *args) -> "void" :
        """stepx(collectionNLCG self, flt dx)"""
        return _sim2dlong.collectionNLCG_stepx(self, *args)

    def getLsq(self) -> "flt" :
        """getLsq(collectionNLCG self) -> flt"""
        return _sim2dlong.collectionNLCG_getLsq(self)

    def fdota(self) -> "flt" :
        """fdota(collectionNLCG self) -> flt"""
        return _sim2dlong.collectionNLCG_fdota(self)

    def fdotf(self) -> "flt" :
        """fdotf(collectionNLCG self) -> flt"""
        return _sim2dlong.collectionNLCG_fdotf(self)

    def fdotv(self) -> "flt" :
        """fdotv(collectionNLCG self) -> flt"""
        return _sim2dlong.collectionNLCG_fdotv(self)

    def vdotv(self) -> "flt" :
        """vdotv(collectionNLCG self) -> flt"""
        return _sim2dlong.collectionNLCG_vdotv(self)

    def __init__(self, *args): 
        """
        __init__(collectionNLCG self, OriginBox box, flt const dt, flt const P0, avector groups=std::vector< atomgroup * >(), 
            ivector interactions=std::vector< interaction * >(), tvector trackers=std::vector< statetracker * >(), 
            constraintvector constraints=std::vector< constraint * >(), 
            flt const kappa=0, flt const kmax=1000, flt const secmax=10, 
            flt const seceps=0.0001) -> collectionNLCG
        __init__(collectionNLCG self, OriginBox box, flt const dt, flt const P0, avector groups=std::vector< atomgroup * >(), 
            ivector interactions=std::vector< interaction * >(), tvector trackers=std::vector< statetracker * >(), 
            constraintvector constraints=std::vector< constraint * >(), 
            flt const kappa=0, flt const kmax=1000, flt const secmax=10) -> collectionNLCG
        __init__(collectionNLCG self, OriginBox box, flt const dt, flt const P0, avector groups=std::vector< atomgroup * >(), 
            ivector interactions=std::vector< interaction * >(), tvector trackers=std::vector< statetracker * >(), 
            constraintvector constraints=std::vector< constraint * >(), 
            flt const kappa=0, flt const kmax=1000) -> collectionNLCG
        __init__(collectionNLCG self, OriginBox box, flt const dt, flt const P0, avector groups=std::vector< atomgroup * >(), 
            ivector interactions=std::vector< interaction * >(), tvector trackers=std::vector< statetracker * >(), 
            constraintvector constraints=std::vector< constraint * >(), 
            flt const kappa=0) -> collectionNLCG
        __init__(collectionNLCG self, OriginBox box, flt const dt, flt const P0, avector groups=std::vector< atomgroup * >(), 
            ivector interactions=std::vector< interaction * >(), tvector trackers=std::vector< statetracker * >(), 
            constraintvector constraints=std::vector< constraint * >()) -> collectionNLCG
        __init__(collectionNLCG self, OriginBox box, flt const dt, flt const P0, avector groups=std::vector< atomgroup * >(), 
            ivector interactions=std::vector< interaction * >(), tvector trackers=std::vector< statetracker * >()) -> collectionNLCG
        __init__(collectionNLCG self, OriginBox box, flt const dt, flt const P0, avector groups=std::vector< atomgroup * >(), 
            ivector interactions=std::vector< interaction * >()) -> collectionNLCG
        __init__(collectionNLCG self, OriginBox box, flt const dt, flt const P0, avector groups=std::vector< atomgroup * >()) -> collectionNLCG
        __init__(collectionNLCG self, OriginBox box, flt const dt, flt const P0) -> collectionNLCG
        """
        this = _sim2dlong.new_collectionNLCG(*args)
        try: self.this.append(this)
        except: self.this = this
    def kinetic(self) -> "flt" :
        """kinetic(collectionNLCG self) -> flt"""
        return _sim2dlong.collectionNLCG_kinetic(self)

    def pressure(self) -> "flt" :
        """pressure(collectionNLCG self) -> flt"""
        return _sim2dlong.collectionNLCG_pressure(self)

    def Hamiltonian(self) -> "flt" :
        """Hamiltonian(collectionNLCG self) -> flt"""
        return _sim2dlong.collectionNLCG_Hamiltonian(self)

    def setForces(self, *args) -> "void" :
        """
        setForces(collectionNLCG self, bool seta=True)
        setForces(collectionNLCG self)
        setForces(collectionNLCG self, bool seta, bool setV)
        """
        return _sim2dlong.collectionNLCG_setForces(self, *args)

    def timestep(self) -> "void" :
        """timestep(collectionNLCG self)"""
        return _sim2dlong.collectionNLCG_timestep(self)

    def descend(self) -> "void" :
        """descend(collectionNLCG self)"""
        return _sim2dlong.collectionNLCG_descend(self)

    def reset(self) -> "void" :
        """reset(collectionNLCG self)"""
        return _sim2dlong.collectionNLCG_reset(self)

    def resize(self, *args) -> "void" :
        """resize(collectionNLCG self, flt V)"""
        return _sim2dlong.collectionNLCG_resize(self, *args)

    def setdt(self, *args) -> "void" :
        """setdt(collectionNLCG self, flt newdt)"""
        return _sim2dlong.collectionNLCG_setdt(self, *args)

    def setP(self, *args) -> "void" :
        """setP(collectionNLCG self, flt P)"""
        return _sim2dlong.collectionNLCG_setP(self, *args)

    def setkappa(self, *args) -> "void" :
        """setkappa(collectionNLCG self, flt k)"""
        return _sim2dlong.collectionNLCG_setkappa(self, *args)

    def setamax(self, *args) -> "void" :
        """setamax(collectionNLCG self, flt a)"""
        return _sim2dlong.collectionNLCG_setamax(self, *args)

    def setdxmax(self, *args) -> "void" :
        """setdxmax(collectionNLCG self, flt d)"""
        return _sim2dlong.collectionNLCG_setdxmax(self, *args)

    def setmaxdV(self, *args) -> "void" :
        """setmaxdV(collectionNLCG self, flt d)"""
        return _sim2dlong.collectionNLCG_setmaxdV(self, *args)

    __swig_destroy__ = _sim2dlong.delete_collectionNLCG
    __del__ = lambda self : None;
collectionNLCG_swigregister = _sim2dlong.collectionNLCG_swigregister
collectionNLCG_swigregister(collectionNLCG)

class collectionNLCGV(collection):
    """Proxy of C++ collectionNLCGV class"""
    __swig_setmethods__ = {}
    for _s in [collection]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, collectionNLCGV, name, value)
    __swig_getmethods__ = {}
    for _s in [collection]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, collectionNLCGV, name)
    __repr__ = _swig_repr
    __swig_setmethods__["dt"] = _sim2dlong.collectionNLCGV_dt_set
    __swig_getmethods__["dt"] = _sim2dlong.collectionNLCGV_dt_get
    if _newclass:dt = _swig_property(_sim2dlong.collectionNLCGV_dt_get, _sim2dlong.collectionNLCGV_dt_set)
    __swig_setmethods__["secmax"] = _sim2dlong.collectionNLCGV_secmax_set
    __swig_getmethods__["secmax"] = _sim2dlong.collectionNLCGV_secmax_get
    if _newclass:secmax = _swig_property(_sim2dlong.collectionNLCGV_secmax_get, _sim2dlong.collectionNLCGV_secmax_set)
    __swig_setmethods__["seceps"] = _sim2dlong.collectionNLCGV_seceps_set
    __swig_getmethods__["seceps"] = _sim2dlong.collectionNLCGV_seceps_get
    if _newclass:seceps = _swig_property(_sim2dlong.collectionNLCGV_seceps_get, _sim2dlong.collectionNLCGV_seceps_set)
    __swig_setmethods__["alphamax"] = _sim2dlong.collectionNLCGV_alphamax_set
    __swig_getmethods__["alphamax"] = _sim2dlong.collectionNLCGV_alphamax_get
    if _newclass:alphamax = _swig_property(_sim2dlong.collectionNLCGV_alphamax_get, _sim2dlong.collectionNLCGV_alphamax_set)
    __swig_setmethods__["afrac"] = _sim2dlong.collectionNLCGV_afrac_set
    __swig_getmethods__["afrac"] = _sim2dlong.collectionNLCGV_afrac_get
    if _newclass:afrac = _swig_property(_sim2dlong.collectionNLCGV_afrac_get, _sim2dlong.collectionNLCGV_afrac_set)
    __swig_setmethods__["dxmax"] = _sim2dlong.collectionNLCGV_dxmax_set
    __swig_getmethods__["dxmax"] = _sim2dlong.collectionNLCGV_dxmax_get
    if _newclass:dxmax = _swig_property(_sim2dlong.collectionNLCGV_dxmax_get, _sim2dlong.collectionNLCGV_dxmax_set)
    __swig_setmethods__["stepmax"] = _sim2dlong.collectionNLCGV_stepmax_set
    __swig_getmethods__["stepmax"] = _sim2dlong.collectionNLCGV_stepmax_get
    if _newclass:stepmax = _swig_property(_sim2dlong.collectionNLCGV_stepmax_get, _sim2dlong.collectionNLCGV_stepmax_set)
    __swig_setmethods__["kmax"] = _sim2dlong.collectionNLCGV_kmax_set
    __swig_getmethods__["kmax"] = _sim2dlong.collectionNLCGV_kmax_get
    if _newclass:kmax = _swig_property(_sim2dlong.collectionNLCGV_kmax_get, _sim2dlong.collectionNLCGV_kmax_set)
    __swig_setmethods__["Knew"] = _sim2dlong.collectionNLCGV_Knew_set
    __swig_getmethods__["Knew"] = _sim2dlong.collectionNLCGV_Knew_get
    if _newclass:Knew = _swig_property(_sim2dlong.collectionNLCGV_Knew_get, _sim2dlong.collectionNLCGV_Knew_set)
    __swig_setmethods__["k"] = _sim2dlong.collectionNLCGV_k_set
    __swig_getmethods__["k"] = _sim2dlong.collectionNLCGV_k_get
    if _newclass:k = _swig_property(_sim2dlong.collectionNLCGV_k_get, _sim2dlong.collectionNLCGV_k_set)
    __swig_setmethods__["vl"] = _sim2dlong.collectionNLCGV_vl_set
    __swig_getmethods__["vl"] = _sim2dlong.collectionNLCGV_vl_get
    if _newclass:vl = _swig_property(_sim2dlong.collectionNLCGV_vl_get, _sim2dlong.collectionNLCGV_vl_set)
    __swig_setmethods__["fl"] = _sim2dlong.collectionNLCGV_fl_set
    __swig_getmethods__["fl"] = _sim2dlong.collectionNLCGV_fl_get
    if _newclass:fl = _swig_property(_sim2dlong.collectionNLCGV_fl_get, _sim2dlong.collectionNLCGV_fl_set)
    __swig_setmethods__["al"] = _sim2dlong.collectionNLCGV_al_set
    __swig_getmethods__["al"] = _sim2dlong.collectionNLCGV_al_get
    if _newclass:al = _swig_property(_sim2dlong.collectionNLCGV_al_get, _sim2dlong.collectionNLCGV_al_set)
    __swig_setmethods__["alpha"] = _sim2dlong.collectionNLCGV_alpha_set
    __swig_getmethods__["alpha"] = _sim2dlong.collectionNLCGV_alpha_get
    if _newclass:alpha = _swig_property(_sim2dlong.collectionNLCGV_alpha_get, _sim2dlong.collectionNLCGV_alpha_set)
    __swig_setmethods__["beta"] = _sim2dlong.collectionNLCGV_beta_set
    __swig_getmethods__["beta"] = _sim2dlong.collectionNLCGV_beta_get
    if _newclass:beta = _swig_property(_sim2dlong.collectionNLCGV_beta_get, _sim2dlong.collectionNLCGV_beta_set)
    __swig_setmethods__["betaused"] = _sim2dlong.collectionNLCGV_betaused_set
    __swig_getmethods__["betaused"] = _sim2dlong.collectionNLCGV_betaused_get
    if _newclass:betaused = _swig_property(_sim2dlong.collectionNLCGV_betaused_get, _sim2dlong.collectionNLCGV_betaused_set)
    __swig_setmethods__["dxsum"] = _sim2dlong.collectionNLCGV_dxsum_set
    __swig_getmethods__["dxsum"] = _sim2dlong.collectionNLCGV_dxsum_get
    if _newclass:dxsum = _swig_property(_sim2dlong.collectionNLCGV_dxsum_get, _sim2dlong.collectionNLCGV_dxsum_set)
    __swig_setmethods__["alphavmax"] = _sim2dlong.collectionNLCGV_alphavmax_set
    __swig_getmethods__["alphavmax"] = _sim2dlong.collectionNLCGV_alphavmax_get
    if _newclass:alphavmax = _swig_property(_sim2dlong.collectionNLCGV_alphavmax_get, _sim2dlong.collectionNLCGV_alphavmax_set)
    __swig_setmethods__["sec"] = _sim2dlong.collectionNLCGV_sec_set
    __swig_getmethods__["sec"] = _sim2dlong.collectionNLCGV_sec_get
    if _newclass:sec = _swig_property(_sim2dlong.collectionNLCGV_sec_get, _sim2dlong.collectionNLCGV_sec_set)
    def stepx(self, *args) -> "void" :
        """stepx(collectionNLCGV self, flt dx)"""
        return _sim2dlong.collectionNLCGV_stepx(self, *args)

    def fdota(self) -> "flt" :
        """fdota(collectionNLCGV self) -> flt"""
        return _sim2dlong.collectionNLCGV_fdota(self)

    def fdotf(self) -> "flt" :
        """fdotf(collectionNLCGV self) -> flt"""
        return _sim2dlong.collectionNLCGV_fdotf(self)

    def fdotv(self) -> "flt" :
        """fdotv(collectionNLCGV self) -> flt"""
        return _sim2dlong.collectionNLCGV_fdotv(self)

    def vdotv(self) -> "flt" :
        """vdotv(collectionNLCGV self) -> flt"""
        return _sim2dlong.collectionNLCGV_vdotv(self)

    def __init__(self, *args): 
        """
        __init__(collectionNLCGV self, Box box, flt const dt, avector groups=std::vector< atomgroup * >(), ivector interactions=std::vector< interaction * >(), 
            tvector trackers=std::vector< statetracker * >(), 
            constraintvector constraints=std::vector< constraint * >(), 
            flt const kmax=1000, flt const secmax=10, flt const seceps=1e-4) -> collectionNLCGV
        __init__(collectionNLCGV self, Box box, flt const dt, avector groups=std::vector< atomgroup * >(), ivector interactions=std::vector< interaction * >(), 
            tvector trackers=std::vector< statetracker * >(), 
            constraintvector constraints=std::vector< constraint * >(), 
            flt const kmax=1000, flt const secmax=10) -> collectionNLCGV
        __init__(collectionNLCGV self, Box box, flt const dt, avector groups=std::vector< atomgroup * >(), ivector interactions=std::vector< interaction * >(), 
            tvector trackers=std::vector< statetracker * >(), 
            constraintvector constraints=std::vector< constraint * >(), 
            flt const kmax=1000) -> collectionNLCGV
        __init__(collectionNLCGV self, Box box, flt const dt, avector groups=std::vector< atomgroup * >(), ivector interactions=std::vector< interaction * >(), 
            tvector trackers=std::vector< statetracker * >(), 
            constraintvector constraints=std::vector< constraint * >()) -> collectionNLCGV
        __init__(collectionNLCGV self, Box box, flt const dt, avector groups=std::vector< atomgroup * >(), ivector interactions=std::vector< interaction * >(), 
            tvector trackers=std::vector< statetracker * >()) -> collectionNLCGV
        __init__(collectionNLCGV self, Box box, flt const dt, avector groups=std::vector< atomgroup * >(), ivector interactions=std::vector< interaction * >()) -> collectionNLCGV
        __init__(collectionNLCGV self, Box box, flt const dt, avector groups=std::vector< atomgroup * >()) -> collectionNLCGV
        __init__(collectionNLCGV self, Box box, flt const dt) -> collectionNLCGV
        """
        this = _sim2dlong.new_collectionNLCGV(*args)
        try: self.this.append(this)
        except: self.this = this
    def pressure(self) -> "flt" :
        """pressure(collectionNLCGV self) -> flt"""
        return _sim2dlong.collectionNLCGV_pressure(self)

    def reset(self) -> "void" :
        """reset(collectionNLCGV self)"""
        return _sim2dlong.collectionNLCGV_reset(self)

    def descend(self) -> "void" :
        """descend(collectionNLCGV self)"""
        return _sim2dlong.collectionNLCGV_descend(self)

    def timestep(self) -> "void" :
        """timestep(collectionNLCGV self)"""
        return _sim2dlong.collectionNLCGV_timestep(self)

    def setdt(self, *args) -> "void" :
        """setdt(collectionNLCGV self, flt newdt)"""
        return _sim2dlong.collectionNLCGV_setdt(self, *args)

    def setamax(self, *args) -> "void" :
        """setamax(collectionNLCGV self, flt a)"""
        return _sim2dlong.collectionNLCGV_setamax(self, *args)

    def setafrac(self, *args) -> "void" :
        """setafrac(collectionNLCGV self, flt a)"""
        return _sim2dlong.collectionNLCGV_setafrac(self, *args)

    def setdxmax(self, *args) -> "void" :
        """setdxmax(collectionNLCGV self, flt d)"""
        return _sim2dlong.collectionNLCGV_setdxmax(self, *args)

    def setstepmax(self, *args) -> "void" :
        """setstepmax(collectionNLCGV self, flt m)"""
        return _sim2dlong.collectionNLCGV_setstepmax(self, *args)

    __swig_destroy__ = _sim2dlong.delete_collectionNLCGV
    __del__ = lambda self : None;
collectionNLCGV_swigregister = _sim2dlong.collectionNLCGV_swigregister
collectionNLCGV_swigregister(collectionNLCGV)


def solveCubic1(*args) -> "flt" :
  """solveCubic1(flt b, flt c, flt d) -> flt"""
  return _sim2dlong.solveCubic1(*args)

def solveCubic(*args) -> "flt" :
  """
    solveCubic(flt a1, flt a2, flt a3, flt closeto=0) -> flt
    solveCubic(flt a1, flt a2, flt a3) -> flt
    """
  return _sim2dlong.solveCubic(*args)
class collectionNoseHoover(collection):
    """Proxy of C++ collectionNoseHoover class"""
    __swig_setmethods__ = {}
    for _s in [collection]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, collectionNoseHoover, name, value)
    __swig_getmethods__ = {}
    for _s in [collection]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, collectionNoseHoover, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(collectionNoseHoover self, Box box, flt const dt, flt const Q, flt const T, avector groups=std::vector< atomgroup * >(), 
            ivector interactions=std::vector< interaction * >(), tvector trackers=std::vector< statetracker * >(), 
            constraintvector constraints=std::vector< constraint * >()) -> collectionNoseHoover
        __init__(collectionNoseHoover self, Box box, flt const dt, flt const Q, flt const T, avector groups=std::vector< atomgroup * >(), 
            ivector interactions=std::vector< interaction * >(), tvector trackers=std::vector< statetracker * >()) -> collectionNoseHoover
        __init__(collectionNoseHoover self, Box box, flt const dt, flt const Q, flt const T, avector groups=std::vector< atomgroup * >(), 
            ivector interactions=std::vector< interaction * >()) -> collectionNoseHoover
        __init__(collectionNoseHoover self, Box box, flt const dt, flt const Q, flt const T, avector groups=std::vector< atomgroup * >()) -> collectionNoseHoover
        __init__(collectionNoseHoover self, Box box, flt const dt, flt const Q, flt const T) -> collectionNoseHoover
        """
        this = _sim2dlong.new_collectionNoseHoover(*args)
        try: self.this.append(this)
        except: self.this = this
    def setdt(self, *args) -> "void" :
        """setdt(collectionNoseHoover self, flt newdt)"""
        return _sim2dlong.collectionNoseHoover_setdt(self, *args)

    def setQ(self, *args) -> "void" :
        """setQ(collectionNoseHoover self, flt newQ)"""
        return _sim2dlong.collectionNoseHoover_setQ(self, *args)

    def resetBath(self) -> "void" :
        """resetBath(collectionNoseHoover self)"""
        return _sim2dlong.collectionNoseHoover_resetBath(self)

    def timestep(self) -> "void" :
        """timestep(collectionNoseHoover self)"""
        return _sim2dlong.collectionNoseHoover_timestep(self)

    def Hamiltonian(self) -> "flt" :
        """Hamiltonian(collectionNoseHoover self) -> flt"""
        return _sim2dlong.collectionNoseHoover_Hamiltonian(self)

    def getxi(self) -> "flt" :
        """getxi(collectionNoseHoover self) -> flt"""
        return _sim2dlong.collectionNoseHoover_getxi(self)

    def getlns(self) -> "flt" :
        """getlns(collectionNoseHoover self) -> flt"""
        return _sim2dlong.collectionNoseHoover_getlns(self)

    __swig_destroy__ = _sim2dlong.delete_collectionNoseHoover
    __del__ = lambda self : None;
collectionNoseHoover_swigregister = _sim2dlong.collectionNoseHoover_swigregister
collectionNoseHoover_swigregister(collectionNoseHoover)

class collectionGaussianT(collection):
    """Proxy of C++ collectionGaussianT class"""
    __swig_setmethods__ = {}
    for _s in [collection]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, collectionGaussianT, name, value)
    __swig_getmethods__ = {}
    for _s in [collection]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, collectionGaussianT, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(collectionGaussianT self, Box box, flt const dt, flt const Q, avector groups=std::vector< atomgroup * >(), 
            ivector interactions=std::vector< interaction * >(), tvector trackers=std::vector< statetracker * >(), 
            constraintvector constraints=std::vector< constraint * >()) -> collectionGaussianT
        __init__(collectionGaussianT self, Box box, flt const dt, flt const Q, avector groups=std::vector< atomgroup * >(), 
            ivector interactions=std::vector< interaction * >(), tvector trackers=std::vector< statetracker * >()) -> collectionGaussianT
        __init__(collectionGaussianT self, Box box, flt const dt, flt const Q, avector groups=std::vector< atomgroup * >(), 
            ivector interactions=std::vector< interaction * >()) -> collectionGaussianT
        __init__(collectionGaussianT self, Box box, flt const dt, flt const Q, avector groups=std::vector< atomgroup * >()) -> collectionGaussianT
        __init__(collectionGaussianT self, Box box, flt const dt, flt const Q) -> collectionGaussianT
        """
        this = _sim2dlong.new_collectionGaussianT(*args)
        try: self.this.append(this)
        except: self.this = this
    def setdt(self, *args) -> "void" :
        """setdt(collectionGaussianT self, flt newdt)"""
        return _sim2dlong.collectionGaussianT_setdt(self, *args)

    def setQ(self, *args) -> "void" :
        """setQ(collectionGaussianT self, flt newQ)"""
        return _sim2dlong.collectionGaussianT_setQ(self, *args)

    def setForces(self, *args) -> "void" :
        """
        setForces(collectionGaussianT self, bool seta=True)
        setForces(collectionGaussianT self)
        setForces(collectionGaussianT self, bool seta, bool setxi)
        """
        return _sim2dlong.collectionGaussianT_setForces(self, *args)

    def timestep(self) -> "void" :
        """timestep(collectionGaussianT self)"""
        return _sim2dlong.collectionGaussianT_timestep(self)

    __swig_destroy__ = _sim2dlong.delete_collectionGaussianT
    __del__ = lambda self : None;
collectionGaussianT_swigregister = _sim2dlong.collectionGaussianT_swigregister
collectionGaussianT_swigregister(collectionGaussianT)

class collectionGear3A(collection):
    """Proxy of C++ collectionGear3A class"""
    __swig_setmethods__ = {}
    for _s in [collection]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, collectionGear3A, name, value)
    __swig_getmethods__ = {}
    for _s in [collection]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, collectionGear3A, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(collectionGear3A self, Box box, flt const dt, avector groups=std::vector< atomgroup * >(), ivector interactions=std::vector< interaction * >(), 
            tvector trackers=std::vector< statetracker * >(), 
            constraintvector constraints=std::vector< constraint * >()) -> collectionGear3A
        __init__(collectionGear3A self, Box box, flt const dt, avector groups=std::vector< atomgroup * >(), ivector interactions=std::vector< interaction * >(), 
            tvector trackers=std::vector< statetracker * >()) -> collectionGear3A
        __init__(collectionGear3A self, Box box, flt const dt, avector groups=std::vector< atomgroup * >(), ivector interactions=std::vector< interaction * >()) -> collectionGear3A
        __init__(collectionGear3A self, Box box, flt const dt, avector groups=std::vector< atomgroup * >()) -> collectionGear3A
        __init__(collectionGear3A self, Box box, flt const dt) -> collectionGear3A
        """
        this = _sim2dlong.new_collectionGear3A(*args)
        try: self.this.append(this)
        except: self.this = this
    def timestep(self) -> "void" :
        """timestep(collectionGear3A self)"""
        return _sim2dlong.collectionGear3A_timestep(self)

    def setdt(self, *args) -> "void" :
        """setdt(collectionGear3A self, flt newdt)"""
        return _sim2dlong.collectionGear3A_setdt(self, *args)

    __swig_destroy__ = _sim2dlong.delete_collectionGear3A
    __del__ = lambda self : None;
collectionGear3A_swigregister = _sim2dlong.collectionGear3A_swigregister
collectionGear3A_swigregister(collectionGear3A)

class collectionGear4A(collection):
    """Proxy of C++ collectionGear4A class"""
    __swig_setmethods__ = {}
    for _s in [collection]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, collectionGear4A, name, value)
    __swig_getmethods__ = {}
    for _s in [collection]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, collectionGear4A, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(collectionGear4A self, Box box, flt const dt, uint ncorrectionsteps, avector groups=std::vector< atomgroup * >(), 
            ivector interactions=std::vector< interaction * >(), tvector trackers=std::vector< statetracker * >(), 
            constraintvector constraints=std::vector< constraint * >()) -> collectionGear4A
        __init__(collectionGear4A self, Box box, flt const dt, uint ncorrectionsteps, avector groups=std::vector< atomgroup * >(), 
            ivector interactions=std::vector< interaction * >(), tvector trackers=std::vector< statetracker * >()) -> collectionGear4A
        __init__(collectionGear4A self, Box box, flt const dt, uint ncorrectionsteps, avector groups=std::vector< atomgroup * >(), 
            ivector interactions=std::vector< interaction * >()) -> collectionGear4A
        __init__(collectionGear4A self, Box box, flt const dt, uint ncorrectionsteps, avector groups=std::vector< atomgroup * >()) -> collectionGear4A
        __init__(collectionGear4A self, Box box, flt const dt, uint ncorrectionsteps) -> collectionGear4A
        __init__(collectionGear4A self, Box box, flt const dt, avector groups=std::vector< atomgroup * >(), ivector interactions=std::vector< interaction * >(), 
            tvector trackers=std::vector< statetracker * >(), 
            constraintvector constraints=std::vector< constraint * >()) -> collectionGear4A
        __init__(collectionGear4A self, Box box, flt const dt, avector groups=std::vector< atomgroup * >(), ivector interactions=std::vector< interaction * >(), 
            tvector trackers=std::vector< statetracker * >()) -> collectionGear4A
        __init__(collectionGear4A self, Box box, flt const dt, avector groups=std::vector< atomgroup * >(), ivector interactions=std::vector< interaction * >()) -> collectionGear4A
        __init__(collectionGear4A self, Box box, flt const dt, avector groups=std::vector< atomgroup * >()) -> collectionGear4A
        __init__(collectionGear4A self, Box box, flt const dt) -> collectionGear4A
        """
        this = _sim2dlong.new_collectionGear4A(*args)
        try: self.this.append(this)
        except: self.this = this
    def timestep(self) -> "void" :
        """timestep(collectionGear4A self)"""
        return _sim2dlong.collectionGear4A_timestep(self)

    def setdt(self, *args) -> "void" :
        """setdt(collectionGear4A self, flt newdt)"""
        return _sim2dlong.collectionGear4A_setdt(self, *args)

    __swig_destroy__ = _sim2dlong.delete_collectionGear4A
    __del__ = lambda self : None;
collectionGear4A_swigregister = _sim2dlong.collectionGear4A_swigregister
collectionGear4A_swigregister(collectionGear4A)

class collectionGear5A(collection):
    """Proxy of C++ collectionGear5A class"""
    __swig_setmethods__ = {}
    for _s in [collection]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, collectionGear5A, name, value)
    __swig_getmethods__ = {}
    for _s in [collection]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, collectionGear5A, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(collectionGear5A self, Box box, flt const dt, uint ncorrectionsteps, avector groups=std::vector< atomgroup * >(), 
            ivector interactions=std::vector< interaction * >(), tvector trackers=std::vector< statetracker * >(), 
            constraintvector constraints=std::vector< constraint * >()) -> collectionGear5A
        __init__(collectionGear5A self, Box box, flt const dt, uint ncorrectionsteps, avector groups=std::vector< atomgroup * >(), 
            ivector interactions=std::vector< interaction * >(), tvector trackers=std::vector< statetracker * >()) -> collectionGear5A
        __init__(collectionGear5A self, Box box, flt const dt, uint ncorrectionsteps, avector groups=std::vector< atomgroup * >(), 
            ivector interactions=std::vector< interaction * >()) -> collectionGear5A
        __init__(collectionGear5A self, Box box, flt const dt, uint ncorrectionsteps, avector groups=std::vector< atomgroup * >()) -> collectionGear5A
        __init__(collectionGear5A self, Box box, flt const dt, uint ncorrectionsteps) -> collectionGear5A
        __init__(collectionGear5A self, Box box, flt const dt, avector groups=std::vector< atomgroup * >(), ivector interactions=std::vector< interaction * >(), 
            tvector trackers=std::vector< statetracker * >(), 
            constraintvector constraints=std::vector< constraint * >()) -> collectionGear5A
        __init__(collectionGear5A self, Box box, flt const dt, avector groups=std::vector< atomgroup * >(), ivector interactions=std::vector< interaction * >(), 
            tvector trackers=std::vector< statetracker * >()) -> collectionGear5A
        __init__(collectionGear5A self, Box box, flt const dt, avector groups=std::vector< atomgroup * >(), ivector interactions=std::vector< interaction * >()) -> collectionGear5A
        __init__(collectionGear5A self, Box box, flt const dt, avector groups=std::vector< atomgroup * >()) -> collectionGear5A
        __init__(collectionGear5A self, Box box, flt const dt) -> collectionGear5A
        """
        this = _sim2dlong.new_collectionGear5A(*args)
        try: self.this.append(this)
        except: self.this = this
    def timestep(self) -> "void" :
        """timestep(collectionGear5A self)"""
        return _sim2dlong.collectionGear5A_timestep(self)

    def setdt(self, *args) -> "void" :
        """setdt(collectionGear5A self, flt newdt)"""
        return _sim2dlong.collectionGear5A_setdt(self, *args)

    __swig_destroy__ = _sim2dlong.delete_collectionGear5A
    __del__ = lambda self : None;
collectionGear5A_swigregister = _sim2dlong.collectionGear5A_swigregister
collectionGear5A_swigregister(collectionGear5A)

class collectionGear6A(collection):
    """Proxy of C++ collectionGear6A class"""
    __swig_setmethods__ = {}
    for _s in [collection]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, collectionGear6A, name, value)
    __swig_getmethods__ = {}
    for _s in [collection]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, collectionGear6A, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(collectionGear6A self, Box box, flt const dt, uint ncorrectionsteps, avector groups=std::vector< atomgroup * >(), 
            ivector interactions=std::vector< interaction * >(), tvector trackers=std::vector< statetracker * >(), 
            constraintvector constraints=std::vector< constraint * >()) -> collectionGear6A
        __init__(collectionGear6A self, Box box, flt const dt, uint ncorrectionsteps, avector groups=std::vector< atomgroup * >(), 
            ivector interactions=std::vector< interaction * >(), tvector trackers=std::vector< statetracker * >()) -> collectionGear6A
        __init__(collectionGear6A self, Box box, flt const dt, uint ncorrectionsteps, avector groups=std::vector< atomgroup * >(), 
            ivector interactions=std::vector< interaction * >()) -> collectionGear6A
        __init__(collectionGear6A self, Box box, flt const dt, uint ncorrectionsteps, avector groups=std::vector< atomgroup * >()) -> collectionGear6A
        __init__(collectionGear6A self, Box box, flt const dt, uint ncorrectionsteps) -> collectionGear6A
        __init__(collectionGear6A self, Box box, flt const dt, avector groups=std::vector< atomgroup * >(), ivector interactions=std::vector< interaction * >(), 
            tvector trackers=std::vector< statetracker * >(), 
            constraintvector constraints=std::vector< constraint * >()) -> collectionGear6A
        __init__(collectionGear6A self, Box box, flt const dt, avector groups=std::vector< atomgroup * >(), ivector interactions=std::vector< interaction * >(), 
            tvector trackers=std::vector< statetracker * >()) -> collectionGear6A
        __init__(collectionGear6A self, Box box, flt const dt, avector groups=std::vector< atomgroup * >(), ivector interactions=std::vector< interaction * >()) -> collectionGear6A
        __init__(collectionGear6A self, Box box, flt const dt, avector groups=std::vector< atomgroup * >()) -> collectionGear6A
        __init__(collectionGear6A self, Box box, flt const dt) -> collectionGear6A
        """
        this = _sim2dlong.new_collectionGear6A(*args)
        try: self.this.append(this)
        except: self.this = this
    def timestep(self) -> "void" :
        """timestep(collectionGear6A self)"""
        return _sim2dlong.collectionGear6A_timestep(self)

    def setdt(self, *args) -> "void" :
        """setdt(collectionGear6A self, flt newdt)"""
        return _sim2dlong.collectionGear6A_setdt(self, *args)

    __swig_destroy__ = _sim2dlong.delete_collectionGear6A
    __del__ = lambda self : None;
collectionGear6A_swigregister = _sim2dlong.collectionGear6A_swigregister
collectionGear6A_swigregister(collectionGear6A)

class atomRK4(atom):
    """Proxy of C++ atomRK4 class"""
    __swig_setmethods__ = {}
    for _s in [atom]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, atomRK4, name, value)
    __swig_getmethods__ = {}
    for _s in [atom]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, atomRK4, name)
    __repr__ = _swig_repr
    __swig_setmethods__["Kxa"] = _sim2dlong.atomRK4_Kxa_set
    __swig_getmethods__["Kxa"] = _sim2dlong.atomRK4_Kxa_get
    if _newclass:Kxa = _swig_property(_sim2dlong.atomRK4_Kxa_get, _sim2dlong.atomRK4_Kxa_set)
    __swig_setmethods__["Kxb"] = _sim2dlong.atomRK4_Kxb_set
    __swig_getmethods__["Kxb"] = _sim2dlong.atomRK4_Kxb_get
    if _newclass:Kxb = _swig_property(_sim2dlong.atomRK4_Kxb_get, _sim2dlong.atomRK4_Kxb_set)
    __swig_setmethods__["Kxc"] = _sim2dlong.atomRK4_Kxc_set
    __swig_getmethods__["Kxc"] = _sim2dlong.atomRK4_Kxc_get
    if _newclass:Kxc = _swig_property(_sim2dlong.atomRK4_Kxc_get, _sim2dlong.atomRK4_Kxc_set)
    __swig_setmethods__["Kxd"] = _sim2dlong.atomRK4_Kxd_set
    __swig_getmethods__["Kxd"] = _sim2dlong.atomRK4_Kxd_get
    if _newclass:Kxd = _swig_property(_sim2dlong.atomRK4_Kxd_get, _sim2dlong.atomRK4_Kxd_set)
    __swig_setmethods__["Kva"] = _sim2dlong.atomRK4_Kva_set
    __swig_getmethods__["Kva"] = _sim2dlong.atomRK4_Kva_get
    if _newclass:Kva = _swig_property(_sim2dlong.atomRK4_Kva_get, _sim2dlong.atomRK4_Kva_set)
    __swig_setmethods__["Kvb"] = _sim2dlong.atomRK4_Kvb_set
    __swig_getmethods__["Kvb"] = _sim2dlong.atomRK4_Kvb_get
    if _newclass:Kvb = _swig_property(_sim2dlong.atomRK4_Kvb_get, _sim2dlong.atomRK4_Kvb_set)
    __swig_setmethods__["Kvc"] = _sim2dlong.atomRK4_Kvc_set
    __swig_getmethods__["Kvc"] = _sim2dlong.atomRK4_Kvc_get
    if _newclass:Kvc = _swig_property(_sim2dlong.atomRK4_Kvc_get, _sim2dlong.atomRK4_Kvc_set)
    __swig_setmethods__["Kvd"] = _sim2dlong.atomRK4_Kvd_set
    __swig_getmethods__["Kvd"] = _sim2dlong.atomRK4_Kvd_get
    if _newclass:Kvd = _swig_property(_sim2dlong.atomRK4_Kvd_get, _sim2dlong.atomRK4_Kvd_set)
    def __init__(self): 
        """__init__(atomRK4 self) -> atomRK4"""
        this = _sim2dlong.new_atomRK4()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _sim2dlong.delete_atomRK4
    __del__ = lambda self : None;
atomRK4_swigregister = _sim2dlong.atomRK4_swigregister
atomRK4_swigregister(atomRK4)

class atomvecRK4(atomgroup):
    """Proxy of C++ atomvecRK4 class"""
    __swig_setmethods__ = {}
    for _s in [atomgroup]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, atomvecRK4, name, value)
    __swig_getmethods__ = {}
    for _s in [atomgroup]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, atomvecRK4, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(atomvecRK4 self, ldvector masses) -> atomvecRK4
        __init__(atomvecRK4 self, atomgroup g) -> atomvecRK4
        """
        this = _sim2dlong.new_atomvecRK4(*args)
        try: self.this.append(this)
        except: self.this = this
    def get(self, *args) -> "atom *" :
        """get(atomvecRK4 self, cuint n) -> atom"""
        return _sim2dlong.atomvecRK4_get(self, *args)

    def getRK4(self, *args) -> "atomRK4 *" :
        """getRK4(atomvecRK4 self, cuint n) -> atomRK4"""
        return _sim2dlong.atomvecRK4_getRK4(self, *args)

    def get_id(self, *args) -> "atomid" :
        """
        get_id(atomvecRK4 self, atom a) -> atomid
        get_id(atomvecRK4 self, uint n) -> atomid
        """
        return _sim2dlong.atomvecRK4_get_id(self, *args)

    def size(self) -> "uint" :
        """size(atomvecRK4 self) -> uint"""
        return _sim2dlong.atomvecRK4_size(self)

    __swig_destroy__ = _sim2dlong.delete_atomvecRK4
    __del__ = lambda self : None;
atomvecRK4_swigregister = _sim2dlong.atomvecRK4_swigregister
atomvecRK4_swigregister(atomvecRK4)

class collectionRK4(collection):
    """Proxy of C++ collectionRK4 class"""
    __swig_setmethods__ = {}
    for _s in [collection]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, collectionRK4, name, value)
    __swig_getmethods__ = {}
    for _s in [collection]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, collectionRK4, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(collectionRK4 self, Box box, flt const dt, aRK4vector rgroups=std::vector< atomvecRK4 * >(), ivector interactions=std::vector< interaction * >(), 
            tvector trackers=std::vector< statetracker * >(), 
            constraintvector constraints=std::vector< constraint * >()) -> collectionRK4
        __init__(collectionRK4 self, Box box, flt const dt, aRK4vector rgroups=std::vector< atomvecRK4 * >(), ivector interactions=std::vector< interaction * >(), 
            tvector trackers=std::vector< statetracker * >()) -> collectionRK4
        __init__(collectionRK4 self, Box box, flt const dt, aRK4vector rgroups=std::vector< atomvecRK4 * >(), ivector interactions=std::vector< interaction * >()) -> collectionRK4
        __init__(collectionRK4 self, Box box, flt const dt, aRK4vector rgroups=std::vector< atomvecRK4 * >()) -> collectionRK4
        __init__(collectionRK4 self, Box box, flt const dt) -> collectionRK4
        """
        this = _sim2dlong.new_collectionRK4(*args)
        try: self.this.append(this)
        except: self.this = this
    def timestep(self) -> "void" :
        """timestep(collectionRK4 self)"""
        return _sim2dlong.collectionRK4_timestep(self)

    def setdt(self, *args) -> "void" :
        """setdt(collectionRK4 self, flt newdt)"""
        return _sim2dlong.collectionRK4_setdt(self, *args)

    __swig_destroy__ = _sim2dlong.delete_collectionRK4
    __del__ = lambda self : None;
collectionRK4_swigregister = _sim2dlong.collectionRK4_swigregister
collectionRK4_swigregister(collectionRK4)

class collectionGear4NPH(collection):
    """Proxy of C++ collectionGear4NPH class"""
    __swig_setmethods__ = {}
    for _s in [collection]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, collectionGear4NPH, name, value)
    __swig_getmethods__ = {}
    for _s in [collection]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, collectionGear4NPH, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(collectionGear4NPH self, OriginBox box, flt const dt, flt const P, flt const Q, uint ncorrectionsteps, avector groups=std::vector< atomgroup * >(), 
            ivector interactions=std::vector< interaction * >(), 
            tvector trackers=std::vector< statetracker * >(), constraintvector constraints=std::vector< constraint * >()) -> collectionGear4NPH
        __init__(collectionGear4NPH self, OriginBox box, flt const dt, flt const P, flt const Q, uint ncorrectionsteps, avector groups=std::vector< atomgroup * >(), 
            ivector interactions=std::vector< interaction * >(), 
            tvector trackers=std::vector< statetracker * >()) -> collectionGear4NPH
        __init__(collectionGear4NPH self, OriginBox box, flt const dt, flt const P, flt const Q, uint ncorrectionsteps, avector groups=std::vector< atomgroup * >(), 
            ivector interactions=std::vector< interaction * >()) -> collectionGear4NPH
        __init__(collectionGear4NPH self, OriginBox box, flt const dt, flt const P, flt const Q, uint ncorrectionsteps, avector groups=std::vector< atomgroup * >()) -> collectionGear4NPH
        __init__(collectionGear4NPH self, OriginBox box, flt const dt, flt const P, flt const Q, uint ncorrectionsteps) -> collectionGear4NPH
        __init__(collectionGear4NPH self, OriginBox box, flt const dt, flt const P, flt const Q, avector groups=std::vector< atomgroup * >(), 
            ivector interactions=std::vector< interaction * >(), tvector trackers=std::vector< statetracker * >(), 
            constraintvector constraints=std::vector< constraint * >()) -> collectionGear4NPH
        __init__(collectionGear4NPH self, OriginBox box, flt const dt, flt const P, flt const Q, avector groups=std::vector< atomgroup * >(), 
            ivector interactions=std::vector< interaction * >(), tvector trackers=std::vector< statetracker * >()) -> collectionGear4NPH
        __init__(collectionGear4NPH self, OriginBox box, flt const dt, flt const P, flt const Q, avector groups=std::vector< atomgroup * >(), 
            ivector interactions=std::vector< interaction * >()) -> collectionGear4NPH
        __init__(collectionGear4NPH self, OriginBox box, flt const dt, flt const P, flt const Q, avector groups=std::vector< atomgroup * >()) -> collectionGear4NPH
        __init__(collectionGear4NPH self, OriginBox box, flt const dt, flt const P, flt const Q) -> collectionGear4NPH
        """
        this = _sim2dlong.new_collectionGear4NPH(*args)
        try: self.this.append(this)
        except: self.this = this
    def timestep(self) -> "void" :
        """timestep(collectionGear4NPH self)"""
        return _sim2dlong.collectionGear4NPH_timestep(self)

    def kinetic(self) -> "flt" :
        """kinetic(collectionGear4NPH self) -> flt"""
        return _sim2dlong.collectionGear4NPH_kinetic(self)

    def temp(self, minuscomv : 'bool'=True) -> "flt" :
        """
        temp(collectionGear4NPH self, bool minuscomv=True) -> flt
        temp(collectionGear4NPH self) -> flt
        """
        return _sim2dlong.collectionGear4NPH_temp(self, minuscomv)

    def Hamiltonian(self) -> "flt" :
        """Hamiltonian(collectionGear4NPH self) -> flt"""
        return _sim2dlong.collectionGear4NPH_Hamiltonian(self)

    def getdV(self) -> "flt" :
        """getdV(collectionGear4NPH self) -> flt"""
        return _sim2dlong.collectionGear4NPH_getdV(self)

    def getddV(self) -> "flt" :
        """getddV(collectionGear4NPH self) -> flt"""
        return _sim2dlong.collectionGear4NPH_getddV(self)

    def setdt(self, *args) -> "void" :
        """setdt(collectionGear4NPH self, flt newdt)"""
        return _sim2dlong.collectionGear4NPH_setdt(self, *args)

    __swig_destroy__ = _sim2dlong.delete_collectionGear4NPH
    __del__ = lambda self : None;
collectionGear4NPH_swigregister = _sim2dlong.collectionGear4NPH_swigregister
collectionGear4NPH_swigregister(collectionGear4NPH)

class xrpsummer(fpairxFunct):
    """Proxy of C++ xrpsummer class"""
    __swig_setmethods__ = {}
    for _s in [fpairxFunct]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, xrpsummer, name, value)
    __swig_getmethods__ = {}
    for _s in [fpairxFunct]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, xrpsummer, name)
    __repr__ = _swig_repr
    __swig_setmethods__["xsum"] = _sim2dlong.xrpsummer_xsum_set
    __swig_getmethods__["xsum"] = _sim2dlong.xrpsummer_xsum_get
    if _newclass:xsum = _swig_property(_sim2dlong.xrpsummer_xsum_get, _sim2dlong.xrpsummer_xsum_set)
    __swig_setmethods__["rpxsum"] = _sim2dlong.xrpsummer_rpxsum_set
    __swig_getmethods__["rpxsum"] = _sim2dlong.xrpsummer_rpxsum_get
    if _newclass:rpxsum = _swig_property(_sim2dlong.xrpsummer_rpxsum_get, _sim2dlong.xrpsummer_rpxsum_set)
    __swig_setmethods__["vfsum"] = _sim2dlong.xrpsummer_vfsum_set
    __swig_getmethods__["vfsum"] = _sim2dlong.xrpsummer_vfsum_get
    if _newclass:vfsum = _swig_property(_sim2dlong.xrpsummer_vfsum_get, _sim2dlong.xrpsummer_vfsum_set)
    __swig_setmethods__["rfsum"] = _sim2dlong.xrpsummer_rfsum_set
    __swig_getmethods__["rfsum"] = _sim2dlong.xrpsummer_rfsum_get
    if _newclass:rfsum = _swig_property(_sim2dlong.xrpsummer_rfsum_get, _sim2dlong.xrpsummer_rfsum_set)
    def __init__(self, *args): 
        """__init__(xrpsummer self, Box box) -> xrpsummer"""
        this = _sim2dlong.new_xrpsummer(*args)
        try: self.this.append(this)
        except: self.this = this
    def run(self, *args) -> "void" :
        """run(xrpsummer self, forcepairx arg2)"""
        return _sim2dlong.xrpsummer_run(self, *args)

    def reset(self) -> "void" :
        """reset(xrpsummer self)"""
        return _sim2dlong.xrpsummer_reset(self)

    __swig_destroy__ = _sim2dlong.delete_xrpsummer
    __del__ = lambda self : None;
xrpsummer_swigregister = _sim2dlong.xrpsummer_swigregister
xrpsummer_swigregister(xrpsummer)

class collectionGear4NPT(collection):
    """Proxy of C++ collectionGear4NPT class"""
    __swig_setmethods__ = {}
    for _s in [collection]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, collectionGear4NPT, name, value)
    __swig_getmethods__ = {}
    for _s in [collection]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, collectionGear4NPT, name)
    __repr__ = _swig_repr
    __swig_setmethods__["dt"] = _sim2dlong.collectionGear4NPT_dt_set
    __swig_getmethods__["dt"] = _sim2dlong.collectionGear4NPT_dt_get
    if _newclass:dt = _swig_property(_sim2dlong.collectionGear4NPT_dt_get, _sim2dlong.collectionGear4NPT_dt_set)
    __swig_setmethods__["xrpsums"] = _sim2dlong.collectionGear4NPT_xrpsums_set
    __swig_getmethods__["xrpsums"] = _sim2dlong.collectionGear4NPT_xrpsums_get
    if _newclass:xrpsums = _swig_property(_sim2dlong.collectionGear4NPT_xrpsums_get, _sim2dlong.collectionGear4NPT_xrpsums_set)
    __swig_setmethods__["ncorrec"] = _sim2dlong.collectionGear4NPT_ncorrec_set
    __swig_getmethods__["ncorrec"] = _sim2dlong.collectionGear4NPT_ncorrec_get
    if _newclass:ncorrec = _swig_property(_sim2dlong.collectionGear4NPT_ncorrec_get, _sim2dlong.collectionGear4NPT_ncorrec_set)
    __swig_setmethods__["V1"] = _sim2dlong.collectionGear4NPT_V1_set
    __swig_getmethods__["V1"] = _sim2dlong.collectionGear4NPT_V1_get
    if _newclass:V1 = _swig_property(_sim2dlong.collectionGear4NPT_V1_get, _sim2dlong.collectionGear4NPT_V1_set)
    __swig_setmethods__["V2"] = _sim2dlong.collectionGear4NPT_V2_set
    __swig_getmethods__["V2"] = _sim2dlong.collectionGear4NPT_V2_get
    if _newclass:V2 = _swig_property(_sim2dlong.collectionGear4NPT_V2_get, _sim2dlong.collectionGear4NPT_V2_set)
    __swig_setmethods__["V3"] = _sim2dlong.collectionGear4NPT_V3_set
    __swig_getmethods__["V3"] = _sim2dlong.collectionGear4NPT_V3_get
    if _newclass:V3 = _swig_property(_sim2dlong.collectionGear4NPT_V3_get, _sim2dlong.collectionGear4NPT_V3_set)
    __swig_setmethods__["chi"] = _sim2dlong.collectionGear4NPT_chi_set
    __swig_getmethods__["chi"] = _sim2dlong.collectionGear4NPT_chi_get
    if _newclass:chi = _swig_property(_sim2dlong.collectionGear4NPT_chi_get, _sim2dlong.collectionGear4NPT_chi_set)
    __swig_setmethods__["chixi"] = _sim2dlong.collectionGear4NPT_chixi_set
    __swig_getmethods__["chixi"] = _sim2dlong.collectionGear4NPT_chixi_get
    if _newclass:chixi = _swig_property(_sim2dlong.collectionGear4NPT_chixi_get, _sim2dlong.collectionGear4NPT_chixi_set)
    __swig_setmethods__["xs1"] = _sim2dlong.collectionGear4NPT_xs1_set
    __swig_getmethods__["xs1"] = _sim2dlong.collectionGear4NPT_xs1_get
    if _newclass:xs1 = _swig_property(_sim2dlong.collectionGear4NPT_xs1_get, _sim2dlong.collectionGear4NPT_xs1_set)
    __swig_setmethods__["xs2"] = _sim2dlong.collectionGear4NPT_xs2_set
    __swig_getmethods__["xs2"] = _sim2dlong.collectionGear4NPT_xs2_get
    if _newclass:xs2 = _swig_property(_sim2dlong.collectionGear4NPT_xs2_get, _sim2dlong.collectionGear4NPT_xs2_set)
    __swig_setmethods__["xs3"] = _sim2dlong.collectionGear4NPT_xs3_set
    __swig_getmethods__["xs3"] = _sim2dlong.collectionGear4NPT_xs3_get
    if _newclass:xs3 = _swig_property(_sim2dlong.collectionGear4NPT_xs3_get, _sim2dlong.collectionGear4NPT_xs3_set)
    __swig_setmethods__["vs2"] = _sim2dlong.collectionGear4NPT_vs2_set
    __swig_getmethods__["vs2"] = _sim2dlong.collectionGear4NPT_vs2_get
    if _newclass:vs2 = _swig_property(_sim2dlong.collectionGear4NPT_vs2_get, _sim2dlong.collectionGear4NPT_vs2_set)
    __swig_setmethods__["vs3"] = _sim2dlong.collectionGear4NPT_vs3_set
    __swig_getmethods__["vs3"] = _sim2dlong.collectionGear4NPT_vs3_get
    if _newclass:vs3 = _swig_property(_sim2dlong.collectionGear4NPT_vs3_get, _sim2dlong.collectionGear4NPT_vs3_set)
    def resetbs(self) -> "void" :
        """resetbs(collectionGear4NPT self)"""
        return _sim2dlong.collectionGear4NPT_resetbs(self)

    def tointerpair(*args) -> "std::vector< interaction * >" :
        """tointerpair(ifxvector arg1) -> ivector"""
        return _sim2dlong.collectionGear4NPT_tointerpair(*args)

    if _newclass:tointerpair = staticmethod(tointerpair)
    __swig_getmethods__["tointerpair"] = lambda x: tointerpair
    def __init__(self, *args): 
        """
        __init__(collectionGear4NPT self, OriginBox box, flt const dt, uint ncorrectionsteps, avector groups=std::vector< atomgroup * >(), 
            ifxvector interactions=std::vector< interactionpairsx * >(), 
            tvector trackers=std::vector< statetracker * >(), constraintvector constraints=std::vector< constraint * >()) -> collectionGear4NPT
        __init__(collectionGear4NPT self, OriginBox box, flt const dt, uint ncorrectionsteps, avector groups=std::vector< atomgroup * >(), 
            ifxvector interactions=std::vector< interactionpairsx * >(), 
            tvector trackers=std::vector< statetracker * >()) -> collectionGear4NPT
        __init__(collectionGear4NPT self, OriginBox box, flt const dt, uint ncorrectionsteps, avector groups=std::vector< atomgroup * >(), 
            ifxvector interactions=std::vector< interactionpairsx * >()) -> collectionGear4NPT
        __init__(collectionGear4NPT self, OriginBox box, flt const dt, uint ncorrectionsteps, avector groups=std::vector< atomgroup * >()) -> collectionGear4NPT
        __init__(collectionGear4NPT self, OriginBox box, flt const dt, uint ncorrectionsteps) -> collectionGear4NPT
        __init__(collectionGear4NPT self, OriginBox box, flt const dt, avector groups=std::vector< atomgroup * >(), ifxvector interactions=std::vector< interactionpairsx * >(), 
            tvector trackers=std::vector< statetracker * >(), 
            constraintvector constraints=std::vector< constraint * >()) -> collectionGear4NPT
        __init__(collectionGear4NPT self, OriginBox box, flt const dt, avector groups=std::vector< atomgroup * >(), ifxvector interactions=std::vector< interactionpairsx * >(), 
            tvector trackers=std::vector< statetracker * >()) -> collectionGear4NPT
        __init__(collectionGear4NPT self, OriginBox box, flt const dt, avector groups=std::vector< atomgroup * >(), ifxvector interactions=std::vector< interactionpairsx * >()) -> collectionGear4NPT
        __init__(collectionGear4NPT self, OriginBox box, flt const dt, avector groups=std::vector< atomgroup * >()) -> collectionGear4NPT
        __init__(collectionGear4NPT self, OriginBox box, flt const dt) -> collectionGear4NPT
        """
        this = _sim2dlong.new_collectionGear4NPT(*args)
        try: self.this.append(this)
        except: self.this = this
    def setForces(self, seta : 'bool'=True) -> "void" :
        """
        setForces(collectionGear4NPT self, bool seta=True)
        setForces(collectionGear4NPT self)
        """
        return _sim2dlong.collectionGear4NPT_setForces(self, seta)

    def timestep(self) -> "void" :
        """timestep(collectionGear4NPT self)"""
        return _sim2dlong.collectionGear4NPT_timestep(self)

    __swig_destroy__ = _sim2dlong.delete_collectionGear4NPT
    __del__ = lambda self : None;
collectionGear4NPT_swigregister = _sim2dlong.collectionGear4NPT_swigregister
collectionGear4NPT_swigregister(collectionGear4NPT)

def collectionGear4NPT_tointerpair(*args) -> "std::vector< interaction * >" :
  """collectionGear4NPT_tointerpair(ifxvector arg1) -> ivector"""
  return _sim2dlong.collectionGear4NPT_tointerpair(*args)

class collectionVerletNPT(collection):
    """Proxy of C++ collectionVerletNPT class"""
    __swig_setmethods__ = {}
    for _s in [collection]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, collectionVerletNPT, name, value)
    __swig_getmethods__ = {}
    for _s in [collection]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, collectionVerletNPT, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(collectionVerletNPT self, OriginBox box, flt const dt, flt const P, flt const QP, flt const T, flt const QT, 
            avector groups=std::vector< atomgroup * >(), ivector interactions=std::vector< interaction * >(), 
            tvector trackers=std::vector< statetracker * >(), 
            constraintvector constraints=std::vector< constraint * >()) -> collectionVerletNPT
        __init__(collectionVerletNPT self, OriginBox box, flt const dt, flt const P, flt const QP, flt const T, flt const QT, 
            avector groups=std::vector< atomgroup * >(), ivector interactions=std::vector< interaction * >(), 
            tvector trackers=std::vector< statetracker * >()) -> collectionVerletNPT
        __init__(collectionVerletNPT self, OriginBox box, flt const dt, flt const P, flt const QP, flt const T, flt const QT, 
            avector groups=std::vector< atomgroup * >(), ivector interactions=std::vector< interaction * >()) -> collectionVerletNPT
        __init__(collectionVerletNPT self, OriginBox box, flt const dt, flt const P, flt const QP, flt const T, flt const QT, 
            avector groups=std::vector< atomgroup * >()) -> collectionVerletNPT
        __init__(collectionVerletNPT self, OriginBox box, flt const dt, flt const P, flt const QP, flt const T, flt const QT) -> collectionVerletNPT
        """
        this = _sim2dlong.new_collectionVerletNPT(*args)
        try: self.this.append(this)
        except: self.this = this
    def timestep(self) -> "void" :
        """timestep(collectionVerletNPT self)"""
        return _sim2dlong.collectionVerletNPT_timestep(self)

    def setdt(self, *args) -> "void" :
        """setdt(collectionVerletNPT self, flt newdt)"""
        return _sim2dlong.collectionVerletNPT_setdt(self, *args)

    def resetcomv(self) -> "void" :
        """resetcomv(collectionVerletNPT self)"""
        return _sim2dlong.collectionVerletNPT_resetcomv(self)

    def resetL(self) -> "void" :
        """resetL(collectionVerletNPT self)"""
        return _sim2dlong.collectionVerletNPT_resetL(self)

    def scaleVs(self, *args) -> "void" :
        """scaleVs(collectionVerletNPT self, flt scaleby)"""
        return _sim2dlong.collectionVerletNPT_scaleVs(self, *args)

    def scaleVelocitiesT(self, *args) -> "void" :
        """scaleVelocitiesT(collectionVerletNPT self, flt T)"""
        return _sim2dlong.collectionVerletNPT_scaleVelocitiesT(self, *args)

    def scaleVelocitiesE(self, *args) -> "void" :
        """scaleVelocitiesE(collectionVerletNPT self, flt E)"""
        return _sim2dlong.collectionVerletNPT_scaleVelocitiesE(self, *args)

    def geteta(self) -> "flt" :
        """geteta(collectionVerletNPT self) -> flt"""
        return _sim2dlong.collectionVerletNPT_geteta(self)

    def getxidot(self) -> "flt" :
        """getxidot(collectionVerletNPT self) -> flt"""
        return _sim2dlong.collectionVerletNPT_getxidot(self)

    def getP(self) -> "flt" :
        """getP(collectionVerletNPT self) -> flt"""
        return _sim2dlong.collectionVerletNPT_getP(self)

    def getvhalf(self, *args) -> "Vec" :
        """getvhalf(collectionVerletNPT self, uint n) -> VecL"""
        return _sim2dlong.collectionVerletNPT_getvhalf(self, *args)

    __swig_destroy__ = _sim2dlong.delete_collectionVerletNPT
    __del__ = lambda self : None;
collectionVerletNPT_swigregister = _sim2dlong.collectionVerletNPT_swigregister
collectionVerletNPT_swigregister(collectionVerletNPT)

# This file is compatible with both classic and new-style classes.


