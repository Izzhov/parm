from __future__ import print_function

import argparse, imp
from simw import *
import gzip, logging

def parseargs():
    conf_parser = argparse.ArgumentParser(
        description=__doc__,
        formatter_class=argparse.RawDescriptionHelpFormatter,
        # Turn off help, so we print all options in response to -h
        add_help=False
        )
    conf_parser.add_argument("-c", "--conf_file",
                        help="Specify config file", metavar="FILE")
    args, remaining_argv = conf_parser.parse_known_args()

    def dir_dict(obj):
        return dict([(k,getattr(obj, k)) 
                for k in dir(obj) if not k.startswith('_')])

    # load defaults
    #conf_dict = dir_dict(cgdefaults)
    conf_dict = {}

    # load config file, if specified
    if args.conf_file:
        conf_module = imp.load_source('conf_module', args.conf_file)
        conf_dict.update(dir_dict(conf_module))

    parser = argparse.ArgumentParser(
            # Inherit options from config_parser
            parents=[conf_parser]
            )
    parser.add_option('-T', '--temperature', type=float, dest='temp', default=1.0)
    parser.add_option('-D', '--damping', type=float, default=.001)
    parser.add_option('-t', '--time', type=float, default=1.0)
    parser.add_option('-d', '--dt', type=float, default=.01)
    parser.add_option('--rampsteps', type=int, default=0)
    parser.add_option('--rampdamp', type=float, default=.5)
    parser.add_option('--rampdt', type=float, default=None)
    parser.add_option('-S', '--showsteps', type=int, dest='showsteps', default=0)
    parser.add_option('-Z', '--showsize', type=float, dest='showsize', default=.25)
    parser.add_option('-N', '--numres', type=int, dest='numres', default=0)
    parser.add_option('-s', '--startfile', dest='startfile', default=None)
    parser.add_option('-x', '--xyzfile', dest='xyzfile', 
                default=(mydir + 'test/tau-CG-T{T}.xyz'))
    parser.add_option('-g', '--statfile', dest='statfile', 
                default=None)
    parser.add_option('-C', '--continue', dest='cont', action='store_true')
    parser.add_option('-K', '--chargek', dest='chargek', type=float, 
                default=1.0)
    parser.add_option('--seed', dest='seed', action='store_false',
                default=True)
    parser.add_option('--startdt', type=float, default=1e-8)
    parser.add_option('--startsteps', type=int, default=0)
    parser.add_option('--startdamp', type=float, default=20000.0)
    parser.add_option('--startfactor', type=float, default=2.0)

    parser.set_defaults(**conf_dict)
    return parser.parse_args(remaining_argv)

def make_residues(opts):
    residues = atomvec(opts.masses)
    dx = cos(opts.bond_angle)
    dy = sin(opts.bond_angle)
    for n,r in enumerate(residues):
       r.x = n * dx
       r.y = dy * (-1**n)
       r.z = 0 
    logging.info('Made %d residues in a line, with total mass %.2f.' 
                        % (len(residues), sum(opts.masses)))
    return residues

def make_interactions(residues, args):
    interactions, trackers = dict(), dict()
    
    ### Bond Lengths
    bond_pairs = bondpairs()
    for r1, r2 in zip(residues[:-1], residues[1:]):
        bond_pairs.add(args.bond_length_k, args.bond_length, r1, r2)
    interactions['bonds'] = bond_pairs
    
    ### Bond Angles
    bond_angles = angletriples()
    for r1,r2,r3 in zip(residues[:-2], residues[1:-1], residues[2:]):
        bond_angles.add(args.bond_angle_k, args.bond_angle, r1, r2, r3)
    interactions['angles'] = bond_angles
    
    ### Dihedrals
    dihedral = dihedrals()
    for r1,r2,r3,r4, d in zip(residues[:-3], residues[1:-2], residues[2:-1], 
                    residues[3:], consts):
        cos_consts, sin_consts = consts
        dihedral.add(fvector(cos_consts), fvector(sin_consts), r1, r2, r3, r4)
    
    ### Lennard-Jones
    innerradius = max(args.LJ_sigmas) * args.LJ_cutoff
    outerradius = innerradius * args.neighbor_cutoff
    LJneighbors = neighborlist(innerradius, outerradius)
    LJ = LJgroup(LJneighbors)
    for n, r, s, e in zip(range(len(residues)), residues, 
                    args.LJ_sigmas, args.LJ_espilons):
        LJ.add(LJatom(e, s, r))
            # ignore bonded residues
            if n >= 1: LJ.ignore(r, residues[n-1])
            # ignore residues with an angle between
            if n >= 2: LJ.ignore(r, residues[n-2])
    
    trackers['LJ_neighbors'] = LJneighbors
    interactions['LJ'] = LJ
    
    ### Electrostatics
    if (hasattr(args, 'charges') and any(c != 0 for c in args.charges)
            and args.charge_k > 0):
        charges = Charges(args.charge_screen, args.charge_k)
        for n, r, c in zip(range(len(residues)), residues, args.charges):
            if c == 0: continue
            charges.add(r1, c)
            # ignore bonded residues
            if n >= 1 and args.charges[n-1] != 0:
                charges.ignore(r, residues[n-1])
            # ignore residues with an angle between
            if n >= 2 and args.charges[n-2] != 0:
                charges.ignore(r, residues[n-2])
            # We don't ignore residues connected by a dihedral
        interactions['charges'] = charges
    
    ### Hydrophobicity
    if (hasattr(args, 'hydrophobicities') and any(H != 0 for H in args.hydrophobicities)
            and args.hphob_k > 0):
        innerradius = args.hphob_sigma * args.hphob_cutoff
        outerradius = innerradius * args.neighbor_cutoff
        neighbors = neighborlist(innerradius, outerradius)
        Hphob = Hydrophobicity(neighbors)
        
        trackers['hphob_neighbors'] = neighbors
        interactions['hydrophobicity'] = charges
    
    return (interactions, trackers)
    
def run(collec, interactions, trackers, steps, printsteps=1000):
    valtracker = defaultdict(list)
    t = 0
    

class distWriter:
    def __init__(self, fname, residues, collec, rijlist, Rg=True):
        self.residues = residues
        self.rijlist = rijlist
        self._write_Rg = Rg
        self.fname = fname
        self.collec = collec
        self.headers_written = False
    
    def write_headers(self):
        headers = (['time'] + (['Rg'] if self._write_Rg else []) + 
            ['%d_%d' % rij for rij in self.rijlist])
        with gzip.open(self.fname, 'w') as f:
            print(*headers, sep='\t', file=f)
    
    def update(self, t):
        if not self.headers_written:
            self.write_headers()
            self.headers_written = True
        
        rijs = [(self.residues[i].x - self.residues[j].x).mag() 
                        for i,j in self.rijlist]
        
        stats = ([t] + ([collec.gyradius()] if self._write_Rg else []) +
                rijs)
        
        with gzip.open(self.fname, 'a') as f:
            print(*stats, sep='\t', file=f)

def printlist(lst, name):
    mean = float(np.mean(lst,0))
    std = np.std(lst)
    sovm = 100*std / mean if mean > 0 else float('nan')
    last = float(lst[-1])
    lstd = 100*(last - mean) / std if std > 0 else float('nan')
    print("{name:10s}={mean:8.2f}, Ïƒ={std:8.3f} ({sovm:7.3g}%) [{last:8.2f} ({lstd:7.3g}%)]".format(**locals()))

if __name__ == '__main__':
    args = parseargs()
    residues = make_residues(args)
    interactions, trackers = make_interactions(residues, args)
    intervec = ivector(list(interactions.values()))
    trackvec = tvector(list(trackers.values())
    collec = collectionSol(args.dt, args.damping, args.temp, 
                    residues, intervec, trackvec)
    collec.interactions = interactions
    
    if opts.seed: collec.seed()
    else: collec.seed(1)
    collec.setForces()
    run(collec, interactions, trackers, steps)
    
    
