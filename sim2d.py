# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.10
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.



from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_sim2d', [dirname(__file__)])
        except ImportError:
            import _sim2d
            return _sim2d
        if fp is not None:
            try:
                _mod = imp.load_module('_sim2d', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _sim2d = swig_import_helper()
    del swig_import_helper
else:
    import _sim2d
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


import collections
class SwigPyIterator(_object):
    """Proxy of C++ swig::SwigPyIterator class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _sim2d.delete_SwigPyIterator
    __del__ = lambda self : None;
    def value(self) -> "PyObject *" :
        """value(SwigPyIterator self) -> PyObject *"""
        return _sim2d.SwigPyIterator_value(self)

    def incr(self, n : 'size_t'=1) -> "swig::SwigPyIterator *" :
        """
        incr(SwigPyIterator self, size_t n=1) -> SwigPyIterator
        incr(SwigPyIterator self) -> SwigPyIterator
        """
        return _sim2d.SwigPyIterator_incr(self, n)

    def decr(self, n : 'size_t'=1) -> "swig::SwigPyIterator *" :
        """
        decr(SwigPyIterator self, size_t n=1) -> SwigPyIterator
        decr(SwigPyIterator self) -> SwigPyIterator
        """
        return _sim2d.SwigPyIterator_decr(self, n)

    def distance(self, *args) -> "ptrdiff_t" :
        """distance(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t"""
        return _sim2d.SwigPyIterator_distance(self, *args)

    def equal(self, *args) -> "bool" :
        """equal(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _sim2d.SwigPyIterator_equal(self, *args)

    def copy(self) -> "swig::SwigPyIterator *" :
        """copy(SwigPyIterator self) -> SwigPyIterator"""
        return _sim2d.SwigPyIterator_copy(self)

    def next(self) -> "PyObject *" :
        """next(SwigPyIterator self) -> PyObject *"""
        return _sim2d.SwigPyIterator_next(self)

    def __next__(self) -> "PyObject *" :
        """__next__(SwigPyIterator self) -> PyObject *"""
        return _sim2d.SwigPyIterator___next__(self)

    def previous(self) -> "PyObject *" :
        """previous(SwigPyIterator self) -> PyObject *"""
        return _sim2d.SwigPyIterator_previous(self)

    def advance(self, *args) -> "swig::SwigPyIterator *" :
        """advance(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _sim2d.SwigPyIterator_advance(self, *args)

    def __eq__(self, *args) -> "bool" :
        """__eq__(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _sim2d.SwigPyIterator___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        """__ne__(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _sim2d.SwigPyIterator___ne__(self, *args)

    def __iadd__(self, *args) -> "swig::SwigPyIterator &" :
        """__iadd__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _sim2d.SwigPyIterator___iadd__(self, *args)

    def __isub__(self, *args) -> "swig::SwigPyIterator &" :
        """__isub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _sim2d.SwigPyIterator___isub__(self, *args)

    def __add__(self, *args) -> "swig::SwigPyIterator *" :
        """__add__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _sim2d.SwigPyIterator___add__(self, *args)

    def __sub__(self, *args) -> "ptrdiff_t" :
        """
        __sub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator
        __sub__(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t
        """
        return _sim2d.SwigPyIterator___sub__(self, *args)

    def __iter__(self): return self
SwigPyIterator_swigregister = _sim2d.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class _Nvector3(_object):
    """Proxy of C++ Nvector<(double,3)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _Nvector3, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _Nvector3, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(Nvector<(double,3)> self) -> _Nvector3
        __init__(Nvector<(double,3)> self, _Nvector3 rhs) -> _Nvector3
        __init__(Nvector<(double,3)> self, double const [3] locs) -> _Nvector3
        """
        this = _sim2d.new__Nvector3(*args)
        try: self.this.append(this)
        except: self.this = this
    def get(self, *args) -> "double const &" :
        """get(_Nvector3 self, unsigned int const n) -> double const &"""
        return _sim2d._Nvector3_get(self, *args)

    def set(self, *args) -> "void" :
        """set(_Nvector3 self, unsigned int const n, double const a)"""
        return _sim2d._Nvector3_set(self, *args)

    def len(self) -> "unsigned int" :
        """len(_Nvector3 self) -> unsigned int"""
        return _sim2d._Nvector3_len(self)

    def __iadd__(self, *args) -> "Nvector< double,3 > &" :
        """__iadd__(_Nvector3 self, _Nvector3 rhs) -> _Nvector3"""
        return _sim2d._Nvector3___iadd__(self, *args)

    def __isub__(self, *args) -> "Nvector< double,3 > &" :
        """__isub__(_Nvector3 self, _Nvector3 rhs) -> _Nvector3"""
        return _sim2d._Nvector3___isub__(self, *args)

    def __neg__(self) -> "Nvector< double,3 >" :
        """__neg__(_Nvector3 self) -> _Nvector3"""
        return _sim2d._Nvector3___neg__(self)

    def __add__(self, *args) -> "Nvector< double,3 >" :
        """__add__(_Nvector3 self, _Nvector3 rhs) -> _Nvector3"""
        return _sim2d._Nvector3___add__(self, *args)

    def __sub__(self, *args) -> "Nvector< double,3 >" :
        """__sub__(_Nvector3 self, _Nvector3 rhs) -> _Nvector3"""
        return _sim2d._Nvector3___sub__(self, *args)

    def begin(self) -> "double *" :
        """begin(_Nvector3 self) -> double *"""
        return _sim2d._Nvector3_begin(self)

    def end(self) -> "double *" :
        """end(_Nvector3 self) -> double *"""
        return _sim2d._Nvector3_end(self)

    __swig_destroy__ = _sim2d.delete__Nvector3
    __del__ = lambda self : None;
    def __mul__(self, *args) -> "Nvector< double,3 >" :
        """__mul__(_Nvector3 self, double const rhs) -> _Nvector3"""
        return _sim2d._Nvector3___mul__(self, *args)

    def __div__(self, *args) -> "Nvector< double,3 >" :
        """__div__(_Nvector3 self, double const rhs) -> _Nvector3"""
        return _sim2d._Nvector3___div__(self, *args)

    def __truediv__(self, *args) -> "Nvector< double,3 >" :
        """__truediv__(_Nvector3 self, double const n) -> _Nvector3"""
        return _sim2d._Nvector3___truediv__(self, *args)

    def __getitem__(self, *args) -> "double" :
        """__getitem__(_Nvector3 self, unsigned int const n) -> double"""
        return _sim2d._Nvector3___getitem__(self, *args)

    def __setitem__(self, *args) -> "void" :
        """__setitem__(_Nvector3 self, unsigned int const n, double const val)"""
        return _sim2d._Nvector3___setitem__(self, *args)

    def __len__(self) -> "unsigned int" :
        """__len__(_Nvector3 self) -> unsigned int"""
        return _sim2d._Nvector3___len__(self)

    #~ def __setitem__(self, n, val):
        #~ return self.set(n, val)

    def __iter__(self):
        for i in range(len(self)):
            yield self.get(i)

    #~ def __len__(self):
        #~ return self.len()

_Nvector3_swigregister = _sim2d._Nvector3_swigregister
_Nvector3_swigregister(_Nvector3)

class _Nvector2(_object):
    """Proxy of C++ Nvector<(double,2)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _Nvector2, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _Nvector2, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(Nvector<(double,2)> self) -> _Nvector2
        __init__(Nvector<(double,2)> self, _Nvector2 rhs) -> _Nvector2
        __init__(Nvector<(double,2)> self, double const [2] locs) -> _Nvector2
        """
        this = _sim2d.new__Nvector2(*args)
        try: self.this.append(this)
        except: self.this = this
    def get(self, *args) -> "double const &" :
        """get(_Nvector2 self, unsigned int const n) -> double const &"""
        return _sim2d._Nvector2_get(self, *args)

    def set(self, *args) -> "void" :
        """set(_Nvector2 self, unsigned int const n, double const a)"""
        return _sim2d._Nvector2_set(self, *args)

    def len(self) -> "unsigned int" :
        """len(_Nvector2 self) -> unsigned int"""
        return _sim2d._Nvector2_len(self)

    def __iadd__(self, *args) -> "Nvector< double,2 > &" :
        """__iadd__(_Nvector2 self, _Nvector2 rhs) -> _Nvector2"""
        return _sim2d._Nvector2___iadd__(self, *args)

    def __isub__(self, *args) -> "Nvector< double,2 > &" :
        """__isub__(_Nvector2 self, _Nvector2 rhs) -> _Nvector2"""
        return _sim2d._Nvector2___isub__(self, *args)

    def __neg__(self) -> "Nvector< double,2 >" :
        """__neg__(_Nvector2 self) -> _Nvector2"""
        return _sim2d._Nvector2___neg__(self)

    def __add__(self, *args) -> "Nvector< double,2 >" :
        """__add__(_Nvector2 self, _Nvector2 rhs) -> _Nvector2"""
        return _sim2d._Nvector2___add__(self, *args)

    def __sub__(self, *args) -> "Nvector< double,2 >" :
        """__sub__(_Nvector2 self, _Nvector2 rhs) -> _Nvector2"""
        return _sim2d._Nvector2___sub__(self, *args)

    def begin(self) -> "double *" :
        """begin(_Nvector2 self) -> double *"""
        return _sim2d._Nvector2_begin(self)

    def end(self) -> "double *" :
        """end(_Nvector2 self) -> double *"""
        return _sim2d._Nvector2_end(self)

    __swig_destroy__ = _sim2d.delete__Nvector2
    __del__ = lambda self : None;
    def __mul__(self, *args) -> "Nvector< double,2 >" :
        """__mul__(_Nvector2 self, double const rhs) -> _Nvector2"""
        return _sim2d._Nvector2___mul__(self, *args)

    def __div__(self, *args) -> "Nvector< double,2 >" :
        """__div__(_Nvector2 self, double const rhs) -> _Nvector2"""
        return _sim2d._Nvector2___div__(self, *args)

    def __truediv__(self, *args) -> "Nvector< double,2 >" :
        """__truediv__(_Nvector2 self, double const n) -> _Nvector2"""
        return _sim2d._Nvector2___truediv__(self, *args)

    def __getitem__(self, *args) -> "double" :
        """__getitem__(_Nvector2 self, unsigned int const n) -> double"""
        return _sim2d._Nvector2___getitem__(self, *args)

    def __setitem__(self, *args) -> "void" :
        """__setitem__(_Nvector2 self, unsigned int const n, double const val)"""
        return _sim2d._Nvector2___setitem__(self, *args)

    def __len__(self) -> "unsigned int" :
        """__len__(_Nvector2 self) -> unsigned int"""
        return _sim2d._Nvector2___len__(self)

    #~ def __setitem__(self, n, val):
        #~ return self.set(n, val)

    def __iter__(self):
        for i in range(len(self)):
            yield self.get(i)

    #~ def __len__(self):
        #~ return self.len()

_Nvector2_swigregister = _sim2d._Nvector2_swigregister
_Nvector2_swigregister(_Nvector2)

class _Numvector3(_Nvector3):
    """Proxy of C++ Numvector<(double,3)> class"""
    __swig_setmethods__ = {}
    for _s in [_Nvector3]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, _Numvector3, name, value)
    __swig_getmethods__ = {}
    for _s in [_Nvector3]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, _Numvector3, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(Numvector<(double,3)> self) -> _Numvector3
        __init__(Numvector<(double,3)> self, _Nvector3 rhs) -> _Numvector3
        __init__(Numvector<(double,3)> self, double const [3] rhs) -> _Numvector3
        """
        this = _sim2d.new__Numvector3(*args)
        try: self.this.append(this)
        except: self.this = this
    def dot(self, *args) -> "double" :
        """dot(_Numvector3 self, _Numvector3 other) -> double"""
        return _sim2d._Numvector3_dot(self, *args)

    def sq(self) -> "double" :
        """sq(_Numvector3 self) -> double"""
        return _sim2d._Numvector3_sq(self)

    def mag(self) -> "double" :
        """mag(_Numvector3 self) -> double"""
        return _sim2d._Numvector3_mag(self)

    def distance(self, *args) -> "double" :
        """distance(_Numvector3 self, _Numvector3 rhs) -> double"""
        return _sim2d._Numvector3_distance(self, *args)

    def perpto(self, *args) -> "Numvector< double,3 >" :
        """perpto(_Numvector3 self, _Numvector3 other) -> _Numvector3"""
        return _sim2d._Numvector3_perpto(self, *args)

    def normalize(self) -> "void" :
        """normalize(_Numvector3 self)"""
        return _sim2d._Numvector3_normalize(self)

    def norm(self) -> "Numvector< double,3 >" :
        """norm(_Numvector3 self) -> _Numvector3"""
        return _sim2d._Numvector3_norm(self)

    __swig_destroy__ = _sim2d.delete__Numvector3
    __del__ = lambda self : None;
_Numvector3_swigregister = _sim2d._Numvector3_swigregister
_Numvector3_swigregister(_Numvector3)

class _Numvector2(_Nvector2):
    """Proxy of C++ Numvector<(double,2)> class"""
    __swig_setmethods__ = {}
    for _s in [_Nvector2]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, _Numvector2, name, value)
    __swig_getmethods__ = {}
    for _s in [_Nvector2]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, _Numvector2, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(Numvector<(double,2)> self) -> _Numvector2
        __init__(Numvector<(double,2)> self, _Nvector2 rhs) -> _Numvector2
        __init__(Numvector<(double,2)> self, double const [2] rhs) -> _Numvector2
        """
        this = _sim2d.new__Numvector2(*args)
        try: self.this.append(this)
        except: self.this = this
    def dot(self, *args) -> "double" :
        """dot(_Numvector2 self, _Numvector2 other) -> double"""
        return _sim2d._Numvector2_dot(self, *args)

    def sq(self) -> "double" :
        """sq(_Numvector2 self) -> double"""
        return _sim2d._Numvector2_sq(self)

    def mag(self) -> "double" :
        """mag(_Numvector2 self) -> double"""
        return _sim2d._Numvector2_mag(self)

    def distance(self, *args) -> "double" :
        """distance(_Numvector2 self, _Numvector2 rhs) -> double"""
        return _sim2d._Numvector2_distance(self, *args)

    def perpto(self, *args) -> "Numvector< double,2 >" :
        """perpto(_Numvector2 self, _Numvector2 other) -> _Numvector2"""
        return _sim2d._Numvector2_perpto(self, *args)

    def normalize(self) -> "void" :
        """normalize(_Numvector2 self)"""
        return _sim2d._Numvector2_normalize(self)

    def norm(self) -> "Numvector< double,2 >" :
        """norm(_Numvector2 self) -> _Numvector2"""
        return _sim2d._Numvector2_norm(self)

    __swig_destroy__ = _sim2d.delete__Numvector2
    __del__ = lambda self : None;
_Numvector2_swigregister = _sim2d._Numvector2_swigregister
_Numvector2_swigregister(_Numvector2)

class Vec(_Numvector2):
    """Proxy of C++ Vector2<(double)> class"""
    __swig_setmethods__ = {}
    for _s in [_Numvector2]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Vec, name, value)
    __swig_getmethods__ = {}
    for _s in [_Numvector2]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Vec, name)
    def __init__(self, *args): 
        """
        __init__(Vector2<(double)> self) -> Vec
        __init__(Vector2<(double)> self, double const a, double const b) -> Vec
        __init__(Vector2<(double)> self, _Numvector2 rhs) -> Vec
        __init__(Vector2<(double)> self, _Nvector2 rhs) -> Vec
        """
        this = _sim2d.new_Vec(*args)
        try: self.this.append(this)
        except: self.this = this
    def getx(self) -> "double const" :
        """getx(Vec self) -> double const"""
        return _sim2d.Vec_getx(self)

    def gety(self) -> "double const" :
        """gety(Vec self) -> double const"""
        return _sim2d.Vec_gety(self)

    def setx(self, *args) -> "void" :
        """setx(Vec self, double const a)"""
        return _sim2d.Vec_setx(self, *args)

    def sety(self, *args) -> "void" :
        """sety(Vec self, double const b)"""
        return _sim2d.Vec_sety(self, *args)

    def set(self, *args) -> "void" :
        """set(Vec self, double const a, double const b)"""
        return _sim2d.Vec_set(self, *args)

    def __neg__(self) -> "Vector2< double >" :
        """__neg__(Vec self) -> Vec"""
        return _sim2d.Vec___neg__(self)

    def __add__(self, *args) -> "Vector2< double >" :
        """__add__(Vec self, Vec rhs) -> Vec"""
        return _sim2d.Vec___add__(self, *args)

    def __sub__(self, *args) -> "Vector2< double >" :
        """__sub__(Vec self, Vec rhs) -> Vec"""
        return _sim2d.Vec___sub__(self, *args)

    def cross(self, *args) -> "double" :
        """cross(Vec self, Vec rhs) -> double"""
        return _sim2d.Vec_cross(self, *args)

    def perp(self) -> "Vector2< double >" :
        """perp(Vec self) -> Vec"""
        return _sim2d.Vec_perp(self)

    def norm(self) -> "Vector2< double >" :
        """norm(Vec self) -> Vec"""
        return _sim2d.Vec_norm(self)

    def __isub__(self, *args) -> "Vector2< double > &" :
        """__isub__(Vec self, Vec rhs) -> Vec"""
        return _sim2d.Vec___isub__(self, *args)

    def __iadd__(self, *args) -> "Vector2< double > &" :
        """__iadd__(Vec self, Vec rhs) -> Vec"""
        return _sim2d.Vec___iadd__(self, *args)

    def rotate(self, *args) -> "Vector2< double >" :
        """rotate(Vec self, uint i) -> Vec"""
        return _sim2d.Vec_rotate(self, *args)

    def flip(self) -> "Vector2< double >" :
        """flip(Vec self) -> Vec"""
        return _sim2d.Vec_flip(self)

    def rotate_flip(self, *args) -> "Vector2< double >" :
        """rotate_flip(Vec self, uint i) -> Vec"""
        return _sim2d.Vec_rotate_flip(self, *args)

    def rotate_flip_inv(self, *args) -> "Vector2< double >" :
        """rotate_flip_inv(Vec self, uint i) -> Vec"""
        return _sim2d.Vec_rotate_flip_inv(self, *args)

    def angle(*args) -> "double" :
        """
        angle(Vec dx1, Vec dx2) -> double
        angle(Vec x1, Vec x2, Vec x3) -> double
        """
        return _sim2d.Vec_angle(*args)

    if _newclass:angle = staticmethod(angle)
    __swig_getmethods__["angle"] = lambda x: angle
    __swig_destroy__ = _sim2d.delete_Vec
    __del__ = lambda self : None;
    def __str__(self) -> "char *" :
        """__str__(Vec self) -> char *"""
        return _sim2d.Vec___str__(self)

    def __repr__(self) -> "char *" :
        """__repr__(Vec self) -> char *"""
        return _sim2d.Vec___repr__(self)

    def __truediv__(self, *args) -> "Vector2< double >" :
        """__truediv__(Vec self, double const n) -> Vec"""
        return _sim2d.Vec___truediv__(self, *args)

    def __mul__(self, *args) -> "Vector2< double >" :
        """
        __mul__(Vec self, Vec rhs) -> double
        __mul__(Vec self, double const n) -> Vec
        """
        return _sim2d.Vec___mul__(self, *args)

    @property
    def X(self):
        return self.getx()

    @property
    def Y(self):
        return self.gety()

Vec_swigregister = _sim2d.Vec_swigregister
Vec_swigregister(Vec)

def Vec_angle(*args) -> "double" :
  """
    angle(Vec dx1, Vec dx2) -> double
    Vec_angle(Vec x1, Vec x2, Vec x3) -> double
    """
  return _sim2d.Vec_angle(*args)

class vecptrvector(_object):
    """Proxy of C++ vector<(p.Vector2<(double)>)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vecptrvector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vecptrvector, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" :
        """iterator(vecptrvector self) -> SwigPyIterator"""
        return _sim2d.vecptrvector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" :
        """__nonzero__(vecptrvector self) -> bool"""
        return _sim2d.vecptrvector___nonzero__(self)

    def __bool__(self) -> "bool" :
        """__bool__(vecptrvector self) -> bool"""
        return _sim2d.vecptrvector___bool__(self)

    def __len__(self) -> "vector< Vector2< double > * >::size_type" :
        """__len__(vecptrvector self) -> vector< Vector2< double > * >::size_type"""
        return _sim2d.vecptrvector___len__(self)

    def pop(self) -> "vector< Vector2< double > * >::value_type" :
        """pop(vecptrvector self) -> Vec"""
        return _sim2d.vecptrvector_pop(self)

    def __getslice__(self, *args) -> "std::vector< Vector2< double > *,std::allocator< Vector2< double > * > > *" :
        """__getslice__(vecptrvector self, vector< Vector2< double > * >::difference_type i, vector< Vector2< double > * >::difference_type j) -> std::vector< Vector2< double > *,std::allocator< Vector2< double > * > > *"""
        return _sim2d.vecptrvector___getslice__(self, *args)

    def __setslice__(self, *args) -> "void" :
        """
        __setslice__(vecptrvector self, vector< Vector2< double > * >::difference_type i, vector< Vector2< double > * >::difference_type j, 
            std::vector< Vector2< double > *,std::allocator< Vector2< double > * > > const & v=std::vector< Vector2< double > *,std::allocator< Vector2< double > * > >())
        __setslice__(vecptrvector self, vector< Vector2< double > * >::difference_type i, vector< Vector2< double > * >::difference_type j)
        """
        return _sim2d.vecptrvector___setslice__(self, *args)

    def __delslice__(self, *args) -> "void" :
        """__delslice__(vecptrvector self, vector< Vector2< double > * >::difference_type i, vector< Vector2< double > * >::difference_type j)"""
        return _sim2d.vecptrvector___delslice__(self, *args)

    def __delitem__(self, *args) -> "void" :
        """
        __delitem__(vecptrvector self, vector< Vector2< double > * >::difference_type i)
        __delitem__(vecptrvector self, PySliceObject * slice)
        """
        return _sim2d.vecptrvector___delitem__(self, *args)

    def __getitem__(self, *args) -> "vector< Vector2< double > * >::value_type" :
        """
        __getitem__(vecptrvector self, PySliceObject * slice) -> std::vector< Vector2< double > *,std::allocator< Vector2< double > * > >
        __getitem__(vecptrvector self, vector< Vector2< double > * >::difference_type i) -> Vec
        """
        return _sim2d.vecptrvector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void" :
        """
        __setitem__(vecptrvector self, PySliceObject * slice, std::vector< Vector2< double > *,std::allocator< Vector2< double > * > > const & v)
        __setitem__(vecptrvector self, PySliceObject * slice)
        __setitem__(vecptrvector self, vector< Vector2< double > * >::difference_type i, Vec x)
        """
        return _sim2d.vecptrvector___setitem__(self, *args)

    def append(self, *args) -> "void" :
        """append(vecptrvector self, Vec x)"""
        return _sim2d.vecptrvector_append(self, *args)

    def empty(self) -> "bool" :
        """empty(vecptrvector self) -> bool"""
        return _sim2d.vecptrvector_empty(self)

    def size(self) -> "vector< Vector2< double > * >::size_type" :
        """size(vecptrvector self) -> vector< Vector2< double > * >::size_type"""
        return _sim2d.vecptrvector_size(self)

    def clear(self) -> "void" :
        """clear(vecptrvector self)"""
        return _sim2d.vecptrvector_clear(self)

    def swap(self, *args) -> "void" :
        """swap(vecptrvector self, vecptrvector v)"""
        return _sim2d.vecptrvector_swap(self, *args)

    def get_allocator(self) -> "vector< Vector2< double > * >::allocator_type" :
        """get_allocator(vecptrvector self) -> vector< Vector2< double > * >::allocator_type"""
        return _sim2d.vecptrvector_get_allocator(self)

    def begin(self) -> "vector< Vector2< double > * >::iterator" :
        """begin(vecptrvector self) -> vector< Vector2< double > * >::iterator"""
        return _sim2d.vecptrvector_begin(self)

    def end(self) -> "vector< Vector2< double > * >::iterator" :
        """end(vecptrvector self) -> vector< Vector2< double > * >::iterator"""
        return _sim2d.vecptrvector_end(self)

    def rbegin(self) -> "vector< Vector2< double > * >::reverse_iterator" :
        """rbegin(vecptrvector self) -> vector< Vector2< double > * >::reverse_iterator"""
        return _sim2d.vecptrvector_rbegin(self)

    def rend(self) -> "vector< Vector2< double > * >::reverse_iterator" :
        """rend(vecptrvector self) -> vector< Vector2< double > * >::reverse_iterator"""
        return _sim2d.vecptrvector_rend(self)

    def pop_back(self) -> "void" :
        """pop_back(vecptrvector self)"""
        return _sim2d.vecptrvector_pop_back(self)

    def erase(self, *args) -> "vector< Vector2< double > * >::iterator" :
        """
        erase(vecptrvector self, vector< Vector2< double > * >::iterator pos) -> vector< Vector2< double > * >::iterator
        erase(vecptrvector self, vector< Vector2< double > * >::iterator first, vector< Vector2< double > * >::iterator last) -> vector< Vector2< double > * >::iterator
        """
        return _sim2d.vecptrvector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(vector<(p.Vector2<(double)>)> self) -> vecptrvector
        __init__(vector<(p.Vector2<(double)>)> self, vecptrvector arg2) -> vecptrvector
        __init__(vector<(p.Vector2<(double)>)> self, vector< Vector2< double > * >::size_type size) -> vecptrvector
        __init__(vector<(p.Vector2<(double)>)> self, vector< Vector2< double > * >::size_type size, Vec value) -> vecptrvector
        """
        this = _sim2d.new_vecptrvector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" :
        """push_back(vecptrvector self, Vec x)"""
        return _sim2d.vecptrvector_push_back(self, *args)

    def front(self) -> "vector< Vector2< double > * >::value_type" :
        """front(vecptrvector self) -> Vec"""
        return _sim2d.vecptrvector_front(self)

    def back(self) -> "vector< Vector2< double > * >::value_type" :
        """back(vecptrvector self) -> Vec"""
        return _sim2d.vecptrvector_back(self)

    def assign(self, *args) -> "void" :
        """assign(vecptrvector self, vector< Vector2< double > * >::size_type n, Vec x)"""
        return _sim2d.vecptrvector_assign(self, *args)

    def resize(self, *args) -> "void" :
        """
        resize(vecptrvector self, vector< Vector2< double > * >::size_type new_size)
        resize(vecptrvector self, vector< Vector2< double > * >::size_type new_size, Vec x)
        """
        return _sim2d.vecptrvector_resize(self, *args)

    def insert(self, *args) -> "void" :
        """
        insert(vecptrvector self, vector< Vector2< double > * >::iterator pos, Vec x) -> vector< Vector2< double > * >::iterator
        insert(vecptrvector self, vector< Vector2< double > * >::iterator pos, vector< Vector2< double > * >::size_type n, 
            Vec x)
        """
        return _sim2d.vecptrvector_insert(self, *args)

    def reserve(self, *args) -> "void" :
        """reserve(vecptrvector self, vector< Vector2< double > * >::size_type n)"""
        return _sim2d.vecptrvector_reserve(self, *args)

    def capacity(self) -> "vector< Vector2< double > * >::size_type" :
        """capacity(vecptrvector self) -> vector< Vector2< double > * >::size_type"""
        return _sim2d.vecptrvector_capacity(self)

    __swig_destroy__ = _sim2d.delete_vecptrvector
    __del__ = lambda self : None;
vecptrvector_swigregister = _sim2d.vecptrvector_swigregister
vecptrvector_swigregister(vecptrvector)

class vecvector(collections.MutableSequence):
    """Proxy of C++ vector<(Vector2<(double)>)> class"""
    __swig_setmethods__ = {}
    for _s in [collections.MutableSequence]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, vecvector, name, value)
    __swig_getmethods__ = {}
    for _s in [collections.MutableSequence]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, vecvector, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" :
        """iterator(vecvector self) -> SwigPyIterator"""
        return _sim2d.vecvector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" :
        """__nonzero__(vecvector self) -> bool"""
        return _sim2d.vecvector___nonzero__(self)

    def __bool__(self) -> "bool" :
        """__bool__(vecvector self) -> bool"""
        return _sim2d.vecvector___bool__(self)

    def __len__(self) -> "vector< Vector2< double > >::size_type" :
        """__len__(vecvector self) -> vector< Vector2< double > >::size_type"""
        return _sim2d.vecvector___len__(self)

    def pop(self) -> "vector< Vector2< double > >::value_type" :
        """pop(vecvector self) -> Vec"""
        return _sim2d.vecvector_pop(self)

    def __getslice__(self, *args) -> "std::vector< Vector2< double >,std::allocator< Vector2< double > > > *" :
        """__getslice__(vecvector self, vector< Vector2< double > >::difference_type i, vector< Vector2< double > >::difference_type j) -> std::vector< Vector2< double >,std::allocator< Vector2< double > > > *"""
        return _sim2d.vecvector___getslice__(self, *args)

    def __setslice__(self, *args) -> "void" :
        """
        __setslice__(vecvector self, vector< Vector2< double > >::difference_type i, vector< Vector2< double > >::difference_type j, 
            std::vector< Vector2< double >,std::allocator< Vector2< double > > > const & v=std::vector< Vector2< double >,std::allocator< Vector2< double > > >())
        __setslice__(vecvector self, vector< Vector2< double > >::difference_type i, vector< Vector2< double > >::difference_type j)
        """
        return _sim2d.vecvector___setslice__(self, *args)

    def __delslice__(self, *args) -> "void" :
        """__delslice__(vecvector self, vector< Vector2< double > >::difference_type i, vector< Vector2< double > >::difference_type j)"""
        return _sim2d.vecvector___delslice__(self, *args)

    def __delitem__(self, *args) -> "void" :
        """
        __delitem__(vecvector self, vector< Vector2< double > >::difference_type i)
        __delitem__(vecvector self, PySliceObject * slice)
        """
        return _sim2d.vecvector___delitem__(self, *args)

    def __getitem__(self, *args) -> "vector< Vector2< double > >::value_type const &" :
        """
        __getitem__(vecvector self, PySliceObject * slice) -> std::vector< Vector2< double >,std::allocator< Vector2< double > > >
        __getitem__(vecvector self, vector< Vector2< double > >::difference_type i) -> Vec
        """
        return _sim2d.vecvector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void" :
        """
        __setitem__(vecvector self, PySliceObject * slice, std::vector< Vector2< double >,std::allocator< Vector2< double > > > const & v)
        __setitem__(vecvector self, PySliceObject * slice)
        __setitem__(vecvector self, vector< Vector2< double > >::difference_type i, Vec x)
        """
        return _sim2d.vecvector___setitem__(self, *args)

    def append(self, *args) -> "void" :
        """append(vecvector self, Vec x)"""
        return _sim2d.vecvector_append(self, *args)

    def empty(self) -> "bool" :
        """empty(vecvector self) -> bool"""
        return _sim2d.vecvector_empty(self)

    def size(self) -> "vector< Vector2< double > >::size_type" :
        """size(vecvector self) -> vector< Vector2< double > >::size_type"""
        return _sim2d.vecvector_size(self)

    def clear(self) -> "void" :
        """clear(vecvector self)"""
        return _sim2d.vecvector_clear(self)

    def swap(self, *args) -> "void" :
        """swap(vecvector self, vecvector v)"""
        return _sim2d.vecvector_swap(self, *args)

    def get_allocator(self) -> "vector< Vector2< double > >::allocator_type" :
        """get_allocator(vecvector self) -> vector< Vector2< double > >::allocator_type"""
        return _sim2d.vecvector_get_allocator(self)

    def begin(self) -> "vector< Vector2< double > >::iterator" :
        """begin(vecvector self) -> vector< Vector2< double > >::iterator"""
        return _sim2d.vecvector_begin(self)

    def end(self) -> "vector< Vector2< double > >::iterator" :
        """end(vecvector self) -> vector< Vector2< double > >::iterator"""
        return _sim2d.vecvector_end(self)

    def rbegin(self) -> "vector< Vector2< double > >::reverse_iterator" :
        """rbegin(vecvector self) -> vector< Vector2< double > >::reverse_iterator"""
        return _sim2d.vecvector_rbegin(self)

    def rend(self) -> "vector< Vector2< double > >::reverse_iterator" :
        """rend(vecvector self) -> vector< Vector2< double > >::reverse_iterator"""
        return _sim2d.vecvector_rend(self)

    def pop_back(self) -> "void" :
        """pop_back(vecvector self)"""
        return _sim2d.vecvector_pop_back(self)

    def erase(self, *args) -> "vector< Vector2< double > >::iterator" :
        """
        erase(vecvector self, vector< Vector2< double > >::iterator pos) -> vector< Vector2< double > >::iterator
        erase(vecvector self, vector< Vector2< double > >::iterator first, vector< Vector2< double > >::iterator last) -> vector< Vector2< double > >::iterator
        """
        return _sim2d.vecvector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(vector<(Vector2<(double)>)> self) -> vecvector
        __init__(vector<(Vector2<(double)>)> self, vecvector arg2) -> vecvector
        __init__(vector<(Vector2<(double)>)> self, vector< Vector2< double > >::size_type size) -> vecvector
        __init__(vector<(Vector2<(double)>)> self, vector< Vector2< double > >::size_type size, Vec value) -> vecvector
        """
        this = _sim2d.new_vecvector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" :
        """push_back(vecvector self, Vec x)"""
        return _sim2d.vecvector_push_back(self, *args)

    def front(self) -> "vector< Vector2< double > >::value_type const &" :
        """front(vecvector self) -> Vec"""
        return _sim2d.vecvector_front(self)

    def back(self) -> "vector< Vector2< double > >::value_type const &" :
        """back(vecvector self) -> Vec"""
        return _sim2d.vecvector_back(self)

    def assign(self, *args) -> "void" :
        """assign(vecvector self, vector< Vector2< double > >::size_type n, Vec x)"""
        return _sim2d.vecvector_assign(self, *args)

    def resize(self, *args) -> "void" :
        """
        resize(vecvector self, vector< Vector2< double > >::size_type new_size)
        resize(vecvector self, vector< Vector2< double > >::size_type new_size, Vec x)
        """
        return _sim2d.vecvector_resize(self, *args)

    def insert(self, *args) -> "void" :
        """
        insert(vecvector self, vector< Vector2< double > >::iterator pos, Vec x) -> vector< Vector2< double > >::iterator
        insert(vecvector self, vector< Vector2< double > >::iterator pos, vector< Vector2< double > >::size_type n, 
            Vec x)
        """
        return _sim2d.vecvector_insert(self, *args)

    def reserve(self, *args) -> "void" :
        """reserve(vecvector self, vector< Vector2< double > >::size_type n)"""
        return _sim2d.vecvector_reserve(self, *args)

    def capacity(self) -> "vector< Vector2< double > >::size_type" :
        """capacity(vecvector self) -> vector< Vector2< double > >::size_type"""
        return _sim2d.vecvector_capacity(self)

    __swig_destroy__ = _sim2d.delete_vecvector
    __del__ = lambda self : None;
vecvector_swigregister = _sim2d.vecvector_swigregister
vecvector_swigregister(vecvector)

class _jamminglist(collections.MutableSequence):
    """Proxy of C++ list<(jamminglist)> class"""
    __swig_setmethods__ = {}
    for _s in [collections.MutableSequence]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, _jamminglist, name, value)
    __swig_getmethods__ = {}
    for _s in [collections.MutableSequence]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, _jamminglist, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" :
        """iterator(_jamminglist self) -> SwigPyIterator"""
        return _sim2d._jamminglist_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" :
        """__nonzero__(_jamminglist self) -> bool"""
        return _sim2d._jamminglist___nonzero__(self)

    def __bool__(self) -> "bool" :
        """__bool__(_jamminglist self) -> bool"""
        return _sim2d._jamminglist___bool__(self)

    def __len__(self) -> "list< jamminglist >::size_type" :
        """__len__(_jamminglist self) -> list< jamminglist >::size_type"""
        return _sim2d._jamminglist___len__(self)

    def pop(self) -> "list< jamminglist >::value_type" :
        """pop(_jamminglist self) -> jamminglist"""
        return _sim2d._jamminglist_pop(self)

    def __getslice__(self, *args) -> "std::list< jamminglist,std::allocator< jamminglist > > *" :
        """__getslice__(_jamminglist self, list< jamminglist >::difference_type i, list< jamminglist >::difference_type j) -> std::list< jamminglist,std::allocator< jamminglist > > *"""
        return _sim2d._jamminglist___getslice__(self, *args)

    def __setslice__(self, *args) -> "void" :
        """
        __setslice__(_jamminglist self, list< jamminglist >::difference_type i, list< jamminglist >::difference_type j, std::list< jamminglist,std::allocator< jamminglist > > const & v=std::list< jamminglist,std::allocator< jamminglist > >())
        __setslice__(_jamminglist self, list< jamminglist >::difference_type i, list< jamminglist >::difference_type j)
        """
        return _sim2d._jamminglist___setslice__(self, *args)

    def __delslice__(self, *args) -> "void" :
        """__delslice__(_jamminglist self, list< jamminglist >::difference_type i, list< jamminglist >::difference_type j)"""
        return _sim2d._jamminglist___delslice__(self, *args)

    def __delitem__(self, *args) -> "void" :
        """
        __delitem__(_jamminglist self, list< jamminglist >::difference_type i)
        __delitem__(_jamminglist self, PySliceObject * slice)
        """
        return _sim2d._jamminglist___delitem__(self, *args)

    def __getitem__(self, *args) -> "list< jamminglist >::value_type const &" :
        """
        __getitem__(_jamminglist self, PySliceObject * slice) -> std::list< jamminglist,std::allocator< jamminglist > >
        __getitem__(_jamminglist self, list< jamminglist >::difference_type i) -> jamminglist
        """
        return _sim2d._jamminglist___getitem__(self, *args)

    def __setitem__(self, *args) -> "void" :
        """
        __setitem__(_jamminglist self, PySliceObject * slice, std::list< jamminglist,std::allocator< jamminglist > > const & v)
        __setitem__(_jamminglist self, PySliceObject * slice)
        __setitem__(_jamminglist self, list< jamminglist >::difference_type i, jamminglist x)
        """
        return _sim2d._jamminglist___setitem__(self, *args)

    def append(self, *args) -> "void" :
        """append(_jamminglist self, jamminglist x)"""
        return _sim2d._jamminglist_append(self, *args)

    def empty(self) -> "bool" :
        """empty(_jamminglist self) -> bool"""
        return _sim2d._jamminglist_empty(self)

    def size(self) -> "list< jamminglist >::size_type" :
        """size(_jamminglist self) -> list< jamminglist >::size_type"""
        return _sim2d._jamminglist_size(self)

    def clear(self) -> "void" :
        """clear(_jamminglist self)"""
        return _sim2d._jamminglist_clear(self)

    def swap(self, *args) -> "void" :
        """swap(_jamminglist self, _jamminglist v)"""
        return _sim2d._jamminglist_swap(self, *args)

    def get_allocator(self) -> "list< jamminglist >::allocator_type" :
        """get_allocator(_jamminglist self) -> list< jamminglist >::allocator_type"""
        return _sim2d._jamminglist_get_allocator(self)

    def begin(self) -> "list< jamminglist >::iterator" :
        """begin(_jamminglist self) -> list< jamminglist >::iterator"""
        return _sim2d._jamminglist_begin(self)

    def end(self) -> "list< jamminglist >::iterator" :
        """end(_jamminglist self) -> list< jamminglist >::iterator"""
        return _sim2d._jamminglist_end(self)

    def rbegin(self) -> "list< jamminglist >::reverse_iterator" :
        """rbegin(_jamminglist self) -> list< jamminglist >::reverse_iterator"""
        return _sim2d._jamminglist_rbegin(self)

    def rend(self) -> "list< jamminglist >::reverse_iterator" :
        """rend(_jamminglist self) -> list< jamminglist >::reverse_iterator"""
        return _sim2d._jamminglist_rend(self)

    def pop_back(self) -> "void" :
        """pop_back(_jamminglist self)"""
        return _sim2d._jamminglist_pop_back(self)

    def erase(self, *args) -> "list< jamminglist >::iterator" :
        """
        erase(_jamminglist self, list< jamminglist >::iterator pos) -> list< jamminglist >::iterator
        erase(_jamminglist self, list< jamminglist >::iterator first, list< jamminglist >::iterator last) -> list< jamminglist >::iterator
        """
        return _sim2d._jamminglist_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(list<(jamminglist)> self) -> _jamminglist
        __init__(list<(jamminglist)> self, _jamminglist arg2) -> _jamminglist
        __init__(list<(jamminglist)> self, list< jamminglist >::size_type size) -> _jamminglist
        __init__(list<(jamminglist)> self, list< jamminglist >::size_type size, jamminglist value) -> _jamminglist
        """
        this = _sim2d.new__jamminglist(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" :
        """push_back(_jamminglist self, jamminglist x)"""
        return _sim2d._jamminglist_push_back(self, *args)

    def front(self) -> "list< jamminglist >::value_type const &" :
        """front(_jamminglist self) -> jamminglist"""
        return _sim2d._jamminglist_front(self)

    def back(self) -> "list< jamminglist >::value_type const &" :
        """back(_jamminglist self) -> jamminglist"""
        return _sim2d._jamminglist_back(self)

    def assign(self, *args) -> "void" :
        """assign(_jamminglist self, list< jamminglist >::size_type n, jamminglist x)"""
        return _sim2d._jamminglist_assign(self, *args)

    def resize(self, *args) -> "void" :
        """
        resize(_jamminglist self, list< jamminglist >::size_type new_size)
        resize(_jamminglist self, list< jamminglist >::size_type new_size, jamminglist x)
        """
        return _sim2d._jamminglist_resize(self, *args)

    def insert(self, *args) -> "void" :
        """
        insert(_jamminglist self, list< jamminglist >::iterator pos, jamminglist x) -> list< jamminglist >::iterator
        insert(_jamminglist self, list< jamminglist >::iterator pos, list< jamminglist >::size_type n, jamminglist x)
        """
        return _sim2d._jamminglist_insert(self, *args)

    def pop_front(self) -> "void" :
        """pop_front(_jamminglist self)"""
        return _sim2d._jamminglist_pop_front(self)

    def push_front(self, *args) -> "void" :
        """push_front(_jamminglist self, jamminglist x)"""
        return _sim2d._jamminglist_push_front(self, *args)

    def reverse(self) -> "void" :
        """reverse(_jamminglist self)"""
        return _sim2d._jamminglist_reverse(self)

    __swig_destroy__ = _sim2d.delete__jamminglist
    __del__ = lambda self : None;
_jamminglist_swigregister = _sim2d._jamminglist_swigregister
_jamminglist_swigregister(_jamminglist)

class _jamminglistrot(collections.MutableSequence):
    """Proxy of C++ list<(jamminglistrot)> class"""
    __swig_setmethods__ = {}
    for _s in [collections.MutableSequence]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, _jamminglistrot, name, value)
    __swig_getmethods__ = {}
    for _s in [collections.MutableSequence]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, _jamminglistrot, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" :
        """iterator(_jamminglistrot self) -> SwigPyIterator"""
        return _sim2d._jamminglistrot_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" :
        """__nonzero__(_jamminglistrot self) -> bool"""
        return _sim2d._jamminglistrot___nonzero__(self)

    def __bool__(self) -> "bool" :
        """__bool__(_jamminglistrot self) -> bool"""
        return _sim2d._jamminglistrot___bool__(self)

    def __len__(self) -> "list< jamminglistrot >::size_type" :
        """__len__(_jamminglistrot self) -> list< jamminglistrot >::size_type"""
        return _sim2d._jamminglistrot___len__(self)

    def pop(self) -> "list< jamminglistrot >::value_type" :
        """pop(_jamminglistrot self) -> jamminglistrot"""
        return _sim2d._jamminglistrot_pop(self)

    def __getslice__(self, *args) -> "std::list< jamminglistrot,std::allocator< jamminglistrot > > *" :
        """__getslice__(_jamminglistrot self, list< jamminglistrot >::difference_type i, list< jamminglistrot >::difference_type j) -> std::list< jamminglistrot,std::allocator< jamminglistrot > > *"""
        return _sim2d._jamminglistrot___getslice__(self, *args)

    def __setslice__(self, *args) -> "void" :
        """
        __setslice__(_jamminglistrot self, list< jamminglistrot >::difference_type i, list< jamminglistrot >::difference_type j, 
            std::list< jamminglistrot,std::allocator< jamminglistrot > > const & v=std::list< jamminglistrot,std::allocator< jamminglistrot > >())
        __setslice__(_jamminglistrot self, list< jamminglistrot >::difference_type i, list< jamminglistrot >::difference_type j)
        """
        return _sim2d._jamminglistrot___setslice__(self, *args)

    def __delslice__(self, *args) -> "void" :
        """__delslice__(_jamminglistrot self, list< jamminglistrot >::difference_type i, list< jamminglistrot >::difference_type j)"""
        return _sim2d._jamminglistrot___delslice__(self, *args)

    def __delitem__(self, *args) -> "void" :
        """
        __delitem__(_jamminglistrot self, list< jamminglistrot >::difference_type i)
        __delitem__(_jamminglistrot self, PySliceObject * slice)
        """
        return _sim2d._jamminglistrot___delitem__(self, *args)

    def __getitem__(self, *args) -> "list< jamminglistrot >::value_type const &" :
        """
        __getitem__(_jamminglistrot self, PySliceObject * slice) -> std::list< jamminglistrot,std::allocator< jamminglistrot > >
        __getitem__(_jamminglistrot self, list< jamminglistrot >::difference_type i) -> jamminglistrot
        """
        return _sim2d._jamminglistrot___getitem__(self, *args)

    def __setitem__(self, *args) -> "void" :
        """
        __setitem__(_jamminglistrot self, PySliceObject * slice, std::list< jamminglistrot,std::allocator< jamminglistrot > > const & v)
        __setitem__(_jamminglistrot self, PySliceObject * slice)
        __setitem__(_jamminglistrot self, list< jamminglistrot >::difference_type i, jamminglistrot x)
        """
        return _sim2d._jamminglistrot___setitem__(self, *args)

    def append(self, *args) -> "void" :
        """append(_jamminglistrot self, jamminglistrot x)"""
        return _sim2d._jamminglistrot_append(self, *args)

    def empty(self) -> "bool" :
        """empty(_jamminglistrot self) -> bool"""
        return _sim2d._jamminglistrot_empty(self)

    def size(self) -> "list< jamminglistrot >::size_type" :
        """size(_jamminglistrot self) -> list< jamminglistrot >::size_type"""
        return _sim2d._jamminglistrot_size(self)

    def clear(self) -> "void" :
        """clear(_jamminglistrot self)"""
        return _sim2d._jamminglistrot_clear(self)

    def swap(self, *args) -> "void" :
        """swap(_jamminglistrot self, _jamminglistrot v)"""
        return _sim2d._jamminglistrot_swap(self, *args)

    def get_allocator(self) -> "list< jamminglistrot >::allocator_type" :
        """get_allocator(_jamminglistrot self) -> list< jamminglistrot >::allocator_type"""
        return _sim2d._jamminglistrot_get_allocator(self)

    def begin(self) -> "list< jamminglistrot >::iterator" :
        """begin(_jamminglistrot self) -> list< jamminglistrot >::iterator"""
        return _sim2d._jamminglistrot_begin(self)

    def end(self) -> "list< jamminglistrot >::iterator" :
        """end(_jamminglistrot self) -> list< jamminglistrot >::iterator"""
        return _sim2d._jamminglistrot_end(self)

    def rbegin(self) -> "list< jamminglistrot >::reverse_iterator" :
        """rbegin(_jamminglistrot self) -> list< jamminglistrot >::reverse_iterator"""
        return _sim2d._jamminglistrot_rbegin(self)

    def rend(self) -> "list< jamminglistrot >::reverse_iterator" :
        """rend(_jamminglistrot self) -> list< jamminglistrot >::reverse_iterator"""
        return _sim2d._jamminglistrot_rend(self)

    def pop_back(self) -> "void" :
        """pop_back(_jamminglistrot self)"""
        return _sim2d._jamminglistrot_pop_back(self)

    def erase(self, *args) -> "list< jamminglistrot >::iterator" :
        """
        erase(_jamminglistrot self, list< jamminglistrot >::iterator pos) -> list< jamminglistrot >::iterator
        erase(_jamminglistrot self, list< jamminglistrot >::iterator first, list< jamminglistrot >::iterator last) -> list< jamminglistrot >::iterator
        """
        return _sim2d._jamminglistrot_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(list<(jamminglistrot)> self) -> _jamminglistrot
        __init__(list<(jamminglistrot)> self, _jamminglistrot arg2) -> _jamminglistrot
        __init__(list<(jamminglistrot)> self, list< jamminglistrot >::size_type size) -> _jamminglistrot
        __init__(list<(jamminglistrot)> self, list< jamminglistrot >::size_type size, jamminglistrot value) -> _jamminglistrot
        """
        this = _sim2d.new__jamminglistrot(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" :
        """push_back(_jamminglistrot self, jamminglistrot x)"""
        return _sim2d._jamminglistrot_push_back(self, *args)

    def front(self) -> "list< jamminglistrot >::value_type const &" :
        """front(_jamminglistrot self) -> jamminglistrot"""
        return _sim2d._jamminglistrot_front(self)

    def back(self) -> "list< jamminglistrot >::value_type const &" :
        """back(_jamminglistrot self) -> jamminglistrot"""
        return _sim2d._jamminglistrot_back(self)

    def assign(self, *args) -> "void" :
        """assign(_jamminglistrot self, list< jamminglistrot >::size_type n, jamminglistrot x)"""
        return _sim2d._jamminglistrot_assign(self, *args)

    def resize(self, *args) -> "void" :
        """
        resize(_jamminglistrot self, list< jamminglistrot >::size_type new_size)
        resize(_jamminglistrot self, list< jamminglistrot >::size_type new_size, jamminglistrot x)
        """
        return _sim2d._jamminglistrot_resize(self, *args)

    def insert(self, *args) -> "void" :
        """
        insert(_jamminglistrot self, list< jamminglistrot >::iterator pos, jamminglistrot x) -> list< jamminglistrot >::iterator
        insert(_jamminglistrot self, list< jamminglistrot >::iterator pos, list< jamminglistrot >::size_type n, jamminglistrot x)
        """
        return _sim2d._jamminglistrot_insert(self, *args)

    def pop_front(self) -> "void" :
        """pop_front(_jamminglistrot self)"""
        return _sim2d._jamminglistrot_pop_front(self)

    def push_front(self, *args) -> "void" :
        """push_front(_jamminglistrot self, jamminglistrot x)"""
        return _sim2d._jamminglistrot_push_front(self, *args)

    def reverse(self) -> "void" :
        """reverse(_jamminglistrot self)"""
        return _sim2d._jamminglistrot_reverse(self)

    __swig_destroy__ = _sim2d.delete__jamminglistrot
    __del__ = lambda self : None;
_jamminglistrot_swigregister = _sim2d._jamminglistrot_swigregister
_jamminglistrot_swigregister(_jamminglistrot)

class Pair(_Nvector2):
    """Proxy of C++ Numvector<(double,2)> class"""
    __swig_setmethods__ = {}
    for _s in [_Nvector2]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Pair, name, value)
    __swig_getmethods__ = {}
    for _s in [_Nvector2]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Pair, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(Numvector<(double,2)> self) -> Pair
        __init__(Numvector<(double,2)> self, _Nvector2 rhs) -> Pair
        __init__(Numvector<(double,2)> self, double const [2] rhs) -> Pair
        """
        this = _sim2d.new_Pair(*args)
        try: self.this.append(this)
        except: self.this = this
    def dot(self, *args) -> "double" :
        """dot(Pair self, _Numvector2 other) -> double"""
        return _sim2d.Pair_dot(self, *args)

    def sq(self) -> "double" :
        """sq(Pair self) -> double"""
        return _sim2d.Pair_sq(self)

    def mag(self) -> "double" :
        """mag(Pair self) -> double"""
        return _sim2d.Pair_mag(self)

    def distance(self, *args) -> "double" :
        """distance(Pair self, _Numvector2 rhs) -> double"""
        return _sim2d.Pair_distance(self, *args)

    def perpto(self, *args) -> "Numvector< double,2 >" :
        """perpto(Pair self, _Numvector2 other) -> _Numvector2"""
        return _sim2d.Pair_perpto(self, *args)

    def normalize(self) -> "void" :
        """normalize(Pair self)"""
        return _sim2d.Pair_normalize(self)

    def norm(self) -> "Numvector< double,2 >" :
        """norm(Pair self) -> _Numvector2"""
        return _sim2d.Pair_norm(self)

    __swig_destroy__ = _sim2d.delete_Pair
    __del__ = lambda self : None;
Pair_swigregister = _sim2d.Pair_swigregister
Pair_swigregister(Pair)

class VecPair(_object):
    """Proxy of C++ Nvector<(Vec,2)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VecPair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VecPair, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(Nvector<(Vec,2)> self) -> VecPair
        __init__(Nvector<(Vec,2)> self, VecPair rhs) -> VecPair
        __init__(Nvector<(Vec,2)> self, Vec locs) -> VecPair
        """
        this = _sim2d.new_VecPair(*args)
        try: self.this.append(this)
        except: self.this = this
    def get(self, *args) -> "Vec const &" :
        """get(VecPair self, unsigned int const n) -> Vec"""
        return _sim2d.VecPair_get(self, *args)

    def set(self, *args) -> "void" :
        """set(VecPair self, unsigned int const n, Vec a)"""
        return _sim2d.VecPair_set(self, *args)

    def len(self) -> "unsigned int" :
        """len(VecPair self) -> unsigned int"""
        return _sim2d.VecPair_len(self)

    def __iadd__(self, *args) -> "Nvector< Vec,2 > &" :
        """__iadd__(VecPair self, VecPair rhs) -> VecPair"""
        return _sim2d.VecPair___iadd__(self, *args)

    def __isub__(self, *args) -> "Nvector< Vec,2 > &" :
        """__isub__(VecPair self, VecPair rhs) -> VecPair"""
        return _sim2d.VecPair___isub__(self, *args)

    def __neg__(self) -> "Nvector< Vec,2 >" :
        """__neg__(VecPair self) -> VecPair"""
        return _sim2d.VecPair___neg__(self)

    def __add__(self, *args) -> "Nvector< Vec,2 >" :
        """__add__(VecPair self, VecPair rhs) -> VecPair"""
        return _sim2d.VecPair___add__(self, *args)

    def __sub__(self, *args) -> "Nvector< Vec,2 >" :
        """__sub__(VecPair self, VecPair rhs) -> VecPair"""
        return _sim2d.VecPair___sub__(self, *args)

    def begin(self) -> "Vec *" :
        """begin(VecPair self) -> Vec"""
        return _sim2d.VecPair_begin(self)

    def end(self) -> "Vec *" :
        """end(VecPair self) -> Vec"""
        return _sim2d.VecPair_end(self)

    __swig_destroy__ = _sim2d.delete_VecPair
    __del__ = lambda self : None;
    def __mul__(self, *args) -> "Nvector< Vec,2 >" :
        """__mul__(VecPair self, double const rhs) -> VecPair"""
        return _sim2d.VecPair___mul__(self, *args)

    def __div__(self, *args) -> "Nvector< Vec,2 >" :
        """__div__(VecPair self, double const rhs) -> VecPair"""
        return _sim2d.VecPair___div__(self, *args)

    def __truediv__(self, *args) -> "Nvector< Vec,2 >" :
        """__truediv__(VecPair self, double const n) -> VecPair"""
        return _sim2d.VecPair___truediv__(self, *args)

    def __getitem__(self, *args) -> "Vec" :
        """__getitem__(VecPair self, unsigned int const n) -> Vec"""
        return _sim2d.VecPair___getitem__(self, *args)

    def __setitem__(self, *args) -> "void" :
        """__setitem__(VecPair self, unsigned int const n, Vec val)"""
        return _sim2d.VecPair___setitem__(self, *args)

    def __len__(self) -> "unsigned int" :
        """__len__(VecPair self) -> unsigned int"""
        return _sim2d.VecPair___len__(self)

    #~ def __setitem__(self, n, val):
        #~ return self.set(n, val)

    def __iter__(self):
        for i in range(len(self)):
            yield self.get(i)

    #~ def __len__(self):
        #~ return self.len()

VecPair_swigregister = _sim2d.VecPair_swigregister
VecPair_swigregister(VecPair)

class _atomarray2(_object):
    """Proxy of C++ array<(p.atom,2)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _atomarray2, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _atomarray2, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(array<(p.atom,2)> self) -> _atomarray2
        __init__(array<(p.atom,2)> self, _atomarray2 rhs) -> _atomarray2
        __init__(array<(p.atom,2)> self, atom *const [2] locs) -> _atomarray2
        """
        this = _sim2d.new__atomarray2(*args)
        try: self.this.append(this)
        except: self.this = this
    def get(self, *args) -> "atom *const &" :
        """get(_atomarray2 self, unsigned int const n) -> atom"""
        return _sim2d._atomarray2_get(self, *args)

    def set(self, *args) -> "void" :
        """set(_atomarray2 self, unsigned int const n, atom a)"""
        return _sim2d._atomarray2_set(self, *args)

    def len(self) -> "unsigned int" :
        """len(_atomarray2 self) -> unsigned int"""
        return _sim2d._atomarray2_len(self)

    def begin(self) -> "atom **" :
        """begin(_atomarray2 self) -> atom **"""
        return _sim2d._atomarray2_begin(self)

    def end(self) -> "atom **" :
        """end(_atomarray2 self) -> atom **"""
        return _sim2d._atomarray2_end(self)

    __swig_destroy__ = _sim2d.delete__atomarray2
    __del__ = lambda self : None;
_atomarray2_swigregister = _sim2d._atomarray2_swigregister
_atomarray2_swigregister(_atomarray2)

class _idarray2(_object):
    """Proxy of C++ array<(atomid,2)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _idarray2, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _idarray2, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(array<(atomid,2)> self) -> _idarray2
        __init__(array<(atomid,2)> self, _idarray2 rhs) -> _idarray2
        __init__(array<(atomid,2)> self, atomid locs) -> _idarray2
        """
        this = _sim2d.new__idarray2(*args)
        try: self.this.append(this)
        except: self.this = this
    def get(self, *args) -> "atomid const &" :
        """get(_idarray2 self, unsigned int const n) -> atomid"""
        return _sim2d._idarray2_get(self, *args)

    def set(self, *args) -> "void" :
        """set(_idarray2 self, unsigned int const n, atomid a)"""
        return _sim2d._idarray2_set(self, *args)

    def len(self) -> "unsigned int" :
        """len(_idarray2 self) -> unsigned int"""
        return _sim2d._idarray2_len(self)

    def begin(self) -> "atomid *" :
        """begin(_idarray2 self) -> atomid"""
        return _sim2d._idarray2_begin(self)

    def end(self) -> "atomid *" :
        """end(_idarray2 self) -> atomid"""
        return _sim2d._idarray2_end(self)

    __swig_destroy__ = _sim2d.delete__idarray2
    __del__ = lambda self : None;
_idarray2_swigregister = _sim2d._idarray2_swigregister
_idarray2_swigregister(_idarray2)

class _atomarray3(_object):
    """Proxy of C++ array<(p.atom,3)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _atomarray3, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _atomarray3, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(array<(p.atom,3)> self) -> _atomarray3
        __init__(array<(p.atom,3)> self, _atomarray3 rhs) -> _atomarray3
        __init__(array<(p.atom,3)> self, atom *const [3] locs) -> _atomarray3
        """
        this = _sim2d.new__atomarray3(*args)
        try: self.this.append(this)
        except: self.this = this
    def get(self, *args) -> "atom *const &" :
        """get(_atomarray3 self, unsigned int const n) -> atom"""
        return _sim2d._atomarray3_get(self, *args)

    def set(self, *args) -> "void" :
        """set(_atomarray3 self, unsigned int const n, atom a)"""
        return _sim2d._atomarray3_set(self, *args)

    def len(self) -> "unsigned int" :
        """len(_atomarray3 self) -> unsigned int"""
        return _sim2d._atomarray3_len(self)

    def begin(self) -> "atom **" :
        """begin(_atomarray3 self) -> atom **"""
        return _sim2d._atomarray3_begin(self)

    def end(self) -> "atom **" :
        """end(_atomarray3 self) -> atom **"""
        return _sim2d._atomarray3_end(self)

    __swig_destroy__ = _sim2d.delete__atomarray3
    __del__ = lambda self : None;
_atomarray3_swigregister = _sim2d._atomarray3_swigregister
_atomarray3_swigregister(_atomarray3)

class _atomarray4(_object):
    """Proxy of C++ array<(p.atom,4)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _atomarray4, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _atomarray4, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(array<(p.atom,4)> self) -> _atomarray4
        __init__(array<(p.atom,4)> self, _atomarray4 rhs) -> _atomarray4
        __init__(array<(p.atom,4)> self, atom *const [4] locs) -> _atomarray4
        """
        this = _sim2d.new__atomarray4(*args)
        try: self.this.append(this)
        except: self.this = this
    def get(self, *args) -> "atom *const &" :
        """get(_atomarray4 self, unsigned int const n) -> atom"""
        return _sim2d._atomarray4_get(self, *args)

    def set(self, *args) -> "void" :
        """set(_atomarray4 self, unsigned int const n, atom a)"""
        return _sim2d._atomarray4_set(self, *args)

    def len(self) -> "unsigned int" :
        """len(_atomarray4 self) -> unsigned int"""
        return _sim2d._atomarray4_len(self)

    def begin(self) -> "atom **" :
        """begin(_atomarray4 self) -> atom **"""
        return _sim2d._atomarray4_begin(self)

    def end(self) -> "atom **" :
        """end(_atomarray4 self) -> atom **"""
        return _sim2d._atomarray4_end(self)

    __swig_destroy__ = _sim2d.delete__atomarray4
    __del__ = lambda self : None;
_atomarray4_swigregister = _sim2d._atomarray4_swigregister
_atomarray4_swigregister(_atomarray4)

class fvector(collections.MutableSequence):
    """Proxy of C++ vector<(double)> class"""
    __swig_setmethods__ = {}
    for _s in [collections.MutableSequence]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, fvector, name, value)
    __swig_getmethods__ = {}
    for _s in [collections.MutableSequence]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, fvector, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" :
        """iterator(fvector self) -> SwigPyIterator"""
        return _sim2d.fvector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" :
        """__nonzero__(fvector self) -> bool"""
        return _sim2d.fvector___nonzero__(self)

    def __bool__(self) -> "bool" :
        """__bool__(fvector self) -> bool"""
        return _sim2d.fvector___bool__(self)

    def __len__(self) -> "vector< double >::size_type" :
        """__len__(fvector self) -> vector< double >::size_type"""
        return _sim2d.fvector___len__(self)

    def pop(self) -> "vector< double >::value_type" :
        """pop(fvector self) -> vector< double >::value_type"""
        return _sim2d.fvector_pop(self)

    def __getslice__(self, *args) -> "std::vector< double,std::allocator< double > > *" :
        """__getslice__(fvector self, vector< double >::difference_type i, vector< double >::difference_type j) -> std::vector< double,std::allocator< double > > *"""
        return _sim2d.fvector___getslice__(self, *args)

    def __setslice__(self, *args) -> "void" :
        """
        __setslice__(fvector self, vector< double >::difference_type i, vector< double >::difference_type j, std::vector< double,std::allocator< double > > const & v=std::vector< double,std::allocator< double > >())
        __setslice__(fvector self, vector< double >::difference_type i, vector< double >::difference_type j)
        """
        return _sim2d.fvector___setslice__(self, *args)

    def __delslice__(self, *args) -> "void" :
        """__delslice__(fvector self, vector< double >::difference_type i, vector< double >::difference_type j)"""
        return _sim2d.fvector___delslice__(self, *args)

    def __delitem__(self, *args) -> "void" :
        """
        __delitem__(fvector self, vector< double >::difference_type i)
        __delitem__(fvector self, PySliceObject * slice)
        """
        return _sim2d.fvector___delitem__(self, *args)

    def __getitem__(self, *args) -> "vector< double >::value_type const &" :
        """
        __getitem__(fvector self, PySliceObject * slice) -> std::vector< double,std::allocator< double > >
        __getitem__(fvector self, vector< double >::difference_type i) -> vector< double >::value_type const &
        """
        return _sim2d.fvector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void" :
        """
        __setitem__(fvector self, PySliceObject * slice, std::vector< double,std::allocator< double > > const & v)
        __setitem__(fvector self, PySliceObject * slice)
        __setitem__(fvector self, vector< double >::difference_type i, vector< double >::value_type const & x)
        """
        return _sim2d.fvector___setitem__(self, *args)

    def append(self, *args) -> "void" :
        """append(fvector self, vector< double >::value_type const & x)"""
        return _sim2d.fvector_append(self, *args)

    def empty(self) -> "bool" :
        """empty(fvector self) -> bool"""
        return _sim2d.fvector_empty(self)

    def size(self) -> "vector< double >::size_type" :
        """size(fvector self) -> vector< double >::size_type"""
        return _sim2d.fvector_size(self)

    def clear(self) -> "void" :
        """clear(fvector self)"""
        return _sim2d.fvector_clear(self)

    def swap(self, *args) -> "void" :
        """swap(fvector self, fvector v)"""
        return _sim2d.fvector_swap(self, *args)

    def get_allocator(self) -> "vector< double >::allocator_type" :
        """get_allocator(fvector self) -> vector< double >::allocator_type"""
        return _sim2d.fvector_get_allocator(self)

    def begin(self) -> "vector< double >::iterator" :
        """begin(fvector self) -> vector< double >::iterator"""
        return _sim2d.fvector_begin(self)

    def end(self) -> "vector< double >::iterator" :
        """end(fvector self) -> vector< double >::iterator"""
        return _sim2d.fvector_end(self)

    def rbegin(self) -> "vector< double >::reverse_iterator" :
        """rbegin(fvector self) -> vector< double >::reverse_iterator"""
        return _sim2d.fvector_rbegin(self)

    def rend(self) -> "vector< double >::reverse_iterator" :
        """rend(fvector self) -> vector< double >::reverse_iterator"""
        return _sim2d.fvector_rend(self)

    def pop_back(self) -> "void" :
        """pop_back(fvector self)"""
        return _sim2d.fvector_pop_back(self)

    def erase(self, *args) -> "vector< double >::iterator" :
        """
        erase(fvector self, vector< double >::iterator pos) -> vector< double >::iterator
        erase(fvector self, vector< double >::iterator first, vector< double >::iterator last) -> vector< double >::iterator
        """
        return _sim2d.fvector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(vector<(double)> self) -> fvector
        __init__(vector<(double)> self, fvector arg2) -> fvector
        __init__(vector<(double)> self, vector< double >::size_type size) -> fvector
        __init__(vector<(double)> self, vector< double >::size_type size, vector< double >::value_type const & value) -> fvector
        """
        this = _sim2d.new_fvector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" :
        """push_back(fvector self, vector< double >::value_type const & x)"""
        return _sim2d.fvector_push_back(self, *args)

    def front(self) -> "vector< double >::value_type const &" :
        """front(fvector self) -> vector< double >::value_type const &"""
        return _sim2d.fvector_front(self)

    def back(self) -> "vector< double >::value_type const &" :
        """back(fvector self) -> vector< double >::value_type const &"""
        return _sim2d.fvector_back(self)

    def assign(self, *args) -> "void" :
        """assign(fvector self, vector< double >::size_type n, vector< double >::value_type const & x)"""
        return _sim2d.fvector_assign(self, *args)

    def resize(self, *args) -> "void" :
        """
        resize(fvector self, vector< double >::size_type new_size)
        resize(fvector self, vector< double >::size_type new_size, vector< double >::value_type const & x)
        """
        return _sim2d.fvector_resize(self, *args)

    def insert(self, *args) -> "void" :
        """
        insert(fvector self, vector< double >::iterator pos, vector< double >::value_type const & x) -> vector< double >::iterator
        insert(fvector self, vector< double >::iterator pos, vector< double >::size_type n, vector< double >::value_type const & x)
        """
        return _sim2d.fvector_insert(self, *args)

    def reserve(self, *args) -> "void" :
        """reserve(fvector self, vector< double >::size_type n)"""
        return _sim2d.fvector_reserve(self, *args)

    def capacity(self) -> "vector< double >::size_type" :
        """capacity(fvector self) -> vector< double >::size_type"""
        return _sim2d.fvector_capacity(self)

    __swig_destroy__ = _sim2d.delete_fvector
    __del__ = lambda self : None;
fvector_swigregister = _sim2d.fvector_swigregister
fvector_swigregister(fvector)

class avector(_object):
    """Proxy of C++ vector<(p.atomgroup)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, avector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, avector, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" :
        """iterator(avector self) -> SwigPyIterator"""
        return _sim2d.avector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" :
        """__nonzero__(avector self) -> bool"""
        return _sim2d.avector___nonzero__(self)

    def __bool__(self) -> "bool" :
        """__bool__(avector self) -> bool"""
        return _sim2d.avector___bool__(self)

    def __len__(self) -> "vector< atomgroup * >::size_type" :
        """__len__(avector self) -> vector< atomgroup * >::size_type"""
        return _sim2d.avector___len__(self)

    def pop(self) -> "vector< atomgroup * >::value_type" :
        """pop(avector self) -> atomgroup"""
        return _sim2d.avector_pop(self)

    def __getslice__(self, *args) -> "std::vector< atomgroup *,std::allocator< atomgroup * > > *" :
        """__getslice__(avector self, vector< atomgroup * >::difference_type i, vector< atomgroup * >::difference_type j) -> std::vector< atomgroup *,std::allocator< atomgroup * > > *"""
        return _sim2d.avector___getslice__(self, *args)

    def __setslice__(self, *args) -> "void" :
        """
        __setslice__(avector self, vector< atomgroup * >::difference_type i, vector< atomgroup * >::difference_type j, 
            std::vector< atomgroup *,std::allocator< atomgroup * > > const & v=std::vector< atomgroup *,std::allocator< atomgroup * > >())
        __setslice__(avector self, vector< atomgroup * >::difference_type i, vector< atomgroup * >::difference_type j)
        """
        return _sim2d.avector___setslice__(self, *args)

    def __delslice__(self, *args) -> "void" :
        """__delslice__(avector self, vector< atomgroup * >::difference_type i, vector< atomgroup * >::difference_type j)"""
        return _sim2d.avector___delslice__(self, *args)

    def __delitem__(self, *args) -> "void" :
        """
        __delitem__(avector self, vector< atomgroup * >::difference_type i)
        __delitem__(avector self, PySliceObject * slice)
        """
        return _sim2d.avector___delitem__(self, *args)

    def __getitem__(self, *args) -> "vector< atomgroup * >::value_type" :
        """
        __getitem__(avector self, PySliceObject * slice) -> std::vector< atomgroup *,std::allocator< atomgroup * > >
        __getitem__(avector self, vector< atomgroup * >::difference_type i) -> atomgroup
        """
        return _sim2d.avector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void" :
        """
        __setitem__(avector self, PySliceObject * slice, std::vector< atomgroup *,std::allocator< atomgroup * > > const & v)
        __setitem__(avector self, PySliceObject * slice)
        __setitem__(avector self, vector< atomgroup * >::difference_type i, atomgroup x)
        """
        return _sim2d.avector___setitem__(self, *args)

    def append(self, *args) -> "void" :
        """append(avector self, atomgroup x)"""
        return _sim2d.avector_append(self, *args)

    def empty(self) -> "bool" :
        """empty(avector self) -> bool"""
        return _sim2d.avector_empty(self)

    def size(self) -> "vector< atomgroup * >::size_type" :
        """size(avector self) -> vector< atomgroup * >::size_type"""
        return _sim2d.avector_size(self)

    def clear(self) -> "void" :
        """clear(avector self)"""
        return _sim2d.avector_clear(self)

    def swap(self, *args) -> "void" :
        """swap(avector self, avector v)"""
        return _sim2d.avector_swap(self, *args)

    def get_allocator(self) -> "vector< atomgroup * >::allocator_type" :
        """get_allocator(avector self) -> vector< atomgroup * >::allocator_type"""
        return _sim2d.avector_get_allocator(self)

    def begin(self) -> "vector< atomgroup * >::iterator" :
        """begin(avector self) -> vector< atomgroup * >::iterator"""
        return _sim2d.avector_begin(self)

    def end(self) -> "vector< atomgroup * >::iterator" :
        """end(avector self) -> vector< atomgroup * >::iterator"""
        return _sim2d.avector_end(self)

    def rbegin(self) -> "vector< atomgroup * >::reverse_iterator" :
        """rbegin(avector self) -> vector< atomgroup * >::reverse_iterator"""
        return _sim2d.avector_rbegin(self)

    def rend(self) -> "vector< atomgroup * >::reverse_iterator" :
        """rend(avector self) -> vector< atomgroup * >::reverse_iterator"""
        return _sim2d.avector_rend(self)

    def pop_back(self) -> "void" :
        """pop_back(avector self)"""
        return _sim2d.avector_pop_back(self)

    def erase(self, *args) -> "vector< atomgroup * >::iterator" :
        """
        erase(avector self, vector< atomgroup * >::iterator pos) -> vector< atomgroup * >::iterator
        erase(avector self, vector< atomgroup * >::iterator first, vector< atomgroup * >::iterator last) -> vector< atomgroup * >::iterator
        """
        return _sim2d.avector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(vector<(p.atomgroup)> self) -> avector
        __init__(vector<(p.atomgroup)> self, avector arg2) -> avector
        __init__(vector<(p.atomgroup)> self, vector< atomgroup * >::size_type size) -> avector
        __init__(vector<(p.atomgroup)> self, vector< atomgroup * >::size_type size, atomgroup value) -> avector
        """
        this = _sim2d.new_avector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" :
        """push_back(avector self, atomgroup x)"""
        return _sim2d.avector_push_back(self, *args)

    def front(self) -> "vector< atomgroup * >::value_type" :
        """front(avector self) -> atomgroup"""
        return _sim2d.avector_front(self)

    def back(self) -> "vector< atomgroup * >::value_type" :
        """back(avector self) -> atomgroup"""
        return _sim2d.avector_back(self)

    def assign(self, *args) -> "void" :
        """assign(avector self, vector< atomgroup * >::size_type n, atomgroup x)"""
        return _sim2d.avector_assign(self, *args)

    def resize(self, *args) -> "void" :
        """
        resize(avector self, vector< atomgroup * >::size_type new_size)
        resize(avector self, vector< atomgroup * >::size_type new_size, atomgroup x)
        """
        return _sim2d.avector_resize(self, *args)

    def insert(self, *args) -> "void" :
        """
        insert(avector self, vector< atomgroup * >::iterator pos, atomgroup x) -> vector< atomgroup * >::iterator
        insert(avector self, vector< atomgroup * >::iterator pos, vector< atomgroup * >::size_type n, atomgroup x)
        """
        return _sim2d.avector_insert(self, *args)

    def reserve(self, *args) -> "void" :
        """reserve(avector self, vector< atomgroup * >::size_type n)"""
        return _sim2d.avector_reserve(self, *args)

    def capacity(self) -> "vector< atomgroup * >::size_type" :
        """capacity(avector self) -> vector< atomgroup * >::size_type"""
        return _sim2d.avector_capacity(self)

    __swig_destroy__ = _sim2d.delete_avector
    __del__ = lambda self : None;
avector_swigregister = _sim2d.avector_swigregister
avector_swigregister(avector)

class ivector(_object):
    """Proxy of C++ vector<(p.interaction)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ivector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ivector, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" :
        """iterator(ivector self) -> SwigPyIterator"""
        return _sim2d.ivector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" :
        """__nonzero__(ivector self) -> bool"""
        return _sim2d.ivector___nonzero__(self)

    def __bool__(self) -> "bool" :
        """__bool__(ivector self) -> bool"""
        return _sim2d.ivector___bool__(self)

    def __len__(self) -> "vector< interaction * >::size_type" :
        """__len__(ivector self) -> vector< interaction * >::size_type"""
        return _sim2d.ivector___len__(self)

    def pop(self) -> "vector< interaction * >::value_type" :
        """pop(ivector self) -> interaction"""
        return _sim2d.ivector_pop(self)

    def __getslice__(self, *args) -> "std::vector< interaction *,std::allocator< interaction * > > *" :
        """__getslice__(ivector self, vector< interaction * >::difference_type i, vector< interaction * >::difference_type j) -> std::vector< interaction *,std::allocator< interaction * > > *"""
        return _sim2d.ivector___getslice__(self, *args)

    def __setslice__(self, *args) -> "void" :
        """
        __setslice__(ivector self, vector< interaction * >::difference_type i, vector< interaction * >::difference_type j, 
            std::vector< interaction *,std::allocator< interaction * > > const & v=std::vector< interaction *,std::allocator< interaction * > >())
        __setslice__(ivector self, vector< interaction * >::difference_type i, vector< interaction * >::difference_type j)
        """
        return _sim2d.ivector___setslice__(self, *args)

    def __delslice__(self, *args) -> "void" :
        """__delslice__(ivector self, vector< interaction * >::difference_type i, vector< interaction * >::difference_type j)"""
        return _sim2d.ivector___delslice__(self, *args)

    def __delitem__(self, *args) -> "void" :
        """
        __delitem__(ivector self, vector< interaction * >::difference_type i)
        __delitem__(ivector self, PySliceObject * slice)
        """
        return _sim2d.ivector___delitem__(self, *args)

    def __getitem__(self, *args) -> "vector< interaction * >::value_type" :
        """
        __getitem__(ivector self, PySliceObject * slice) -> std::vector< interaction *,std::allocator< interaction * > >
        __getitem__(ivector self, vector< interaction * >::difference_type i) -> interaction
        """
        return _sim2d.ivector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void" :
        """
        __setitem__(ivector self, PySliceObject * slice, std::vector< interaction *,std::allocator< interaction * > > const & v)
        __setitem__(ivector self, PySliceObject * slice)
        __setitem__(ivector self, vector< interaction * >::difference_type i, interaction x)
        """
        return _sim2d.ivector___setitem__(self, *args)

    def append(self, *args) -> "void" :
        """append(ivector self, interaction x)"""
        return _sim2d.ivector_append(self, *args)

    def empty(self) -> "bool" :
        """empty(ivector self) -> bool"""
        return _sim2d.ivector_empty(self)

    def size(self) -> "vector< interaction * >::size_type" :
        """size(ivector self) -> vector< interaction * >::size_type"""
        return _sim2d.ivector_size(self)

    def clear(self) -> "void" :
        """clear(ivector self)"""
        return _sim2d.ivector_clear(self)

    def swap(self, *args) -> "void" :
        """swap(ivector self, ivector v)"""
        return _sim2d.ivector_swap(self, *args)

    def get_allocator(self) -> "vector< interaction * >::allocator_type" :
        """get_allocator(ivector self) -> vector< interaction * >::allocator_type"""
        return _sim2d.ivector_get_allocator(self)

    def begin(self) -> "vector< interaction * >::iterator" :
        """begin(ivector self) -> vector< interaction * >::iterator"""
        return _sim2d.ivector_begin(self)

    def end(self) -> "vector< interaction * >::iterator" :
        """end(ivector self) -> vector< interaction * >::iterator"""
        return _sim2d.ivector_end(self)

    def rbegin(self) -> "vector< interaction * >::reverse_iterator" :
        """rbegin(ivector self) -> vector< interaction * >::reverse_iterator"""
        return _sim2d.ivector_rbegin(self)

    def rend(self) -> "vector< interaction * >::reverse_iterator" :
        """rend(ivector self) -> vector< interaction * >::reverse_iterator"""
        return _sim2d.ivector_rend(self)

    def pop_back(self) -> "void" :
        """pop_back(ivector self)"""
        return _sim2d.ivector_pop_back(self)

    def erase(self, *args) -> "vector< interaction * >::iterator" :
        """
        erase(ivector self, vector< interaction * >::iterator pos) -> vector< interaction * >::iterator
        erase(ivector self, vector< interaction * >::iterator first, vector< interaction * >::iterator last) -> vector< interaction * >::iterator
        """
        return _sim2d.ivector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(vector<(p.interaction)> self) -> ivector
        __init__(vector<(p.interaction)> self, ivector arg2) -> ivector
        __init__(vector<(p.interaction)> self, vector< interaction * >::size_type size) -> ivector
        __init__(vector<(p.interaction)> self, vector< interaction * >::size_type size, interaction value) -> ivector
        """
        this = _sim2d.new_ivector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" :
        """push_back(ivector self, interaction x)"""
        return _sim2d.ivector_push_back(self, *args)

    def front(self) -> "vector< interaction * >::value_type" :
        """front(ivector self) -> interaction"""
        return _sim2d.ivector_front(self)

    def back(self) -> "vector< interaction * >::value_type" :
        """back(ivector self) -> interaction"""
        return _sim2d.ivector_back(self)

    def assign(self, *args) -> "void" :
        """assign(ivector self, vector< interaction * >::size_type n, interaction x)"""
        return _sim2d.ivector_assign(self, *args)

    def resize(self, *args) -> "void" :
        """
        resize(ivector self, vector< interaction * >::size_type new_size)
        resize(ivector self, vector< interaction * >::size_type new_size, interaction x)
        """
        return _sim2d.ivector_resize(self, *args)

    def insert(self, *args) -> "void" :
        """
        insert(ivector self, vector< interaction * >::iterator pos, interaction x) -> vector< interaction * >::iterator
        insert(ivector self, vector< interaction * >::iterator pos, vector< interaction * >::size_type n, interaction x)
        """
        return _sim2d.ivector_insert(self, *args)

    def reserve(self, *args) -> "void" :
        """reserve(ivector self, vector< interaction * >::size_type n)"""
        return _sim2d.ivector_reserve(self, *args)

    def capacity(self) -> "vector< interaction * >::size_type" :
        """capacity(ivector self) -> vector< interaction * >::size_type"""
        return _sim2d.ivector_capacity(self)

    __swig_destroy__ = _sim2d.delete_ivector
    __del__ = lambda self : None;
ivector_swigregister = _sim2d.ivector_swigregister
ivector_swigregister(ivector)

class ifxvector(_object):
    """Proxy of C++ vector<(p.interactionpairsx)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ifxvector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ifxvector, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" :
        """iterator(ifxvector self) -> SwigPyIterator"""
        return _sim2d.ifxvector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" :
        """__nonzero__(ifxvector self) -> bool"""
        return _sim2d.ifxvector___nonzero__(self)

    def __bool__(self) -> "bool" :
        """__bool__(ifxvector self) -> bool"""
        return _sim2d.ifxvector___bool__(self)

    def __len__(self) -> "vector< interactionpairsx * >::size_type" :
        """__len__(ifxvector self) -> vector< interactionpairsx * >::size_type"""
        return _sim2d.ifxvector___len__(self)

    def pop(self) -> "vector< interactionpairsx * >::value_type" :
        """pop(ifxvector self) -> interactionpairsx"""
        return _sim2d.ifxvector_pop(self)

    def __getslice__(self, *args) -> "std::vector< interactionpairsx *,std::allocator< interactionpairsx * > > *" :
        """__getslice__(ifxvector self, vector< interactionpairsx * >::difference_type i, vector< interactionpairsx * >::difference_type j) -> std::vector< interactionpairsx *,std::allocator< interactionpairsx * > > *"""
        return _sim2d.ifxvector___getslice__(self, *args)

    def __setslice__(self, *args) -> "void" :
        """
        __setslice__(ifxvector self, vector< interactionpairsx * >::difference_type i, vector< interactionpairsx * >::difference_type j, 
            std::vector< interactionpairsx *,std::allocator< interactionpairsx * > > const & v=std::vector< interactionpairsx *,std::allocator< interactionpairsx * > >())
        __setslice__(ifxvector self, vector< interactionpairsx * >::difference_type i, vector< interactionpairsx * >::difference_type j)
        """
        return _sim2d.ifxvector___setslice__(self, *args)

    def __delslice__(self, *args) -> "void" :
        """__delslice__(ifxvector self, vector< interactionpairsx * >::difference_type i, vector< interactionpairsx * >::difference_type j)"""
        return _sim2d.ifxvector___delslice__(self, *args)

    def __delitem__(self, *args) -> "void" :
        """
        __delitem__(ifxvector self, vector< interactionpairsx * >::difference_type i)
        __delitem__(ifxvector self, PySliceObject * slice)
        """
        return _sim2d.ifxvector___delitem__(self, *args)

    def __getitem__(self, *args) -> "vector< interactionpairsx * >::value_type" :
        """
        __getitem__(ifxvector self, PySliceObject * slice) -> std::vector< interactionpairsx *,std::allocator< interactionpairsx * > >
        __getitem__(ifxvector self, vector< interactionpairsx * >::difference_type i) -> interactionpairsx
        """
        return _sim2d.ifxvector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void" :
        """
        __setitem__(ifxvector self, PySliceObject * slice, std::vector< interactionpairsx *,std::allocator< interactionpairsx * > > const & v)
        __setitem__(ifxvector self, PySliceObject * slice)
        __setitem__(ifxvector self, vector< interactionpairsx * >::difference_type i, interactionpairsx x)
        """
        return _sim2d.ifxvector___setitem__(self, *args)

    def append(self, *args) -> "void" :
        """append(ifxvector self, interactionpairsx x)"""
        return _sim2d.ifxvector_append(self, *args)

    def empty(self) -> "bool" :
        """empty(ifxvector self) -> bool"""
        return _sim2d.ifxvector_empty(self)

    def size(self) -> "vector< interactionpairsx * >::size_type" :
        """size(ifxvector self) -> vector< interactionpairsx * >::size_type"""
        return _sim2d.ifxvector_size(self)

    def clear(self) -> "void" :
        """clear(ifxvector self)"""
        return _sim2d.ifxvector_clear(self)

    def swap(self, *args) -> "void" :
        """swap(ifxvector self, ifxvector v)"""
        return _sim2d.ifxvector_swap(self, *args)

    def get_allocator(self) -> "vector< interactionpairsx * >::allocator_type" :
        """get_allocator(ifxvector self) -> vector< interactionpairsx * >::allocator_type"""
        return _sim2d.ifxvector_get_allocator(self)

    def begin(self) -> "vector< interactionpairsx * >::iterator" :
        """begin(ifxvector self) -> vector< interactionpairsx * >::iterator"""
        return _sim2d.ifxvector_begin(self)

    def end(self) -> "vector< interactionpairsx * >::iterator" :
        """end(ifxvector self) -> vector< interactionpairsx * >::iterator"""
        return _sim2d.ifxvector_end(self)

    def rbegin(self) -> "vector< interactionpairsx * >::reverse_iterator" :
        """rbegin(ifxvector self) -> vector< interactionpairsx * >::reverse_iterator"""
        return _sim2d.ifxvector_rbegin(self)

    def rend(self) -> "vector< interactionpairsx * >::reverse_iterator" :
        """rend(ifxvector self) -> vector< interactionpairsx * >::reverse_iterator"""
        return _sim2d.ifxvector_rend(self)

    def pop_back(self) -> "void" :
        """pop_back(ifxvector self)"""
        return _sim2d.ifxvector_pop_back(self)

    def erase(self, *args) -> "vector< interactionpairsx * >::iterator" :
        """
        erase(ifxvector self, vector< interactionpairsx * >::iterator pos) -> vector< interactionpairsx * >::iterator
        erase(ifxvector self, vector< interactionpairsx * >::iterator first, vector< interactionpairsx * >::iterator last) -> vector< interactionpairsx * >::iterator
        """
        return _sim2d.ifxvector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(vector<(p.interactionpairsx)> self) -> ifxvector
        __init__(vector<(p.interactionpairsx)> self, ifxvector arg2) -> ifxvector
        __init__(vector<(p.interactionpairsx)> self, vector< interactionpairsx * >::size_type size) -> ifxvector
        __init__(vector<(p.interactionpairsx)> self, vector< interactionpairsx * >::size_type size, interactionpairsx value) -> ifxvector
        """
        this = _sim2d.new_ifxvector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" :
        """push_back(ifxvector self, interactionpairsx x)"""
        return _sim2d.ifxvector_push_back(self, *args)

    def front(self) -> "vector< interactionpairsx * >::value_type" :
        """front(ifxvector self) -> interactionpairsx"""
        return _sim2d.ifxvector_front(self)

    def back(self) -> "vector< interactionpairsx * >::value_type" :
        """back(ifxvector self) -> interactionpairsx"""
        return _sim2d.ifxvector_back(self)

    def assign(self, *args) -> "void" :
        """assign(ifxvector self, vector< interactionpairsx * >::size_type n, interactionpairsx x)"""
        return _sim2d.ifxvector_assign(self, *args)

    def resize(self, *args) -> "void" :
        """
        resize(ifxvector self, vector< interactionpairsx * >::size_type new_size)
        resize(ifxvector self, vector< interactionpairsx * >::size_type new_size, interactionpairsx x)
        """
        return _sim2d.ifxvector_resize(self, *args)

    def insert(self, *args) -> "void" :
        """
        insert(ifxvector self, vector< interactionpairsx * >::iterator pos, interactionpairsx x) -> vector< interactionpairsx * >::iterator
        insert(ifxvector self, vector< interactionpairsx * >::iterator pos, vector< interactionpairsx * >::size_type n, 
            interactionpairsx x)
        """
        return _sim2d.ifxvector_insert(self, *args)

    def reserve(self, *args) -> "void" :
        """reserve(ifxvector self, vector< interactionpairsx * >::size_type n)"""
        return _sim2d.ifxvector_reserve(self, *args)

    def capacity(self) -> "vector< interactionpairsx * >::size_type" :
        """capacity(ifxvector self) -> vector< interactionpairsx * >::size_type"""
        return _sim2d.ifxvector_capacity(self)

    __swig_destroy__ = _sim2d.delete_ifxvector
    __del__ = lambda self : None;
ifxvector_swigregister = _sim2d.ifxvector_swigregister
ifxvector_swigregister(ifxvector)

class tvector(_object):
    """Proxy of C++ vector<(p.statetracker)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, tvector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, tvector, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" :
        """iterator(tvector self) -> SwigPyIterator"""
        return _sim2d.tvector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" :
        """__nonzero__(tvector self) -> bool"""
        return _sim2d.tvector___nonzero__(self)

    def __bool__(self) -> "bool" :
        """__bool__(tvector self) -> bool"""
        return _sim2d.tvector___bool__(self)

    def __len__(self) -> "vector< statetracker * >::size_type" :
        """__len__(tvector self) -> vector< statetracker * >::size_type"""
        return _sim2d.tvector___len__(self)

    def pop(self) -> "vector< statetracker * >::value_type" :
        """pop(tvector self) -> statetracker"""
        return _sim2d.tvector_pop(self)

    def __getslice__(self, *args) -> "std::vector< statetracker *,std::allocator< statetracker * > > *" :
        """__getslice__(tvector self, vector< statetracker * >::difference_type i, vector< statetracker * >::difference_type j) -> std::vector< statetracker *,std::allocator< statetracker * > > *"""
        return _sim2d.tvector___getslice__(self, *args)

    def __setslice__(self, *args) -> "void" :
        """
        __setslice__(tvector self, vector< statetracker * >::difference_type i, vector< statetracker * >::difference_type j, 
            std::vector< statetracker *,std::allocator< statetracker * > > const & v=std::vector< statetracker *,std::allocator< statetracker * > >())
        __setslice__(tvector self, vector< statetracker * >::difference_type i, vector< statetracker * >::difference_type j)
        """
        return _sim2d.tvector___setslice__(self, *args)

    def __delslice__(self, *args) -> "void" :
        """__delslice__(tvector self, vector< statetracker * >::difference_type i, vector< statetracker * >::difference_type j)"""
        return _sim2d.tvector___delslice__(self, *args)

    def __delitem__(self, *args) -> "void" :
        """
        __delitem__(tvector self, vector< statetracker * >::difference_type i)
        __delitem__(tvector self, PySliceObject * slice)
        """
        return _sim2d.tvector___delitem__(self, *args)

    def __getitem__(self, *args) -> "vector< statetracker * >::value_type" :
        """
        __getitem__(tvector self, PySliceObject * slice) -> std::vector< statetracker *,std::allocator< statetracker * > >
        __getitem__(tvector self, vector< statetracker * >::difference_type i) -> statetracker
        """
        return _sim2d.tvector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void" :
        """
        __setitem__(tvector self, PySliceObject * slice, std::vector< statetracker *,std::allocator< statetracker * > > const & v)
        __setitem__(tvector self, PySliceObject * slice)
        __setitem__(tvector self, vector< statetracker * >::difference_type i, statetracker x)
        """
        return _sim2d.tvector___setitem__(self, *args)

    def append(self, *args) -> "void" :
        """append(tvector self, statetracker x)"""
        return _sim2d.tvector_append(self, *args)

    def empty(self) -> "bool" :
        """empty(tvector self) -> bool"""
        return _sim2d.tvector_empty(self)

    def size(self) -> "vector< statetracker * >::size_type" :
        """size(tvector self) -> vector< statetracker * >::size_type"""
        return _sim2d.tvector_size(self)

    def clear(self) -> "void" :
        """clear(tvector self)"""
        return _sim2d.tvector_clear(self)

    def swap(self, *args) -> "void" :
        """swap(tvector self, tvector v)"""
        return _sim2d.tvector_swap(self, *args)

    def get_allocator(self) -> "vector< statetracker * >::allocator_type" :
        """get_allocator(tvector self) -> vector< statetracker * >::allocator_type"""
        return _sim2d.tvector_get_allocator(self)

    def begin(self) -> "vector< statetracker * >::iterator" :
        """begin(tvector self) -> vector< statetracker * >::iterator"""
        return _sim2d.tvector_begin(self)

    def end(self) -> "vector< statetracker * >::iterator" :
        """end(tvector self) -> vector< statetracker * >::iterator"""
        return _sim2d.tvector_end(self)

    def rbegin(self) -> "vector< statetracker * >::reverse_iterator" :
        """rbegin(tvector self) -> vector< statetracker * >::reverse_iterator"""
        return _sim2d.tvector_rbegin(self)

    def rend(self) -> "vector< statetracker * >::reverse_iterator" :
        """rend(tvector self) -> vector< statetracker * >::reverse_iterator"""
        return _sim2d.tvector_rend(self)

    def pop_back(self) -> "void" :
        """pop_back(tvector self)"""
        return _sim2d.tvector_pop_back(self)

    def erase(self, *args) -> "vector< statetracker * >::iterator" :
        """
        erase(tvector self, vector< statetracker * >::iterator pos) -> vector< statetracker * >::iterator
        erase(tvector self, vector< statetracker * >::iterator first, vector< statetracker * >::iterator last) -> vector< statetracker * >::iterator
        """
        return _sim2d.tvector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(vector<(p.statetracker)> self) -> tvector
        __init__(vector<(p.statetracker)> self, tvector arg2) -> tvector
        __init__(vector<(p.statetracker)> self, vector< statetracker * >::size_type size) -> tvector
        __init__(vector<(p.statetracker)> self, vector< statetracker * >::size_type size, statetracker value) -> tvector
        """
        this = _sim2d.new_tvector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" :
        """push_back(tvector self, statetracker x)"""
        return _sim2d.tvector_push_back(self, *args)

    def front(self) -> "vector< statetracker * >::value_type" :
        """front(tvector self) -> statetracker"""
        return _sim2d.tvector_front(self)

    def back(self) -> "vector< statetracker * >::value_type" :
        """back(tvector self) -> statetracker"""
        return _sim2d.tvector_back(self)

    def assign(self, *args) -> "void" :
        """assign(tvector self, vector< statetracker * >::size_type n, statetracker x)"""
        return _sim2d.tvector_assign(self, *args)

    def resize(self, *args) -> "void" :
        """
        resize(tvector self, vector< statetracker * >::size_type new_size)
        resize(tvector self, vector< statetracker * >::size_type new_size, statetracker x)
        """
        return _sim2d.tvector_resize(self, *args)

    def insert(self, *args) -> "void" :
        """
        insert(tvector self, vector< statetracker * >::iterator pos, statetracker x) -> vector< statetracker * >::iterator
        insert(tvector self, vector< statetracker * >::iterator pos, vector< statetracker * >::size_type n, statetracker x)
        """
        return _sim2d.tvector_insert(self, *args)

    def reserve(self, *args) -> "void" :
        """reserve(tvector self, vector< statetracker * >::size_type n)"""
        return _sim2d.tvector_reserve(self, *args)

    def capacity(self) -> "vector< statetracker * >::size_type" :
        """capacity(tvector self) -> vector< statetracker * >::size_type"""
        return _sim2d.tvector_capacity(self)

    __swig_destroy__ = _sim2d.delete_tvector
    __del__ = lambda self : None;
tvector_swigregister = _sim2d.tvector_swigregister
tvector_swigregister(tvector)

class constraintvector(_object):
    """Proxy of C++ vector<(p.constraint)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, constraintvector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, constraintvector, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" :
        """iterator(constraintvector self) -> SwigPyIterator"""
        return _sim2d.constraintvector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" :
        """__nonzero__(constraintvector self) -> bool"""
        return _sim2d.constraintvector___nonzero__(self)

    def __bool__(self) -> "bool" :
        """__bool__(constraintvector self) -> bool"""
        return _sim2d.constraintvector___bool__(self)

    def __len__(self) -> "vector< constraint * >::size_type" :
        """__len__(constraintvector self) -> vector< constraint * >::size_type"""
        return _sim2d.constraintvector___len__(self)

    def pop(self) -> "vector< constraint * >::value_type" :
        """pop(constraintvector self) -> constraint"""
        return _sim2d.constraintvector_pop(self)

    def __getslice__(self, *args) -> "std::vector< constraint *,std::allocator< constraint * > > *" :
        """__getslice__(constraintvector self, vector< constraint * >::difference_type i, vector< constraint * >::difference_type j) -> std::vector< constraint *,std::allocator< constraint * > > *"""
        return _sim2d.constraintvector___getslice__(self, *args)

    def __setslice__(self, *args) -> "void" :
        """
        __setslice__(constraintvector self, vector< constraint * >::difference_type i, vector< constraint * >::difference_type j, 
            std::vector< constraint *,std::allocator< constraint * > > const & v=std::vector< constraint *,std::allocator< constraint * > >())
        __setslice__(constraintvector self, vector< constraint * >::difference_type i, vector< constraint * >::difference_type j)
        """
        return _sim2d.constraintvector___setslice__(self, *args)

    def __delslice__(self, *args) -> "void" :
        """__delslice__(constraintvector self, vector< constraint * >::difference_type i, vector< constraint * >::difference_type j)"""
        return _sim2d.constraintvector___delslice__(self, *args)

    def __delitem__(self, *args) -> "void" :
        """
        __delitem__(constraintvector self, vector< constraint * >::difference_type i)
        __delitem__(constraintvector self, PySliceObject * slice)
        """
        return _sim2d.constraintvector___delitem__(self, *args)

    def __getitem__(self, *args) -> "vector< constraint * >::value_type" :
        """
        __getitem__(constraintvector self, PySliceObject * slice) -> std::vector< constraint *,std::allocator< constraint * > >
        __getitem__(constraintvector self, vector< constraint * >::difference_type i) -> constraint
        """
        return _sim2d.constraintvector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void" :
        """
        __setitem__(constraintvector self, PySliceObject * slice, std::vector< constraint *,std::allocator< constraint * > > const & v)
        __setitem__(constraintvector self, PySliceObject * slice)
        __setitem__(constraintvector self, vector< constraint * >::difference_type i, constraint x)
        """
        return _sim2d.constraintvector___setitem__(self, *args)

    def append(self, *args) -> "void" :
        """append(constraintvector self, constraint x)"""
        return _sim2d.constraintvector_append(self, *args)

    def empty(self) -> "bool" :
        """empty(constraintvector self) -> bool"""
        return _sim2d.constraintvector_empty(self)

    def size(self) -> "vector< constraint * >::size_type" :
        """size(constraintvector self) -> vector< constraint * >::size_type"""
        return _sim2d.constraintvector_size(self)

    def clear(self) -> "void" :
        """clear(constraintvector self)"""
        return _sim2d.constraintvector_clear(self)

    def swap(self, *args) -> "void" :
        """swap(constraintvector self, constraintvector v)"""
        return _sim2d.constraintvector_swap(self, *args)

    def get_allocator(self) -> "vector< constraint * >::allocator_type" :
        """get_allocator(constraintvector self) -> vector< constraint * >::allocator_type"""
        return _sim2d.constraintvector_get_allocator(self)

    def begin(self) -> "vector< constraint * >::iterator" :
        """begin(constraintvector self) -> vector< constraint * >::iterator"""
        return _sim2d.constraintvector_begin(self)

    def end(self) -> "vector< constraint * >::iterator" :
        """end(constraintvector self) -> vector< constraint * >::iterator"""
        return _sim2d.constraintvector_end(self)

    def rbegin(self) -> "vector< constraint * >::reverse_iterator" :
        """rbegin(constraintvector self) -> vector< constraint * >::reverse_iterator"""
        return _sim2d.constraintvector_rbegin(self)

    def rend(self) -> "vector< constraint * >::reverse_iterator" :
        """rend(constraintvector self) -> vector< constraint * >::reverse_iterator"""
        return _sim2d.constraintvector_rend(self)

    def pop_back(self) -> "void" :
        """pop_back(constraintvector self)"""
        return _sim2d.constraintvector_pop_back(self)

    def erase(self, *args) -> "vector< constraint * >::iterator" :
        """
        erase(constraintvector self, vector< constraint * >::iterator pos) -> vector< constraint * >::iterator
        erase(constraintvector self, vector< constraint * >::iterator first, vector< constraint * >::iterator last) -> vector< constraint * >::iterator
        """
        return _sim2d.constraintvector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(vector<(p.constraint)> self) -> constraintvector
        __init__(vector<(p.constraint)> self, constraintvector arg2) -> constraintvector
        __init__(vector<(p.constraint)> self, vector< constraint * >::size_type size) -> constraintvector
        __init__(vector<(p.constraint)> self, vector< constraint * >::size_type size, constraint value) -> constraintvector
        """
        this = _sim2d.new_constraintvector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" :
        """push_back(constraintvector self, constraint x)"""
        return _sim2d.constraintvector_push_back(self, *args)

    def front(self) -> "vector< constraint * >::value_type" :
        """front(constraintvector self) -> constraint"""
        return _sim2d.constraintvector_front(self)

    def back(self) -> "vector< constraint * >::value_type" :
        """back(constraintvector self) -> constraint"""
        return _sim2d.constraintvector_back(self)

    def assign(self, *args) -> "void" :
        """assign(constraintvector self, vector< constraint * >::size_type n, constraint x)"""
        return _sim2d.constraintvector_assign(self, *args)

    def resize(self, *args) -> "void" :
        """
        resize(constraintvector self, vector< constraint * >::size_type new_size)
        resize(constraintvector self, vector< constraint * >::size_type new_size, constraint x)
        """
        return _sim2d.constraintvector_resize(self, *args)

    def insert(self, *args) -> "void" :
        """
        insert(constraintvector self, vector< constraint * >::iterator pos, constraint x) -> vector< constraint * >::iterator
        insert(constraintvector self, vector< constraint * >::iterator pos, vector< constraint * >::size_type n, constraint x)
        """
        return _sim2d.constraintvector_insert(self, *args)

    def reserve(self, *args) -> "void" :
        """reserve(constraintvector self, vector< constraint * >::size_type n)"""
        return _sim2d.constraintvector_reserve(self, *args)

    def capacity(self) -> "vector< constraint * >::size_type" :
        """capacity(constraintvector self) -> vector< constraint * >::size_type"""
        return _sim2d.constraintvector_capacity(self)

    __swig_destroy__ = _sim2d.delete_constraintvector
    __del__ = lambda self : None;
constraintvector_swigregister = _sim2d.constraintvector_swigregister
constraintvector_swigregister(constraintvector)

class aRK4vector(_object):
    """Proxy of C++ vector<(p.atomvecRK4)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, aRK4vector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, aRK4vector, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" :
        """iterator(aRK4vector self) -> SwigPyIterator"""
        return _sim2d.aRK4vector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" :
        """__nonzero__(aRK4vector self) -> bool"""
        return _sim2d.aRK4vector___nonzero__(self)

    def __bool__(self) -> "bool" :
        """__bool__(aRK4vector self) -> bool"""
        return _sim2d.aRK4vector___bool__(self)

    def __len__(self) -> "vector< atomvecRK4 * >::size_type" :
        """__len__(aRK4vector self) -> vector< atomvecRK4 * >::size_type"""
        return _sim2d.aRK4vector___len__(self)

    def pop(self) -> "vector< atomvecRK4 * >::value_type" :
        """pop(aRK4vector self) -> atomvecRK4"""
        return _sim2d.aRK4vector_pop(self)

    def __getslice__(self, *args) -> "std::vector< atomvecRK4 *,std::allocator< atomvecRK4 * > > *" :
        """__getslice__(aRK4vector self, vector< atomvecRK4 * >::difference_type i, vector< atomvecRK4 * >::difference_type j) -> std::vector< atomvecRK4 *,std::allocator< atomvecRK4 * > > *"""
        return _sim2d.aRK4vector___getslice__(self, *args)

    def __setslice__(self, *args) -> "void" :
        """
        __setslice__(aRK4vector self, vector< atomvecRK4 * >::difference_type i, vector< atomvecRK4 * >::difference_type j, 
            std::vector< atomvecRK4 *,std::allocator< atomvecRK4 * > > const & v=std::vector< atomvecRK4 *,std::allocator< atomvecRK4 * > >())
        __setslice__(aRK4vector self, vector< atomvecRK4 * >::difference_type i, vector< atomvecRK4 * >::difference_type j)
        """
        return _sim2d.aRK4vector___setslice__(self, *args)

    def __delslice__(self, *args) -> "void" :
        """__delslice__(aRK4vector self, vector< atomvecRK4 * >::difference_type i, vector< atomvecRK4 * >::difference_type j)"""
        return _sim2d.aRK4vector___delslice__(self, *args)

    def __delitem__(self, *args) -> "void" :
        """
        __delitem__(aRK4vector self, vector< atomvecRK4 * >::difference_type i)
        __delitem__(aRK4vector self, PySliceObject * slice)
        """
        return _sim2d.aRK4vector___delitem__(self, *args)

    def __getitem__(self, *args) -> "vector< atomvecRK4 * >::value_type" :
        """
        __getitem__(aRK4vector self, PySliceObject * slice) -> std::vector< atomvecRK4 *,std::allocator< atomvecRK4 * > >
        __getitem__(aRK4vector self, vector< atomvecRK4 * >::difference_type i) -> atomvecRK4
        """
        return _sim2d.aRK4vector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void" :
        """
        __setitem__(aRK4vector self, PySliceObject * slice, std::vector< atomvecRK4 *,std::allocator< atomvecRK4 * > > const & v)
        __setitem__(aRK4vector self, PySliceObject * slice)
        __setitem__(aRK4vector self, vector< atomvecRK4 * >::difference_type i, atomvecRK4 x)
        """
        return _sim2d.aRK4vector___setitem__(self, *args)

    def append(self, *args) -> "void" :
        """append(aRK4vector self, atomvecRK4 x)"""
        return _sim2d.aRK4vector_append(self, *args)

    def empty(self) -> "bool" :
        """empty(aRK4vector self) -> bool"""
        return _sim2d.aRK4vector_empty(self)

    def size(self) -> "vector< atomvecRK4 * >::size_type" :
        """size(aRK4vector self) -> vector< atomvecRK4 * >::size_type"""
        return _sim2d.aRK4vector_size(self)

    def clear(self) -> "void" :
        """clear(aRK4vector self)"""
        return _sim2d.aRK4vector_clear(self)

    def swap(self, *args) -> "void" :
        """swap(aRK4vector self, aRK4vector v)"""
        return _sim2d.aRK4vector_swap(self, *args)

    def get_allocator(self) -> "vector< atomvecRK4 * >::allocator_type" :
        """get_allocator(aRK4vector self) -> vector< atomvecRK4 * >::allocator_type"""
        return _sim2d.aRK4vector_get_allocator(self)

    def begin(self) -> "vector< atomvecRK4 * >::iterator" :
        """begin(aRK4vector self) -> vector< atomvecRK4 * >::iterator"""
        return _sim2d.aRK4vector_begin(self)

    def end(self) -> "vector< atomvecRK4 * >::iterator" :
        """end(aRK4vector self) -> vector< atomvecRK4 * >::iterator"""
        return _sim2d.aRK4vector_end(self)

    def rbegin(self) -> "vector< atomvecRK4 * >::reverse_iterator" :
        """rbegin(aRK4vector self) -> vector< atomvecRK4 * >::reverse_iterator"""
        return _sim2d.aRK4vector_rbegin(self)

    def rend(self) -> "vector< atomvecRK4 * >::reverse_iterator" :
        """rend(aRK4vector self) -> vector< atomvecRK4 * >::reverse_iterator"""
        return _sim2d.aRK4vector_rend(self)

    def pop_back(self) -> "void" :
        """pop_back(aRK4vector self)"""
        return _sim2d.aRK4vector_pop_back(self)

    def erase(self, *args) -> "vector< atomvecRK4 * >::iterator" :
        """
        erase(aRK4vector self, vector< atomvecRK4 * >::iterator pos) -> vector< atomvecRK4 * >::iterator
        erase(aRK4vector self, vector< atomvecRK4 * >::iterator first, vector< atomvecRK4 * >::iterator last) -> vector< atomvecRK4 * >::iterator
        """
        return _sim2d.aRK4vector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(vector<(p.atomvecRK4)> self) -> aRK4vector
        __init__(vector<(p.atomvecRK4)> self, aRK4vector arg2) -> aRK4vector
        __init__(vector<(p.atomvecRK4)> self, vector< atomvecRK4 * >::size_type size) -> aRK4vector
        __init__(vector<(p.atomvecRK4)> self, vector< atomvecRK4 * >::size_type size, atomvecRK4 value) -> aRK4vector
        """
        this = _sim2d.new_aRK4vector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" :
        """push_back(aRK4vector self, atomvecRK4 x)"""
        return _sim2d.aRK4vector_push_back(self, *args)

    def front(self) -> "vector< atomvecRK4 * >::value_type" :
        """front(aRK4vector self) -> atomvecRK4"""
        return _sim2d.aRK4vector_front(self)

    def back(self) -> "vector< atomvecRK4 * >::value_type" :
        """back(aRK4vector self) -> atomvecRK4"""
        return _sim2d.aRK4vector_back(self)

    def assign(self, *args) -> "void" :
        """assign(aRK4vector self, vector< atomvecRK4 * >::size_type n, atomvecRK4 x)"""
        return _sim2d.aRK4vector_assign(self, *args)

    def resize(self, *args) -> "void" :
        """
        resize(aRK4vector self, vector< atomvecRK4 * >::size_type new_size)
        resize(aRK4vector self, vector< atomvecRK4 * >::size_type new_size, atomvecRK4 x)
        """
        return _sim2d.aRK4vector_resize(self, *args)

    def insert(self, *args) -> "void" :
        """
        insert(aRK4vector self, vector< atomvecRK4 * >::iterator pos, atomvecRK4 x) -> vector< atomvecRK4 * >::iterator
        insert(aRK4vector self, vector< atomvecRK4 * >::iterator pos, vector< atomvecRK4 * >::size_type n, atomvecRK4 x)
        """
        return _sim2d.aRK4vector_insert(self, *args)

    def reserve(self, *args) -> "void" :
        """reserve(aRK4vector self, vector< atomvecRK4 * >::size_type n)"""
        return _sim2d.aRK4vector_reserve(self, *args)

    def capacity(self) -> "vector< atomvecRK4 * >::size_type" :
        """capacity(aRK4vector self) -> vector< atomvecRK4 * >::size_type"""
        return _sim2d.aRK4vector_capacity(self)

    __swig_destroy__ = _sim2d.delete_aRK4vector
    __del__ = lambda self : None;
aRK4vector_swigregister = _sim2d.aRK4vector_swigregister
aRK4vector_swigregister(aRK4vector)

class _uintvector(collections.MutableSequence):
    """Proxy of C++ vector<(unsigned int)> class"""
    __swig_setmethods__ = {}
    for _s in [collections.MutableSequence]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, _uintvector, name, value)
    __swig_getmethods__ = {}
    for _s in [collections.MutableSequence]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, _uintvector, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" :
        """iterator(_uintvector self) -> SwigPyIterator"""
        return _sim2d._uintvector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" :
        """__nonzero__(_uintvector self) -> bool"""
        return _sim2d._uintvector___nonzero__(self)

    def __bool__(self) -> "bool" :
        """__bool__(_uintvector self) -> bool"""
        return _sim2d._uintvector___bool__(self)

    def __len__(self) -> "vector< unsigned int >::size_type" :
        """__len__(_uintvector self) -> vector< unsigned int >::size_type"""
        return _sim2d._uintvector___len__(self)

    def pop(self) -> "vector< unsigned int >::value_type" :
        """pop(_uintvector self) -> vector< unsigned int >::value_type"""
        return _sim2d._uintvector_pop(self)

    def __getslice__(self, *args) -> "std::vector< unsigned int,std::allocator< unsigned int > > *" :
        """__getslice__(_uintvector self, vector< unsigned int >::difference_type i, vector< unsigned int >::difference_type j) -> std::vector< unsigned int,std::allocator< unsigned int > > *"""
        return _sim2d._uintvector___getslice__(self, *args)

    def __setslice__(self, *args) -> "void" :
        """
        __setslice__(_uintvector self, vector< unsigned int >::difference_type i, vector< unsigned int >::difference_type j, 
            std::vector< unsigned int,std::allocator< unsigned int > > const & v=std::vector< unsigned int,std::allocator< unsigned int > >())
        __setslice__(_uintvector self, vector< unsigned int >::difference_type i, vector< unsigned int >::difference_type j)
        """
        return _sim2d._uintvector___setslice__(self, *args)

    def __delslice__(self, *args) -> "void" :
        """__delslice__(_uintvector self, vector< unsigned int >::difference_type i, vector< unsigned int >::difference_type j)"""
        return _sim2d._uintvector___delslice__(self, *args)

    def __delitem__(self, *args) -> "void" :
        """
        __delitem__(_uintvector self, vector< unsigned int >::difference_type i)
        __delitem__(_uintvector self, PySliceObject * slice)
        """
        return _sim2d._uintvector___delitem__(self, *args)

    def __getitem__(self, *args) -> "vector< unsigned int >::value_type const &" :
        """
        __getitem__(_uintvector self, PySliceObject * slice) -> std::vector< unsigned int,std::allocator< unsigned int > >
        __getitem__(_uintvector self, vector< unsigned int >::difference_type i) -> vector< unsigned int >::value_type const &
        """
        return _sim2d._uintvector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void" :
        """
        __setitem__(_uintvector self, PySliceObject * slice, std::vector< unsigned int,std::allocator< unsigned int > > const & v)
        __setitem__(_uintvector self, PySliceObject * slice)
        __setitem__(_uintvector self, vector< unsigned int >::difference_type i, vector< unsigned int >::value_type const & x)
        """
        return _sim2d._uintvector___setitem__(self, *args)

    def append(self, *args) -> "void" :
        """append(_uintvector self, vector< unsigned int >::value_type const & x)"""
        return _sim2d._uintvector_append(self, *args)

    def empty(self) -> "bool" :
        """empty(_uintvector self) -> bool"""
        return _sim2d._uintvector_empty(self)

    def size(self) -> "vector< unsigned int >::size_type" :
        """size(_uintvector self) -> vector< unsigned int >::size_type"""
        return _sim2d._uintvector_size(self)

    def clear(self) -> "void" :
        """clear(_uintvector self)"""
        return _sim2d._uintvector_clear(self)

    def swap(self, *args) -> "void" :
        """swap(_uintvector self, _uintvector v)"""
        return _sim2d._uintvector_swap(self, *args)

    def get_allocator(self) -> "vector< unsigned int >::allocator_type" :
        """get_allocator(_uintvector self) -> vector< unsigned int >::allocator_type"""
        return _sim2d._uintvector_get_allocator(self)

    def begin(self) -> "vector< unsigned int >::iterator" :
        """begin(_uintvector self) -> vector< unsigned int >::iterator"""
        return _sim2d._uintvector_begin(self)

    def end(self) -> "vector< unsigned int >::iterator" :
        """end(_uintvector self) -> vector< unsigned int >::iterator"""
        return _sim2d._uintvector_end(self)

    def rbegin(self) -> "vector< unsigned int >::reverse_iterator" :
        """rbegin(_uintvector self) -> vector< unsigned int >::reverse_iterator"""
        return _sim2d._uintvector_rbegin(self)

    def rend(self) -> "vector< unsigned int >::reverse_iterator" :
        """rend(_uintvector self) -> vector< unsigned int >::reverse_iterator"""
        return _sim2d._uintvector_rend(self)

    def pop_back(self) -> "void" :
        """pop_back(_uintvector self)"""
        return _sim2d._uintvector_pop_back(self)

    def erase(self, *args) -> "vector< unsigned int >::iterator" :
        """
        erase(_uintvector self, vector< unsigned int >::iterator pos) -> vector< unsigned int >::iterator
        erase(_uintvector self, vector< unsigned int >::iterator first, vector< unsigned int >::iterator last) -> vector< unsigned int >::iterator
        """
        return _sim2d._uintvector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(vector<(unsigned int)> self) -> _uintvector
        __init__(vector<(unsigned int)> self, _uintvector arg2) -> _uintvector
        __init__(vector<(unsigned int)> self, vector< unsigned int >::size_type size) -> _uintvector
        __init__(vector<(unsigned int)> self, vector< unsigned int >::size_type size, vector< unsigned int >::value_type const & value) -> _uintvector
        """
        this = _sim2d.new__uintvector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" :
        """push_back(_uintvector self, vector< unsigned int >::value_type const & x)"""
        return _sim2d._uintvector_push_back(self, *args)

    def front(self) -> "vector< unsigned int >::value_type const &" :
        """front(_uintvector self) -> vector< unsigned int >::value_type const &"""
        return _sim2d._uintvector_front(self)

    def back(self) -> "vector< unsigned int >::value_type const &" :
        """back(_uintvector self) -> vector< unsigned int >::value_type const &"""
        return _sim2d._uintvector_back(self)

    def assign(self, *args) -> "void" :
        """assign(_uintvector self, vector< unsigned int >::size_type n, vector< unsigned int >::value_type const & x)"""
        return _sim2d._uintvector_assign(self, *args)

    def resize(self, *args) -> "void" :
        """
        resize(_uintvector self, vector< unsigned int >::size_type new_size)
        resize(_uintvector self, vector< unsigned int >::size_type new_size, vector< unsigned int >::value_type const & x)
        """
        return _sim2d._uintvector_resize(self, *args)

    def insert(self, *args) -> "void" :
        """
        insert(_uintvector self, vector< unsigned int >::iterator pos, vector< unsigned int >::value_type const & x) -> vector< unsigned int >::iterator
        insert(_uintvector self, vector< unsigned int >::iterator pos, vector< unsigned int >::size_type n, vector< unsigned int >::value_type const & x)
        """
        return _sim2d._uintvector_insert(self, *args)

    def reserve(self, *args) -> "void" :
        """reserve(_uintvector self, vector< unsigned int >::size_type n)"""
        return _sim2d._uintvector_reserve(self, *args)

    def capacity(self) -> "vector< unsigned int >::size_type" :
        """capacity(_uintvector self) -> vector< unsigned int >::size_type"""
        return _sim2d._uintvector_capacity(self)

    __swig_destroy__ = _sim2d.delete__uintvector
    __del__ = lambda self : None;
_uintvector_swigregister = _sim2d._uintvector_swigregister
_uintvector_swigregister(_uintvector)

NDIM = _sim2d.NDIM

def randVec() -> "Vec" :
  """randVec() -> Vec"""
  return _sim2d.randVec()

def randVecBoxed() -> "Vec" :
  """randVecBoxed() -> Vec"""
  return _sim2d.randVecBoxed()

def seed(*args) -> "unsigned int" :
  """
    seed(unsigned int n) -> unsigned int
    seed() -> unsigned int
    """
  return _sim2d.seed(*args)
class gaussVec(_object):
    """Proxy of C++ gaussVec class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, gaussVec, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, gaussVec, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(gaussVec self, double sigma) -> gaussVec"""
        this = _sim2d.new_gaussVec(*args)
        try: self.this.append(this)
        except: self.this = this
    def set(self, *args) -> "void" :
        """set(gaussVec self, double sigma)"""
        return _sim2d.gaussVec_set(self, *args)

    def generate(self) -> "Vec" :
        """generate(gaussVec self) -> Vec"""
        return _sim2d.gaussVec_generate(self)

    __swig_destroy__ = _sim2d.delete_gaussVec
    __del__ = lambda self : None;
gaussVec_swigregister = _sim2d.gaussVec_swigregister
gaussVec_swigregister(gaussVec)

class bivariateGauss(_object):
    """Proxy of C++ bivariateGauss class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, bivariateGauss, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, bivariateGauss, name)
    __repr__ = _swig_repr
    def __init__(self, s1 : 'double const'=1, s2 : 'double const'=1, corr : 'double const'=0): 
        """
        __init__(bivariateGauss self, double const s1=1, double const s2=1, double const corr=0) -> bivariateGauss
        __init__(bivariateGauss self, double const s1=1, double const s2=1) -> bivariateGauss
        __init__(bivariateGauss self, double const s1=1) -> bivariateGauss
        __init__(bivariateGauss self) -> bivariateGauss
        """
        this = _sim2d.new_bivariateGauss(s1, s2, corr)
        try: self.this.append(this)
        except: self.this = this
    def set(self, *args) -> "void" :
        """set(bivariateGauss self, double const s1, double const s2, double const corr)"""
        return _sim2d.bivariateGauss_set(self, *args)

    def generate(self) -> "Pair" :
        """generate(bivariateGauss self) -> _Numvector2"""
        return _sim2d.bivariateGauss_generate(self)

    def genVec(self) -> "Vec" :
        """genVec(bivariateGauss self) -> Vec"""
        return _sim2d.bivariateGauss_genVec(self)

    def genVecs(self) -> "VecPair" :
        """genVecs(bivariateGauss self) -> VecPair"""
        return _sim2d.bivariateGauss_genVecs(self)

    __swig_destroy__ = _sim2d.delete_bivariateGauss
    __del__ = lambda self : None;
bivariateGauss_swigregister = _sim2d.bivariateGauss_swigregister
bivariateGauss_swigregister(bivariateGauss)

class Box(_object):
    """Proxy of C++ Box class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Box, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Box, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def diff(self, *args) -> "Vec" :
        """diff(Box self, Vec r1, Vec r2) -> Vec"""
        return _sim2d.Box_diff(self, *args)

    def V(self) -> "flt" :
        """V(Box self) -> flt"""
        return _sim2d.Box_V(self)

    __swig_destroy__ = _sim2d.delete_Box
    __del__ = lambda self : None;
Box_swigregister = _sim2d.Box_swigregister
Box_swigregister(Box)

class interaction(_object):
    """Proxy of C++ interaction class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, interaction, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, interaction, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def energy(self, *args) -> "flt" :
        """energy(interaction self, Box box) -> flt"""
        return _sim2d.interaction_energy(self, *args)

    def setForces(self, *args) -> "void" :
        """setForces(interaction self, Box box)"""
        return _sim2d.interaction_setForces(self, *args)

    def setForcesGetPressure(self, *args) -> "flt" :
        """setForcesGetPressure(interaction self, Box box) -> flt"""
        return _sim2d.interaction_setForcesGetPressure(self, *args)

    def pressure(self, *args) -> "flt" :
        """pressure(interaction self, Box box) -> flt"""
        return _sim2d.interaction_pressure(self, *args)

    __swig_destroy__ = _sim2d.delete_interaction
    __del__ = lambda self : None;
interaction_swigregister = _sim2d.interaction_swigregister
interaction_swigregister(interaction)

class statetracker(_object):
    """Proxy of C++ statetracker class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, statetracker, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, statetracker, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def update(self, *args) -> "void" :
        """update(statetracker self, Box box)"""
        return _sim2d.statetracker_update(self, *args)

    __swig_destroy__ = _sim2d.delete_statetracker
    __del__ = lambda self : None;
statetracker_swigregister = _sim2d.statetracker_swigregister
statetracker_swigregister(statetracker)


def vecmod(*args) -> "Vec" :
  """vecmod(Vec r1, Vec r2) -> Vec"""
  return _sim2d.vecmod(*args)
class InfiniteBox(Box):
    """Proxy of C++ InfiniteBox class"""
    __swig_setmethods__ = {}
    for _s in [Box]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, InfiniteBox, name, value)
    __swig_getmethods__ = {}
    for _s in [Box]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, InfiniteBox, name)
    __repr__ = _swig_repr
    def diff(self, *args) -> "Vec" :
        """diff(InfiniteBox self, Vec r1, Vec r2) -> Vec"""
        return _sim2d.InfiniteBox_diff(self, *args)

    def V(self) -> "flt" :
        """V(InfiniteBox self) -> flt"""
        return _sim2d.InfiniteBox_V(self)

    def __init__(self): 
        """__init__(InfiniteBox self) -> InfiniteBox"""
        this = _sim2d.new_InfiniteBox()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _sim2d.delete_InfiniteBox
    __del__ = lambda self : None;
InfiniteBox_swigregister = _sim2d.InfiniteBox_swigregister
InfiniteBox_swigregister(InfiniteBox)

class OriginBox(Box):
    """Proxy of C++ OriginBox class"""
    __swig_setmethods__ = {}
    for _s in [Box]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, OriginBox, name, value)
    __swig_getmethods__ = {}
    for _s in [Box]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, OriginBox, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(OriginBox self, Vec size) -> OriginBox"""
        this = _sim2d.new_OriginBox(*args)
        try: self.this.append(this)
        except: self.this = this
    def diff(self, *args) -> "Vec" :
        """diff(OriginBox self, Vec r1, Vec r2) -> Vec"""
        return _sim2d.OriginBox_diff(self, *args)

    def V(self) -> "flt" :
        """V(OriginBox self) -> flt"""
        return _sim2d.OriginBox_V(self)

    def L(self) -> "flt" :
        """L(OriginBox self) -> flt"""
        return _sim2d.OriginBox_L(self)

    def resize(self, *args) -> "flt" :
        """resize(OriginBox self, flt factor) -> flt"""
        return _sim2d.OriginBox_resize(self, *args)

    def resizeV(self, *args) -> "flt" :
        """resizeV(OriginBox self, flt newV) -> flt"""
        return _sim2d.OriginBox_resizeV(self, *args)

    def randLoc(self) -> "Vec" :
        """randLoc(OriginBox self) -> Vec"""
        return _sim2d.OriginBox_randLoc(self)

    __swig_destroy__ = _sim2d.delete_OriginBox
    __del__ = lambda self : None;
OriginBox_swigregister = _sim2d.OriginBox_swigregister
OriginBox_swigregister(OriginBox)
cvar = _sim2d.cvar

class atom(_object):
    """Proxy of C++ atom class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, atom, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, atom, name)
    __repr__ = _swig_repr
    __swig_setmethods__["x"] = _sim2d.atom_x_set
    __swig_getmethods__["x"] = _sim2d.atom_x_get
    if _newclass:x = _swig_property(_sim2d.atom_x_get, _sim2d.atom_x_set)
    __swig_setmethods__["v"] = _sim2d.atom_v_set
    __swig_getmethods__["v"] = _sim2d.atom_v_get
    if _newclass:v = _swig_property(_sim2d.atom_v_get, _sim2d.atom_v_set)
    __swig_setmethods__["a"] = _sim2d.atom_a_set
    __swig_getmethods__["a"] = _sim2d.atom_a_get
    if _newclass:a = _swig_property(_sim2d.atom_a_get, _sim2d.atom_a_set)
    __swig_setmethods__["f"] = _sim2d.atom_f_set
    __swig_getmethods__["f"] = _sim2d.atom_f_get
    if _newclass:f = _swig_property(_sim2d.atom_f_get, _sim2d.atom_f_set)
    __swig_setmethods__["m"] = _sim2d.atom_m_set
    __swig_getmethods__["m"] = _sim2d.atom_m_get
    if _newclass:m = _swig_property(_sim2d.atom_m_get, _sim2d.atom_m_set)
    def __getstate__(self):
        return (tuple(self.x),tuple(self.v),tuple(self.f), tuple(self.a))

    def __setstate__(self, lst):
        self.x, self.v, self.f, self.a = [Vec(*r) for r in lst]

    def __str__(self):
        if hasattr(self, 'name'):
            return "<atom %s>" % self.name
        return "<atom>"

    def __repr__(self):
        #ifdef VEC2D
        x,y = tuple(self.x)
        if hasattr(self, 'name'):
            return "<atom %s at (%.2f,%.2f)>" % (self.name,x,y)
        return "<atom at (%.2f,%.2f)>" % (x,y)
        #else
        x,y,z = tuple(self.x)
        if hasattr(self, 'name'):
            return "<atom %s at (%.2f,%.2f,%.2f)>" % (self.name,x,y,z)
        return "<atom at (%.2f,%.2f,%.2f)>" % (x,y,z)
        #endif

    def __init__(self): 
        """__init__(atom self) -> atom"""
        this = _sim2d.new_atom()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _sim2d.delete_atom
    __del__ = lambda self : None;
atom_swigregister = _sim2d.atom_swigregister
atom_swigregister(atom)

class atomref(_object):
    """Proxy of C++ atomref class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, atomref, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, atomref, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(atomref self) -> atomref
        __init__(atomref self, atom a) -> atomref
        """
        this = _sim2d.new_atomref(*args)
        try: self.this.append(this)
        except: self.this = this
    def __ref__(self) -> "atom &" :
        """__ref__(atomref self) -> atom"""
        return _sim2d.atomref___ref__(self)

    def pointer(self) -> "atom *" :
        """pointer(atomref self) -> atom"""
        return _sim2d.atomref_pointer(self)

    def x(self) -> "Vec &" :
        """x(atomref self) -> Vec"""
        return _sim2d.atomref_x(self)

    def v(self) -> "Vec &" :
        """v(atomref self) -> Vec"""
        return _sim2d.atomref_v(self)

    def f(self) -> "Vec &" :
        """f(atomref self) -> Vec"""
        return _sim2d.atomref_f(self)

    def a(self) -> "Vec &" :
        """a(atomref self) -> Vec"""
        return _sim2d.atomref_a(self)

    def m(self) -> "flt &" :
        """m(atomref self) -> flt &"""
        return _sim2d.atomref_m(self)

    def __eq__(self, *args) -> "bool" :
        """
        __eq__(atomref self, atomref other) -> bool
        __eq__(atomref self, atom other) -> bool
        """
        return _sim2d.atomref___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        """__ne__(atomref self, atomref other) -> bool"""
        return _sim2d.atomref___ne__(self, *args)

    def __lt__(self, *args) -> "bool" :
        """__lt__(atomref self, atomref other) -> bool"""
        return _sim2d.atomref___lt__(self, *args)

    def __le__(self, *args) -> "bool" :
        """__le__(atomref self, atomref other) -> bool"""
        return _sim2d.atomref___le__(self, *args)

    def __ge__(self, *args) -> "bool" :
        """__ge__(atomref self, atomref other) -> bool"""
        return _sim2d.atomref___ge__(self, *args)

    def __gt__(self, *args) -> "bool" :
        """__gt__(atomref self, atomref other) -> bool"""
        return _sim2d.atomref___gt__(self, *args)

    __swig_destroy__ = _sim2d.delete_atomref
    __del__ = lambda self : None;
atomref_swigregister = _sim2d.atomref_swigregister
atomref_swigregister(atomref)

class atomid(atomref):
    """Proxy of C++ atomid class"""
    __swig_setmethods__ = {}
    for _s in [atomref]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, atomid, name, value)
    __swig_getmethods__ = {}
    for _s in [atomref]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, atomid, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(atomid self) -> atomid
        __init__(atomid self, atom a) -> atomid
        __init__(atomid self, atom a, uint n) -> atomid
        """
        this = _sim2d.new_atomid(*args)
        try: self.this.append(this)
        except: self.this = this
    def n(self) -> "uint" :
        """n(atomid self) -> uint"""
        return _sim2d.atomid_n(self)

    __swig_destroy__ = _sim2d.delete_atomid
    __del__ = lambda self : None;
atomid_swigregister = _sim2d.atomid_swigregister
atomid_swigregister(atomid)

class idpair(_idarray2):
    """Proxy of C++ idpair class"""
    __swig_setmethods__ = {}
    for _s in [_idarray2]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, idpair, name, value)
    __swig_getmethods__ = {}
    for _s in [_idarray2]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, idpair, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(idpair self, atomid a, atomid b) -> idpair"""
        this = _sim2d.new_idpair(*args)
        try: self.this.append(this)
        except: self.this = this
    def first(self) -> "atomid" :
        """first(idpair self) -> atomid"""
        return _sim2d.idpair_first(self)

    def last(self) -> "atomid" :
        """last(idpair self) -> atomid"""
        return _sim2d.idpair_last(self)

    __swig_destroy__ = _sim2d.delete_idpair
    __del__ = lambda self : None;
idpair_swigregister = _sim2d.idpair_swigregister
idpair_swigregister(idpair)

class atompair(_atomarray2):
    """Proxy of C++ atompair class"""
    __swig_setmethods__ = {}
    for _s in [_atomarray2]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, atompair, name, value)
    __swig_getmethods__ = {}
    for _s in [_atomarray2]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, atompair, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(atompair self, atom a, atom b) -> atompair"""
        this = _sim2d.new_atompair(*args)
        try: self.this.append(this)
        except: self.this = this
    def first(self) -> "atom &" :
        """first(atompair self) -> atom"""
        return _sim2d.atompair_first(self)

    def last(self) -> "atom &" :
        """last(atompair self) -> atom"""
        return _sim2d.atompair_last(self)

    __swig_destroy__ = _sim2d.delete_atompair
    __del__ = lambda self : None;
atompair_swigregister = _sim2d.atompair_swigregister
atompair_swigregister(atompair)

class atomgroup(_object):
    """Proxy of C++ atomgroup class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, atomgroup, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, atomgroup, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def get(self, *args) -> "atom *" :
        """get(atomgroup self, cuint n) -> atom"""
        return _sim2d.atomgroup_get(self, *args)

    def get_id(self, *args) -> "atomid" :
        """get_id(atomgroup self, cuint n) -> atomid"""
        return _sim2d.atomgroup_get_id(self, *args)

    def size(self) -> "uint" :
        """size(atomgroup self) -> uint"""
        return _sim2d.atomgroup_size(self)

    def getmass(self, *args) -> "flt" :
        """getmass(atomgroup self, unsigned int const n) -> flt"""
        return _sim2d.atomgroup_getmass(self, *args)

    def com(self) -> "Vec" :
        """com(atomgroup self) -> Vec"""
        return _sim2d.atomgroup_com(self)

    def comv(self) -> "Vec" :
        """comv(atomgroup self) -> Vec"""
        return _sim2d.atomgroup_comv(self)

    def mass(self) -> "flt" :
        """mass(atomgroup self) -> flt"""
        return _sim2d.atomgroup_mass(self)

    def kinetic(self, *args) -> "flt" :
        """
        kinetic(atomgroup self, Vec originvelocity=Vec()) -> flt
        kinetic(atomgroup self) -> flt
        """
        return _sim2d.atomgroup_kinetic(self, *args)

    def momentum(self) -> "Vec" :
        """momentum(atomgroup self) -> Vec"""
        return _sim2d.atomgroup_momentum(self)

    def moment(self, *args) -> "flt" :
        """moment(atomgroup self, Vec loc, Box box) -> flt"""
        return _sim2d.atomgroup_moment(self, *args)

    def angmomentum(self, *args) -> "flt" :
        """angmomentum(atomgroup self, Vec loc, Box box) -> flt"""
        return _sim2d.atomgroup_angmomentum(self, *args)

    def omega(self, *args) -> "flt" :
        """omega(atomgroup self, Vec loc, Box box) -> flt"""
        return _sim2d.atomgroup_omega(self, *args)

    def addOmega(self, *args) -> "void" :
        """addOmega(atomgroup self, flt w, Vec origin, Box box)"""
        return _sim2d.atomgroup_addOmega(self, *args)

    def resetL(self, *args) -> "void" :
        """resetL(atomgroup self, Box box)"""
        return _sim2d.atomgroup_resetL(self, *args)

    def addv(self, *args) -> "void" :
        """addv(atomgroup self, Vec v)"""
        return _sim2d.atomgroup_addv(self, *args)

    def resetcomv(self) -> "void" :
        """resetcomv(atomgroup self)"""
        return _sim2d.atomgroup_resetcomv(self)

    def resetForces(self) -> "void" :
        """resetForces(atomgroup self)"""
        return _sim2d.atomgroup_resetForces(self)

    def setAccel(self) -> "void" :
        """setAccel(atomgroup self)"""
        return _sim2d.atomgroup_setAccel(self)

    __swig_destroy__ = _sim2d.delete_atomgroup
    __del__ = lambda self : None;
    def __iter__(self):
        for i in range(self.size()):
            yield self.get(i)

atomgroup_swigregister = _sim2d.atomgroup_swigregister
atomgroup_swigregister(atomgroup)

class atomvec(atomgroup):
    """Proxy of C++ atomvec class"""
    __swig_setmethods__ = {}
    for _s in [atomgroup]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, atomvec, name, value)
    __swig_getmethods__ = {}
    for _s in [atomgroup]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, atomvec, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(atomvec self, fvector masses) -> atomvec
        __init__(atomvec self, atomvec other) -> atomvec
        """
        this = _sim2d.new_atomvec(*args)
        try: self.this.append(this)
        except: self.this = this
    def get_id(self, *args) -> "atomid" :
        """
        get_id(atomvec self, atom a) -> atomid
        get_id(atomvec self, uint n) -> atomid
        """
        return _sim2d.atomvec_get_id(self, *args)

    def size(self) -> "uint" :
        """size(atomvec self) -> uint"""
        return _sim2d.atomvec_size(self)

    __swig_destroy__ = _sim2d.delete_atomvec
    __del__ = lambda self : None;
    def __iter__(self):
        for i in range(self.size()):
            yield self[i]

    def __len__(self):
        return self.size()

    def __getitem__(self, obj):
        return self.get(obj)

    def __setitem__(self, obj, val):
        return self.set(obj, val)

    def __getstate__(self):
        return ([self.getmass(i) for i in range(self.N())],
                    [a.__getstate__() for a in self])

    def __setstate__(self, lst):
        masses, atomstates = lst
        self.__init__(fvector(masses))
        for i, atomstate in enumerate(atomstates):
            #~ print "i:",i
            a = self.get(i)
            a.__setstate__(atomstate)

atomvec_swigregister = _sim2d.atomvec_swigregister
atomvec_swigregister(atomvec)

class metagroup(atomgroup):
    """Proxy of C++ metagroup class"""
    __swig_setmethods__ = {}
    for _s in [atomgroup]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, metagroup, name, value)
    __swig_getmethods__ = {}
    for _s in [atomgroup]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, metagroup, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(metagroup self) -> metagroup
        __init__(metagroup self, avector arg2) -> metagroup
        """
        this = _sim2d.new_metagroup(*args)
        try: self.this.append(this)
        except: self.this = this
    def get(self, *args) -> "atom *" :
        """get(metagroup self, cuint n) -> atom"""
        return _sim2d.metagroup_get(self, *args)

    def add(self, *args) -> "void" :
        """add(metagroup self, atom a)"""
        return _sim2d.metagroup_add(self, *args)

    def get_id(self, *args) -> "atomid" :
        """
        get_id(metagroup self, atom a) -> atomid
        get_id(metagroup self, uint n) -> atomid
        """
        return _sim2d.metagroup_get_id(self, *args)

    def size(self) -> "uint" :
        """size(metagroup self) -> uint"""
        return _sim2d.metagroup_size(self)

    __swig_destroy__ = _sim2d.delete_metagroup
    __del__ = lambda self : None;
metagroup_swigregister = _sim2d.metagroup_swigregister
metagroup_swigregister(metagroup)

class interactpair(_object):
    """Proxy of C++ interactpair class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, interactpair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, interactpair, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def energy(self, *args) -> "flt" :
        """energy(interactpair self, Vec diff) -> flt"""
        return _sim2d.interactpair_energy(self, *args)

    def forces(self, *args) -> "Vec" :
        """forces(interactpair self, Vec diff) -> Vec"""
        return _sim2d.interactpair_forces(self, *args)

    __swig_destroy__ = _sim2d.delete_interactpair
    __del__ = lambda self : None;
interactpair_swigregister = _sim2d.interactpair_swigregister
interactpair_swigregister(interactpair)

class LJrepulsive(_object):
    """Proxy of C++ LJrepulsive class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJrepulsive, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LJrepulsive, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(LJrepulsive self, flt const epsilon, flt const sigma) -> LJrepulsive"""
        this = _sim2d.new_LJrepulsive(*args)
        try: self.this.append(this)
        except: self.this = this
    def energy(self, *args) -> "flt" :
        """
        energy(LJrepulsive self, Vec diff, flt const eps, flt const sig) -> flt
        energy(LJrepulsive self, Vec diff) -> flt
        """
        return _sim2d.LJrepulsive_energy(self, *args)

    def forces(self, *args) -> "Vec" :
        """
        forces(LJrepulsive self, Vec diff, flt const eps, flt const sig) -> Vec
        forces(LJrepulsive self, Vec diff) -> Vec
        """
        return _sim2d.LJrepulsive_forces(self, *args)

    __swig_destroy__ = _sim2d.delete_LJrepulsive
    __del__ = lambda self : None;
LJrepulsive_swigregister = _sim2d.LJrepulsive_swigregister
LJrepulsive_swigregister(LJrepulsive)
LJr0 = cvar.LJr0
LJr0sq = cvar.LJr0sq

class LJattract(_object):
    """Proxy of C++ LJattract class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJattract, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LJattract, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(LJattract self, flt const epsilon, flt const sigma) -> LJattract"""
        this = _sim2d.new_LJattract(*args)
        try: self.this.append(this)
        except: self.this = this
    def energy(self, *args) -> "flt" :
        """
        energy(LJattract self, Vec diff, flt const eps, flt const sig) -> flt
        energy(LJattract self, flt const rsig) -> flt
        energy(LJattract self, Vec diff) -> flt
        """
        return _sim2d.LJattract_energy(self, *args)

    def forces(self, *args) -> "Vec" :
        """
        forces(LJattract self, Vec diff, flt const eps, flt const sig) -> Vec
        forces(LJattract self, flt const rsig) -> flt
        forces(LJattract self, Vec diff) -> Vec
        """
        return _sim2d.LJattract_forces(self, *args)

    __swig_destroy__ = _sim2d.delete_LJattract
    __del__ = lambda self : None;
LJattract_swigregister = _sim2d.LJattract_swigregister
LJattract_swigregister(LJattract)

class LJattractCut(_object):
    """Proxy of C++ LJattractCut class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJattractCut, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LJattractCut, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(LJattractCut self, flt const epsilon, flt const sigma, flt const cutsig) -> LJattractCut"""
        this = _sim2d.new_LJattractCut(*args)
        try: self.this.append(this)
        except: self.this = this
    def energy(self, *args) -> "flt" :
        """
        energy(LJattractCut self, Vec diff, flt const eps, flt const sig, flt const cutsig) -> flt
        energy(LJattractCut self, Vec diff) -> flt
        """
        return _sim2d.LJattractCut_energy(self, *args)

    def forces(self, *args) -> "Vec" :
        """
        forces(LJattractCut self, Vec diff, flt const eps, flt const sig, flt const cutsig) -> Vec
        forces(LJattractCut self, Vec diff) -> Vec
        """
        return _sim2d.LJattractCut_forces(self, *args)

    __swig_destroy__ = _sim2d.delete_LJattractCut
    __del__ = lambda self : None;
LJattractCut_swigregister = _sim2d.LJattractCut_swigregister
LJattractCut_swigregister(LJattractCut)

class LJFullCut(_object):
    """Proxy of C++ LJFullCut class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJFullCut, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LJFullCut, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(LJFullCut self, flt const epsilon, flt const sigma, flt const cutsig) -> LJFullCut"""
        this = _sim2d.new_LJFullCut(*args)
        try: self.this.append(this)
        except: self.this = this
    def energy(self, *args) -> "flt" :
        """
        energy(LJFullCut self, Vec diff, flt const eps, flt const sig, flt const cutsig) -> flt
        energy(LJFullCut self, flt const rsig, flt const cutsig) -> flt
        energy(LJFullCut self, Vec diff) -> flt
        """
        return _sim2d.LJFullCut_energy(self, *args)

    def forces(self, *args) -> "Vec" :
        """
        forces(LJFullCut self, Vec diff, flt const eps, flt const sig, flt const cutsig) -> Vec
        forces(LJFullCut self, flt const rsig, flt const cutsig) -> flt
        forces(LJFullCut self, Vec diff) -> Vec
        """
        return _sim2d.LJFullCut_forces(self, *args)

    __swig_destroy__ = _sim2d.delete_LJFullCut
    __del__ = lambda self : None;
LJFullCut_swigregister = _sim2d.LJFullCut_swigregister
LJFullCut_swigregister(LJFullCut)

class spring(interactpair):
    """Proxy of C++ spring class"""
    __swig_setmethods__ = {}
    for _s in [interactpair]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, spring, name, value)
    __swig_getmethods__ = {}
    for _s in [interactpair]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, spring, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(spring self, flt const k, flt const x0) -> spring"""
        this = _sim2d.new_spring(*args)
        try: self.this.append(this)
        except: self.this = this
    def energy(self, *args) -> "flt" :
        """energy(spring self, Vec diff) -> flt"""
        return _sim2d.spring_energy(self, *args)

    def forces(self, *args) -> "Vec" :
        """forces(spring self, Vec diff) -> Vec"""
        return _sim2d.spring_forces(self, *args)

    __swig_destroy__ = _sim2d.delete_spring
    __del__ = lambda self : None;
spring_swigregister = _sim2d.spring_swigregister
spring_swigregister(spring)

class bondangle(_object):
    """Proxy of C++ bondangle class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, bondangle, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, bondangle, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(bondangle self, flt const k, flt const theta, bool const cosine=False) -> bondangle
        __init__(bondangle self, flt const k, flt const theta) -> bondangle
        """
        this = _sim2d.new_bondangle(*args)
        try: self.this.append(this)
        except: self.this = this
    def energy(self, *args) -> "flt" :
        """energy(bondangle self, Vec diff1, Vec diff2) -> flt"""
        return _sim2d.bondangle_energy(self, *args)

    def forces(self, *args) -> "Nvector< Vec,3 >" :
        """forces(bondangle self, Vec diff1, Vec diff2) -> Nvector< Vec,3 >"""
        return _sim2d.bondangle_forces(self, *args)

    __swig_destroy__ = _sim2d.delete_bondangle
    __del__ = lambda self : None;
bondangle_swigregister = _sim2d.bondangle_swigregister
bondangle_swigregister(bondangle)

class electricScreened(interactpair):
    """Proxy of C++ electricScreened class"""
    __swig_setmethods__ = {}
    for _s in [interactpair]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, electricScreened, name, value)
    __swig_getmethods__ = {}
    for _s in [interactpair]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, electricScreened, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(electricScreened self, flt const screenLength, flt const q1, flt const q2, flt const cutoff) -> electricScreened"""
        this = _sim2d.new_electricScreened(*args)
        try: self.this.append(this)
        except: self.this = this
    def energy(*args) -> "flt" :
        """
        energy(Vec r) -> flt
        energy(flt const r, flt const qaqb, flt const screen, flt const cutoff=0) -> flt
        energy(flt const r, flt const qaqb, flt const screen) -> flt
        """
        return _sim2d.electricScreened_energy(*args)

    if _newclass:energy = staticmethod(energy)
    __swig_getmethods__["energy"] = lambda x: energy
    def forces(*args) -> "Vec" :
        """
        forces(Vec r) -> Vec
        forces(Vec r, flt const qaqb, flt const screen, flt const cutoff=0) -> Vec
        forces(Vec r, flt const qaqb, flt const screen) -> Vec
        """
        return _sim2d.electricScreened_forces(*args)

    if _newclass:forces = staticmethod(forces)
    __swig_getmethods__["forces"] = lambda x: forces
    __swig_destroy__ = _sim2d.delete_electricScreened
    __del__ = lambda self : None;
electricScreened_swigregister = _sim2d.electricScreened_swigregister
electricScreened_swigregister(electricScreened)

def electricScreened_energy(*args) -> "flt" :
  """
    energy(Vec r) -> flt
    energy(flt const r, flt const qaqb, flt const screen, flt const cutoff=0) -> flt
    electricScreened_energy(flt const r, flt const qaqb, flt const screen) -> flt
    """
  return _sim2d.electricScreened_energy(*args)

def electricScreened_forces(*args) -> "Vec" :
  """
    forces(Vec r) -> Vec
    forces(Vec r, flt const qaqb, flt const screen, flt const cutoff=0) -> Vec
    electricScreened_forces(Vec r, flt const qaqb, flt const screen) -> Vec
    """
  return _sim2d.electricScreened_forces(*args)

class fixedForceAtom(_object):
    """Proxy of C++ fixedForceAtom class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, fixedForceAtom, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, fixedForceAtom, name)
    __repr__ = _swig_repr
    __swig_setmethods__["F"] = _sim2d.fixedForceAtom_F_set
    __swig_getmethods__["F"] = _sim2d.fixedForceAtom_F_get
    if _newclass:F = _swig_property(_sim2d.fixedForceAtom_F_get, _sim2d.fixedForceAtom_F_set)
    __swig_setmethods__["a"] = _sim2d.fixedForceAtom_a_set
    __swig_getmethods__["a"] = _sim2d.fixedForceAtom_a_get
    if _newclass:a = _swig_property(_sim2d.fixedForceAtom_a_get, _sim2d.fixedForceAtom_a_set)
    def __init__(self, *args): 
        """__init__(fixedForceAtom self, Vec F, atom a) -> fixedForceAtom"""
        this = _sim2d.new_fixedForceAtom(*args)
        try: self.this.append(this)
        except: self.this = this
    def energy(self, *args) -> "flt" :
        """energy(fixedForceAtom self, Box box) -> flt"""
        return _sim2d.fixedForceAtom_energy(self, *args)

    def setForce(self, *args) -> "void" :
        """setForce(fixedForceAtom self, Box box)"""
        return _sim2d.fixedForceAtom_setForce(self, *args)

    __swig_destroy__ = _sim2d.delete_fixedForceAtom
    __del__ = lambda self : None;
fixedForceAtom_swigregister = _sim2d.fixedForceAtom_swigregister
fixedForceAtom_swigregister(fixedForceAtom)

class fixedForce(interaction):
    """Proxy of C++ fixedForce class"""
    __swig_setmethods__ = {}
    for _s in [interaction]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, fixedForce, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, fixedForce, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(fixedForce self, std::vector< fixedForceAtom > atoms=std::vector< fixedForceAtom >()) -> fixedForce
        __init__(fixedForce self) -> fixedForce
        """
        this = _sim2d.new_fixedForce(*args)
        try: self.this.append(this)
        except: self.this = this
    def add(self, *args) -> "void" :
        """
        add(fixedForce self, fixedForceAtom a)
        add(fixedForce self, Vec F, atom a)
        add(fixedForce self, flt x, flt y, atom a)
        """
        return _sim2d.fixedForce_add(self, *args)

    def size(self) -> "uint" :
        """size(fixedForce self) -> uint"""
        return _sim2d.fixedForce_size(self)

    def energy(self, *args) -> "flt" :
        """energy(fixedForce self, Box box) -> flt"""
        return _sim2d.fixedForce_energy(self, *args)

    def setForces(self, *args) -> "void" :
        """setForces(fixedForce self, Box box)"""
        return _sim2d.fixedForce_setForces(self, *args)

    def pressure(self, *args) -> "flt" :
        """pressure(fixedForce self, Box box) -> flt"""
        return _sim2d.fixedForce_pressure(self, *args)

    __swig_destroy__ = _sim2d.delete_fixedForce
    __del__ = lambda self : None;
fixedForce_swigregister = _sim2d.fixedForce_swigregister
fixedForce_swigregister(fixedForce)

class fixedSpringAtom(_object):
    """Proxy of C++ fixedSpringAtom class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, fixedSpringAtom, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, fixedSpringAtom, name)
    __repr__ = _swig_repr
    __swig_setmethods__["loc"] = _sim2d.fixedSpringAtom_loc_set
    __swig_getmethods__["loc"] = _sim2d.fixedSpringAtom_loc_get
    if _newclass:loc = _swig_property(_sim2d.fixedSpringAtom_loc_get, _sim2d.fixedSpringAtom_loc_set)
    __swig_setmethods__["k"] = _sim2d.fixedSpringAtom_k_set
    __swig_getmethods__["k"] = _sim2d.fixedSpringAtom_k_get
    if _newclass:k = _swig_property(_sim2d.fixedSpringAtom_k_get, _sim2d.fixedSpringAtom_k_set)
    __swig_setmethods__["usecoord"] = _sim2d.fixedSpringAtom_usecoord_set
    __swig_getmethods__["usecoord"] = _sim2d.fixedSpringAtom_usecoord_get
    if _newclass:usecoord = _swig_property(_sim2d.fixedSpringAtom_usecoord_get, _sim2d.fixedSpringAtom_usecoord_set)
    __swig_setmethods__["a"] = _sim2d.fixedSpringAtom_a_set
    __swig_getmethods__["a"] = _sim2d.fixedSpringAtom_a_get
    if _newclass:a = _swig_property(_sim2d.fixedSpringAtom_a_get, _sim2d.fixedSpringAtom_a_set)
    def __init__(self, *args): 
        """
        __init__(fixedSpringAtom self, atom a, Vec loc, flt k, bool usex=True, bool usey=True, bool usez=True) -> fixedSpringAtom
        __init__(fixedSpringAtom self, atom a, Vec loc, flt k, bool usex=True, bool usey=True) -> fixedSpringAtom
        __init__(fixedSpringAtom self, atom a, Vec loc, flt k, bool usex=True) -> fixedSpringAtom
        __init__(fixedSpringAtom self, atom a, Vec loc, flt k) -> fixedSpringAtom
        """
        this = _sim2d.new_fixedSpringAtom(*args)
        try: self.this.append(this)
        except: self.this = this
    def energy(self, *args) -> "flt" :
        """energy(fixedSpringAtom self, Box box) -> flt"""
        return _sim2d.fixedSpringAtom_energy(self, *args)

    def setForce(self, *args) -> "void" :
        """setForce(fixedSpringAtom self, Box box)"""
        return _sim2d.fixedSpringAtom_setForce(self, *args)

    __swig_destroy__ = _sim2d.delete_fixedSpringAtom
    __del__ = lambda self : None;
fixedSpringAtom_swigregister = _sim2d.fixedSpringAtom_swigregister
fixedSpringAtom_swigregister(fixedSpringAtom)

class fixedSpring(interaction):
    """Proxy of C++ fixedSpring class"""
    __swig_setmethods__ = {}
    for _s in [interaction]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, fixedSpring, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, fixedSpring, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(fixedSpring self, std::vector< fixedSpringAtom > atoms=std::vector< fixedSpringAtom >()) -> fixedSpring
        __init__(fixedSpring self) -> fixedSpring
        """
        this = _sim2d.new_fixedSpring(*args)
        try: self.this.append(this)
        except: self.this = this
    def add(self, *args) -> "void" :
        """
        add(fixedSpring self, fixedSpringAtom a)
        add(fixedSpring self, atom a, Vec loc, flt k, bool usex=True, bool usey=True, bool usez=True)
        add(fixedSpring self, atom a, Vec loc, flt k, bool usex=True, bool usey=True)
        add(fixedSpring self, atom a, Vec loc, flt k, bool usex=True)
        add(fixedSpring self, atom a, Vec loc, flt k)
        """
        return _sim2d.fixedSpring_add(self, *args)

    def size(self) -> "uint" :
        """size(fixedSpring self) -> uint"""
        return _sim2d.fixedSpring_size(self)

    def energy(self, *args) -> "flt" :
        """energy(fixedSpring self, Box box) -> flt"""
        return _sim2d.fixedSpring_energy(self, *args)

    def setForces(self, *args) -> "void" :
        """setForces(fixedSpring self, Box box)"""
        return _sim2d.fixedSpring_setForces(self, *args)

    def pressure(self, *args) -> "flt" :
        """pressure(fixedSpring self, Box box) -> flt"""
        return _sim2d.fixedSpring_pressure(self, *args)

    __swig_destroy__ = _sim2d.delete_fixedSpring
    __del__ = lambda self : None;
fixedSpring_swigregister = _sim2d.fixedSpring_swigregister
fixedSpring_swigregister(fixedSpring)

class COMSpring(interaction):
    """Proxy of C++ COMSpring class"""
    __swig_setmethods__ = {}
    for _s in [interaction]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, COMSpring, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, COMSpring, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(COMSpring self, atomgroup g1, atomgroup g2, flt k, flt x0=0) -> COMSpring
        __init__(COMSpring self, atomgroup g1, atomgroup g2, flt k) -> COMSpring
        """
        this = _sim2d.new_COMSpring(*args)
        try: self.this.append(this)
        except: self.this = this
    def energy(self, *args) -> "flt" :
        """energy(COMSpring self, Box box) -> flt"""
        return _sim2d.COMSpring_energy(self, *args)

    def setForces(self, *args) -> "void" :
        """setForces(COMSpring self, Box box)"""
        return _sim2d.COMSpring_setForces(self, *args)

    def pressure(self, *args) -> "flt" :
        """pressure(COMSpring self, Box box) -> flt"""
        return _sim2d.COMSpring_pressure(self, *args)

    __swig_destroy__ = _sim2d.delete_COMSpring
    __del__ = lambda self : None;
COMSpring_swigregister = _sim2d.COMSpring_swigregister
COMSpring_swigregister(COMSpring)

class bondgrouping(_object):
    """Proxy of C++ bondgrouping class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, bondgrouping, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, bondgrouping, name)
    __repr__ = _swig_repr
    __swig_setmethods__["k"] = _sim2d.bondgrouping_k_set
    __swig_getmethods__["k"] = _sim2d.bondgrouping_k_get
    if _newclass:k = _swig_property(_sim2d.bondgrouping_k_get, _sim2d.bondgrouping_k_set)
    __swig_setmethods__["x0"] = _sim2d.bondgrouping_x0_set
    __swig_getmethods__["x0"] = _sim2d.bondgrouping_x0_get
    if _newclass:x0 = _swig_property(_sim2d.bondgrouping_x0_get, _sim2d.bondgrouping_x0_set)
    __swig_setmethods__["a1"] = _sim2d.bondgrouping_a1_set
    __swig_getmethods__["a1"] = _sim2d.bondgrouping_a1_get
    if _newclass:a1 = _swig_property(_sim2d.bondgrouping_a1_get, _sim2d.bondgrouping_a1_set)
    __swig_setmethods__["a2"] = _sim2d.bondgrouping_a2_set
    __swig_getmethods__["a2"] = _sim2d.bondgrouping_a2_get
    if _newclass:a2 = _swig_property(_sim2d.bondgrouping_a2_get, _sim2d.bondgrouping_a2_set)
    def __init__(self, *args): 
        """__init__(bondgrouping self, flt k, flt x0, atom a1, atom a2) -> bondgrouping"""
        this = _sim2d.new_bondgrouping(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _sim2d.delete_bondgrouping
    __del__ = lambda self : None;
bondgrouping_swigregister = _sim2d.bondgrouping_swigregister
bondgrouping_swigregister(bondgrouping)

class bondpairs(interaction):
    """Proxy of C++ bondpairs class"""
    __swig_setmethods__ = {}
    for _s in [interaction]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, bondpairs, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, bondpairs, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(bondpairs self, std::vector< bondgrouping > pairs=std::vector< bondgrouping >()) -> bondpairs
        __init__(bondpairs self) -> bondpairs
        """
        this = _sim2d.new_bondpairs(*args)
        try: self.this.append(this)
        except: self.this = this
    def add(self, *args) -> "void" :
        """
        add(bondpairs self, bondgrouping b)
        add(bondpairs self, flt k, flt x0, atom a1, atom a2)
        """
        return _sim2d.bondpairs_add(self, *args)

    def size(self) -> "uint" :
        """size(bondpairs self) -> uint"""
        return _sim2d.bondpairs_size(self)

    def mean_dists(self) -> "flt" :
        """mean_dists(bondpairs self) -> flt"""
        return _sim2d.bondpairs_mean_dists(self)

    def std_dists(self) -> "flt" :
        """std_dists(bondpairs self) -> flt"""
        return _sim2d.bondpairs_std_dists(self)

    def energy(self, *args) -> "flt" :
        """energy(bondpairs self, Box box) -> flt"""
        return _sim2d.bondpairs_energy(self, *args)

    def setForces(self, *args) -> "void" :
        """setForces(bondpairs self, Box box)"""
        return _sim2d.bondpairs_setForces(self, *args)

    def pressure(self, *args) -> "flt" :
        """pressure(bondpairs self, Box box) -> flt"""
        return _sim2d.bondpairs_pressure(self, *args)

    __swig_destroy__ = _sim2d.delete_bondpairs
    __del__ = lambda self : None;
bondpairs_swigregister = _sim2d.bondpairs_swigregister
bondpairs_swigregister(bondpairs)

class anglegrouping(_object):
    """Proxy of C++ anglegrouping class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, anglegrouping, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, anglegrouping, name)
    __repr__ = _swig_repr
    __swig_setmethods__["k"] = _sim2d.anglegrouping_k_set
    __swig_getmethods__["k"] = _sim2d.anglegrouping_k_get
    if _newclass:k = _swig_property(_sim2d.anglegrouping_k_get, _sim2d.anglegrouping_k_set)
    __swig_setmethods__["x0"] = _sim2d.anglegrouping_x0_set
    __swig_getmethods__["x0"] = _sim2d.anglegrouping_x0_get
    if _newclass:x0 = _swig_property(_sim2d.anglegrouping_x0_get, _sim2d.anglegrouping_x0_set)
    __swig_setmethods__["a1"] = _sim2d.anglegrouping_a1_set
    __swig_getmethods__["a1"] = _sim2d.anglegrouping_a1_get
    if _newclass:a1 = _swig_property(_sim2d.anglegrouping_a1_get, _sim2d.anglegrouping_a1_set)
    __swig_setmethods__["a2"] = _sim2d.anglegrouping_a2_set
    __swig_getmethods__["a2"] = _sim2d.anglegrouping_a2_get
    if _newclass:a2 = _swig_property(_sim2d.anglegrouping_a2_get, _sim2d.anglegrouping_a2_set)
    __swig_setmethods__["a3"] = _sim2d.anglegrouping_a3_set
    __swig_getmethods__["a3"] = _sim2d.anglegrouping_a3_get
    if _newclass:a3 = _swig_property(_sim2d.anglegrouping_a3_get, _sim2d.anglegrouping_a3_set)
    def __init__(self, *args): 
        """__init__(anglegrouping self, flt k, flt x0, atom a1, atom a2, atom a3) -> anglegrouping"""
        this = _sim2d.new_anglegrouping(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _sim2d.delete_anglegrouping
    __del__ = lambda self : None;
anglegrouping_swigregister = _sim2d.anglegrouping_swigregister
anglegrouping_swigregister(anglegrouping)

class angletriples(interaction):
    """Proxy of C++ angletriples class"""
    __swig_setmethods__ = {}
    for _s in [interaction]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, angletriples, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, angletriples, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(angletriples self, std::vector< anglegrouping > triples=std::vector< anglegrouping >()) -> angletriples
        __init__(angletriples self) -> angletriples
        """
        this = _sim2d.new_angletriples(*args)
        try: self.this.append(this)
        except: self.this = this
    def add(self, *args) -> "void" :
        """
        add(angletriples self, anglegrouping b)
        add(angletriples self, flt k, flt x0, atom a1, atom a2, atom a3)
        """
        return _sim2d.angletriples_add(self, *args)

    def energy(self, *args) -> "flt" :
        """energy(angletriples self, Box box) -> flt"""
        return _sim2d.angletriples_energy(self, *args)

    def pressure(self, *args) -> "flt" :
        """pressure(angletriples self, Box box) -> flt"""
        return _sim2d.angletriples_pressure(self, *args)

    def setForces(self, *args) -> "void" :
        """setForces(angletriples self, Box box)"""
        return _sim2d.angletriples_setForces(self, *args)

    def size(self) -> "uint" :
        """size(angletriples self) -> uint"""
        return _sim2d.angletriples_size(self)

    def mean_dists(self) -> "flt" :
        """mean_dists(angletriples self) -> flt"""
        return _sim2d.angletriples_mean_dists(self)

    def std_dists(self) -> "flt" :
        """std_dists(angletriples self) -> flt"""
        return _sim2d.angletriples_std_dists(self)

    __swig_destroy__ = _sim2d.delete_angletriples
    __del__ = lambda self : None;
angletriples_swigregister = _sim2d.angletriples_swigregister
angletriples_swigregister(angletriples)

class forcepair(_object):
    """Proxy of C++ forcepair class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, forcepair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, forcepair, name)
    __repr__ = _swig_repr
    __swig_setmethods__["a1"] = _sim2d.forcepair_a1_set
    __swig_getmethods__["a1"] = _sim2d.forcepair_a1_get
    if _newclass:a1 = _swig_property(_sim2d.forcepair_a1_get, _sim2d.forcepair_a1_set)
    __swig_setmethods__["a2"] = _sim2d.forcepair_a2_set
    __swig_getmethods__["a2"] = _sim2d.forcepair_a2_get
    if _newclass:a2 = _swig_property(_sim2d.forcepair_a2_get, _sim2d.forcepair_a2_set)
    __swig_setmethods__["fij"] = _sim2d.forcepair_fij_set
    __swig_getmethods__["fij"] = _sim2d.forcepair_fij_get
    if _newclass:fij = _swig_property(_sim2d.forcepair_fij_get, _sim2d.forcepair_fij_set)
    def __init__(self): 
        """__init__(forcepair self) -> forcepair"""
        this = _sim2d.new_forcepair()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _sim2d.delete_forcepair
    __del__ = lambda self : None;
forcepair_swigregister = _sim2d.forcepair_swigregister
forcepair_swigregister(forcepair)

class forcepairx(_object):
    """Proxy of C++ forcepairx class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, forcepairx, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, forcepairx, name)
    __repr__ = _swig_repr
    __swig_setmethods__["a1"] = _sim2d.forcepairx_a1_set
    __swig_getmethods__["a1"] = _sim2d.forcepairx_a1_get
    if _newclass:a1 = _swig_property(_sim2d.forcepairx_a1_get, _sim2d.forcepairx_a1_set)
    __swig_setmethods__["a2"] = _sim2d.forcepairx_a2_set
    __swig_getmethods__["a2"] = _sim2d.forcepairx_a2_get
    if _newclass:a2 = _swig_property(_sim2d.forcepairx_a2_get, _sim2d.forcepairx_a2_set)
    __swig_setmethods__["xij"] = _sim2d.forcepairx_xij_set
    __swig_getmethods__["xij"] = _sim2d.forcepairx_xij_get
    if _newclass:xij = _swig_property(_sim2d.forcepairx_xij_get, _sim2d.forcepairx_xij_set)
    __swig_setmethods__["fij"] = _sim2d.forcepairx_fij_set
    __swig_getmethods__["fij"] = _sim2d.forcepairx_fij_get
    if _newclass:fij = _swig_property(_sim2d.forcepairx_fij_get, _sim2d.forcepairx_fij_set)
    def __init__(self): 
        """__init__(forcepairx self) -> forcepairx"""
        this = _sim2d.new_forcepairx()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _sim2d.delete_forcepairx
    __del__ = lambda self : None;
forcepairx_swigregister = _sim2d.forcepairx_swigregister
forcepairx_swigregister(forcepairx)

class fpairxFunct(_object):
    """Proxy of C++ fpairxFunct class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, fpairxFunct, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, fpairxFunct, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def run(self, *args) -> "void" :
        """run(fpairxFunct self, forcepairx arg2)"""
        return _sim2d.fpairxFunct_run(self, *args)

    __swig_destroy__ = _sim2d.delete_fpairxFunct
    __del__ = lambda self : None;
fpairxFunct_swigregister = _sim2d.fpairxFunct_swigregister
fpairxFunct_swigregister(fpairxFunct)

class interactionpairsx(interaction):
    """Proxy of C++ interactionpairsx class"""
    __swig_setmethods__ = {}
    for _s in [interaction]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, interactionpairsx, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, interactionpairsx, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def setForces(self, *args) -> "void" :
        """
        setForces(interactionpairsx self, Box box)
        setForces(interactionpairsx self, Box box, fpairxFunct arg3)
        """
        return _sim2d.interactionpairsx_setForces(self, *args)

    __swig_destroy__ = _sim2d.delete_interactionpairsx
    __del__ = lambda self : None;
interactionpairsx_swigregister = _sim2d.interactionpairsx_swigregister
interactionpairsx_swigregister(interactionpairsx)

class atompaircomp(_object):
    """Proxy of C++ atompaircomp class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, atompaircomp, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, atompaircomp, name)
    __repr__ = _swig_repr
    def __call__(self, *args) -> "bool" :
        """__call__(atompaircomp self, atompair lhs, atompair rhs) -> bool"""
        return _sim2d.atompaircomp___call__(self, *args)

    def __init__(self): 
        """__init__(atompaircomp self) -> atompaircomp"""
        this = _sim2d.new_atompaircomp()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _sim2d.delete_atompaircomp
    __del__ = lambda self : None;
atompaircomp_swigregister = _sim2d.atompaircomp_swigregister
atompaircomp_swigregister(atompaircomp)

class pairlist(_object):
    """Proxy of C++ pairlist class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, pairlist, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, pairlist, name)
    __repr__ = _swig_repr
    def __init__(self): 
        """__init__(pairlist self) -> pairlist"""
        this = _sim2d.new_pairlist()
        try: self.this.append(this)
        except: self.this = this
    def ensure(self, *args) -> "void" :
        """
        ensure(pairlist self, atomid a)
        ensure(pairlist self, std::vector< atomid > ps)
        ensure(pairlist self, atomgroup group)
        """
        return _sim2d.pairlist_ensure(self, *args)

    def has_pair(self, *args) -> "bool" :
        """has_pair(pairlist self, atomid a1, atomid a2) -> bool"""
        return _sim2d.pairlist_has_pair(self, *args)

    def add_pair(self, *args) -> "void" :
        """add_pair(pairlist self, atomid a1, atomid a2)"""
        return _sim2d.pairlist_add_pair(self, *args)

    def erase_pair(self, *args) -> "void" :
        """erase_pair(pairlist self, atomid a1, atomid a2)"""
        return _sim2d.pairlist_erase_pair(self, *args)

    def get_pairs(self, *args) -> "set< atomid >" :
        """get_pairs(pairlist self, atomid a) -> set< atomid >"""
        return _sim2d.pairlist_get_pairs(self, *args)

    def begin(self, *args) -> "set< atomid >::iterator" :
        """begin(pairlist self, atomid a) -> set< atomid >::iterator"""
        return _sim2d.pairlist_begin(self, *args)

    def end(self, *args) -> "set< atomid >::iterator" :
        """end(pairlist self, atomid a) -> set< atomid >::iterator"""
        return _sim2d.pairlist_end(self, *args)

    def size(self) -> "uint" :
        """size(pairlist self) -> uint"""
        return _sim2d.pairlist_size(self)

    def clear(self) -> "void" :
        """clear(pairlist self)"""
        return _sim2d.pairlist_clear(self)

    __swig_destroy__ = _sim2d.delete_pairlist
    __del__ = lambda self : None;
pairlist_swigregister = _sim2d.pairlist_swigregister
pairlist_swigregister(pairlist)

class neighborlist(statetracker):
    """Proxy of C++ neighborlist class"""
    __swig_setmethods__ = {}
    for _s in [statetracker]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, neighborlist, name, value)
    __swig_getmethods__ = {}
    for _s in [statetracker]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, neighborlist, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(neighborlist self, Box box, flt const innerradius, flt const outerradius) -> neighborlist
        __init__(neighborlist self, Box box, atomgroup vec, flt const innerradius, flt const outerradius, pairlist ignore=pairlist()) -> neighborlist
        __init__(neighborlist self, Box box, atomgroup vec, flt const innerradius, flt const outerradius) -> neighborlist
        """
        this = _sim2d.new_neighborlist(*args)
        try: self.this.append(this)
        except: self.this = this
    def update(self, *args) -> "void" :
        """update(neighborlist self, Box newbox)"""
        return _sim2d.neighborlist_update(self, *args)

    def update_list(self, force : 'bool'=True) -> "bool" :
        """
        update_list(neighborlist self, bool force=True) -> bool
        update_list(neighborlist self) -> bool
        """
        return _sim2d.neighborlist_update_list(self, force)

    def which(self) -> "uint" :
        """which(neighborlist self) -> uint"""
        return _sim2d.neighborlist_which(self)

    def numpairs(self) -> "uint" :
        """numpairs(neighborlist self) -> uint"""
        return _sim2d.neighborlist_numpairs(self)

    def ignore(self, *args) -> "void" :
        """
        ignore(neighborlist self, atomid a, atomid b)
        ignore(neighborlist self, atom arg2, atom arg3)
        """
        return _sim2d.neighborlist_ignore(self, *args)

    def add(self, *args) -> "atomid" :
        """add(neighborlist self, atom a) -> atomid"""
        return _sim2d.neighborlist_add(self, *args)

    def changesize(self, *args) -> "void" :
        """
        changesize(neighborlist self, flt inner, flt outer)
        changesize(neighborlist self, flt ratio)
        """
        return _sim2d.neighborlist_changesize(self, *args)

    def ignore_size(self) -> "uint" :
        """ignore_size(neighborlist self) -> uint"""
        return _sim2d.neighborlist_ignore_size(self)

    def size(self) -> "uint" :
        """size(neighborlist self) -> uint"""
        return _sim2d.neighborlist_size(self)

    def begin(self) -> "std::vector< idpair,std::allocator< idpair > >::iterator" :
        """begin(neighborlist self) -> std::vector< idpair,std::allocator< idpair > >::iterator"""
        return _sim2d.neighborlist_begin(self)

    def end(self) -> "std::vector< idpair,std::allocator< idpair > >::iterator" :
        """end(neighborlist self) -> std::vector< idpair,std::allocator< idpair > >::iterator"""
        return _sim2d.neighborlist_end(self)

    def get(self, *args) -> "idpair" :
        """get(neighborlist self, uint i) -> idpair"""
        return _sim2d.neighborlist_get(self, *args)

    __swig_destroy__ = _sim2d.delete_neighborlist
    __del__ = lambda self : None;
    def __getitem__(self, *args) -> "idpair" :
        """__getitem__(neighborlist self, size_t i) -> idpair"""
        return _sim2d.neighborlist___getitem__(self, *args)

    def __iter__(self):
        for i in range(self.numpairs()):
            yield self[i]

neighborlist_swigregister = _sim2d.neighborlist_swigregister
neighborlist_swigregister(neighborlist)

class Charged(atomid):
    """Proxy of C++ Charged class"""
    __swig_setmethods__ = {}
    for _s in [atomid]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Charged, name, value)
    __swig_getmethods__ = {}
    for _s in [atomid]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Charged, name)
    __repr__ = _swig_repr
    __swig_setmethods__["q"] = _sim2d.Charged_q_set
    __swig_getmethods__["q"] = _sim2d.Charged_q_get
    if _newclass:q = _swig_property(_sim2d.Charged_q_get, _sim2d.Charged_q_set)
    def __init__(self, *args): 
        """
        __init__(Charged self) -> Charged
        __init__(Charged self, flt q, atom a) -> Charged
        """
        this = _sim2d.new_Charged(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _sim2d.delete_Charged
    __del__ = lambda self : None;
Charged_swigregister = _sim2d.Charged_swigregister
Charged_swigregister(Charged)

class ChargePair(_object):
    """Proxy of C++ ChargePair class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ChargePair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ChargePair, name)
    __repr__ = _swig_repr
    __swig_setmethods__["q1q2"] = _sim2d.ChargePair_q1q2_set
    __swig_getmethods__["q1q2"] = _sim2d.ChargePair_q1q2_get
    if _newclass:q1q2 = _swig_property(_sim2d.ChargePair_q1q2_get, _sim2d.ChargePair_q1q2_set)
    __swig_setmethods__["atom1"] = _sim2d.ChargePair_atom1_set
    __swig_getmethods__["atom1"] = _sim2d.ChargePair_atom1_get
    if _newclass:atom1 = _swig_property(_sim2d.ChargePair_atom1_get, _sim2d.ChargePair_atom1_set)
    __swig_setmethods__["atom2"] = _sim2d.ChargePair_atom2_set
    __swig_getmethods__["atom2"] = _sim2d.ChargePair_atom2_get
    if _newclass:atom2 = _swig_property(_sim2d.ChargePair_atom2_get, _sim2d.ChargePair_atom2_set)
    def __init__(self, *args): 
        """__init__(ChargePair self, Charged a1, Charged a2) -> ChargePair"""
        this = _sim2d.new_ChargePair(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _sim2d.delete_ChargePair
    __del__ = lambda self : None;
ChargePair_swigregister = _sim2d.ChargePair_swigregister
ChargePair_swigregister(ChargePair)

class LJatom(atomid):
    """Proxy of C++ LJatom class"""
    __swig_setmethods__ = {}
    for _s in [atomid]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJatom, name, value)
    __swig_getmethods__ = {}
    for _s in [atomid]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LJatom, name)
    __repr__ = _swig_repr
    __swig_setmethods__["epsilon"] = _sim2d.LJatom_epsilon_set
    __swig_getmethods__["epsilon"] = _sim2d.LJatom_epsilon_get
    if _newclass:epsilon = _swig_property(_sim2d.LJatom_epsilon_get, _sim2d.LJatom_epsilon_set)
    __swig_setmethods__["sigma"] = _sim2d.LJatom_sigma_set
    __swig_getmethods__["sigma"] = _sim2d.LJatom_sigma_get
    if _newclass:sigma = _swig_property(_sim2d.LJatom_sigma_get, _sim2d.LJatom_sigma_set)
    def __init__(self, *args): 
        """
        __init__(LJatom self, flt epsilon, flt sigma, atom a) -> LJatom
        __init__(LJatom self, atomid a, LJatom other) -> LJatom
        """
        this = _sim2d.new_LJatom(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _sim2d.delete_LJatom
    __del__ = lambda self : None;
LJatom_swigregister = _sim2d.LJatom_swigregister
LJatom_swigregister(LJatom)

class LJpair(_object):
    """Proxy of C++ LJpair class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJpair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LJpair, name)
    __repr__ = _swig_repr
    __swig_setmethods__["epsilon"] = _sim2d.LJpair_epsilon_set
    __swig_getmethods__["epsilon"] = _sim2d.LJpair_epsilon_get
    if _newclass:epsilon = _swig_property(_sim2d.LJpair_epsilon_get, _sim2d.LJpair_epsilon_set)
    __swig_setmethods__["sigma"] = _sim2d.LJpair_sigma_set
    __swig_getmethods__["sigma"] = _sim2d.LJpair_sigma_get
    if _newclass:sigma = _swig_property(_sim2d.LJpair_sigma_get, _sim2d.LJpair_sigma_set)
    __swig_setmethods__["atom1"] = _sim2d.LJpair_atom1_set
    __swig_getmethods__["atom1"] = _sim2d.LJpair_atom1_get
    if _newclass:atom1 = _swig_property(_sim2d.LJpair_atom1_get, _sim2d.LJpair_atom1_set)
    __swig_setmethods__["atom2"] = _sim2d.LJpair_atom2_set
    __swig_getmethods__["atom2"] = _sim2d.LJpair_atom2_get
    if _newclass:atom2 = _swig_property(_sim2d.LJpair_atom2_get, _sim2d.LJpair_atom2_set)
    def __init__(self, *args): 
        """__init__(LJpair self, LJatom LJ1, LJatom LJ2) -> LJpair"""
        this = _sim2d.new_LJpair(*args)
        try: self.this.append(this)
        except: self.this = this
    def energy(self, *args) -> "flt" :
        """energy(LJpair self, Box box) -> flt"""
        return _sim2d.LJpair_energy(self, *args)

    def forces(self, *args) -> "Vec" :
        """forces(LJpair self, Box box) -> Vec"""
        return _sim2d.LJpair_forces(self, *args)

    __swig_destroy__ = _sim2d.delete_LJpair
    __del__ = lambda self : None;
LJpair_swigregister = _sim2d.LJpair_swigregister
LJpair_swigregister(LJpair)

class LJatomcut(LJatom):
    """Proxy of C++ LJatomcut class"""
    __swig_setmethods__ = {}
    for _s in [LJatom]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJatomcut, name, value)
    __swig_getmethods__ = {}
    for _s in [LJatom]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LJatomcut, name)
    __repr__ = _swig_repr
    __swig_setmethods__["sigcut"] = _sim2d.LJatomcut_sigcut_set
    __swig_getmethods__["sigcut"] = _sim2d.LJatomcut_sigcut_get
    if _newclass:sigcut = _swig_property(_sim2d.LJatomcut_sigcut_get, _sim2d.LJatomcut_sigcut_set)
    def __init__(self, *args): 
        """
        __init__(LJatomcut self, flt epsilon, flt sigma, atom a, flt cut) -> LJatomcut
        __init__(LJatomcut self, atomid a, LJatomcut other) -> LJatomcut
        """
        this = _sim2d.new_LJatomcut(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _sim2d.delete_LJatomcut
    __del__ = lambda self : None;
LJatomcut_swigregister = _sim2d.LJatomcut_swigregister
LJatomcut_swigregister(LJatomcut)

class LJAttractPair(_object):
    """Proxy of C++ LJAttractPair class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJAttractPair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LJAttractPair, name)
    __repr__ = _swig_repr
    __swig_setmethods__["inter"] = _sim2d.LJAttractPair_inter_set
    __swig_getmethods__["inter"] = _sim2d.LJAttractPair_inter_get
    if _newclass:inter = _swig_property(_sim2d.LJAttractPair_inter_get, _sim2d.LJAttractPair_inter_set)
    __swig_setmethods__["atom1"] = _sim2d.LJAttractPair_atom1_set
    __swig_getmethods__["atom1"] = _sim2d.LJAttractPair_atom1_get
    if _newclass:atom1 = _swig_property(_sim2d.LJAttractPair_atom1_get, _sim2d.LJAttractPair_atom1_set)
    __swig_setmethods__["atom2"] = _sim2d.LJAttractPair_atom2_set
    __swig_getmethods__["atom2"] = _sim2d.LJAttractPair_atom2_get
    if _newclass:atom2 = _swig_property(_sim2d.LJAttractPair_atom2_get, _sim2d.LJAttractPair_atom2_set)
    def __init__(self, *args): 
        """__init__(LJAttractPair self, LJatomcut a1, LJatomcut a2) -> LJAttractPair"""
        this = _sim2d.new_LJAttractPair(*args)
        try: self.this.append(this)
        except: self.this = this
    def energy(self, *args) -> "flt" :
        """energy(LJAttractPair self, Box box) -> flt"""
        return _sim2d.LJAttractPair_energy(self, *args)

    def forces(self, *args) -> "Vec" :
        """forces(LJAttractPair self, Box box) -> Vec"""
        return _sim2d.LJAttractPair_forces(self, *args)

    __swig_destroy__ = _sim2d.delete_LJAttractPair
    __del__ = lambda self : None;
LJAttractPair_swigregister = _sim2d.LJAttractPair_swigregister
LJAttractPair_swigregister(LJAttractPair)

class HydroAtom(atomid):
    """Proxy of C++ HydroAtom class"""
    __swig_setmethods__ = {}
    for _s in [atomid]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HydroAtom, name, value)
    __swig_getmethods__ = {}
    for _s in [atomid]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, HydroAtom, name)
    __repr__ = _swig_repr
    __swig_setmethods__["epsilons"] = _sim2d.HydroAtom_epsilons_set
    __swig_getmethods__["epsilons"] = _sim2d.HydroAtom_epsilons_get
    if _newclass:epsilons = _swig_property(_sim2d.HydroAtom_epsilons_get, _sim2d.HydroAtom_epsilons_set)
    __swig_setmethods__["indx"] = _sim2d.HydroAtom_indx_set
    __swig_getmethods__["indx"] = _sim2d.HydroAtom_indx_get
    if _newclass:indx = _swig_property(_sim2d.HydroAtom_indx_get, _sim2d.HydroAtom_indx_set)
    __swig_setmethods__["sigma"] = _sim2d.HydroAtom_sigma_set
    __swig_getmethods__["sigma"] = _sim2d.HydroAtom_sigma_get
    if _newclass:sigma = _swig_property(_sim2d.HydroAtom_sigma_get, _sim2d.HydroAtom_sigma_set)
    __swig_setmethods__["sigcut"] = _sim2d.HydroAtom_sigcut_set
    __swig_getmethods__["sigcut"] = _sim2d.HydroAtom_sigcut_get
    if _newclass:sigcut = _swig_property(_sim2d.HydroAtom_sigcut_get, _sim2d.HydroAtom_sigcut_set)
    def __init__(self, *args): 
        """
        __init__(HydroAtom self, fvector epsilons, uint indx, flt sigma, atom a, flt cut) -> HydroAtom
        __init__(HydroAtom self, atomid a, HydroAtom other) -> HydroAtom
        """
        this = _sim2d.new_HydroAtom(*args)
        try: self.this.append(this)
        except: self.this = this
    def getEpsilon(self, *args) -> "flt" :
        """getEpsilon(HydroAtom self, HydroAtom other) -> flt"""
        return _sim2d.HydroAtom_getEpsilon(self, *args)

    __swig_destroy__ = _sim2d.delete_HydroAtom
    __del__ = lambda self : None;
HydroAtom_swigregister = _sim2d.HydroAtom_swigregister
HydroAtom_swigregister(HydroAtom)

class HydroPair(_object):
    """Proxy of C++ HydroPair class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, HydroPair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, HydroPair, name)
    __repr__ = _swig_repr
    __swig_setmethods__["inter"] = _sim2d.HydroPair_inter_set
    __swig_getmethods__["inter"] = _sim2d.HydroPair_inter_get
    if _newclass:inter = _swig_property(_sim2d.HydroPair_inter_get, _sim2d.HydroPair_inter_set)
    __swig_setmethods__["atom1"] = _sim2d.HydroPair_atom1_set
    __swig_getmethods__["atom1"] = _sim2d.HydroPair_atom1_get
    if _newclass:atom1 = _swig_property(_sim2d.HydroPair_atom1_get, _sim2d.HydroPair_atom1_set)
    __swig_setmethods__["atom2"] = _sim2d.HydroPair_atom2_set
    __swig_getmethods__["atom2"] = _sim2d.HydroPair_atom2_get
    if _newclass:atom2 = _swig_property(_sim2d.HydroPair_atom2_get, _sim2d.HydroPair_atom2_set)
    def __init__(self, *args): 
        """__init__(HydroPair self, HydroAtom a1, HydroAtom a2) -> HydroPair"""
        this = _sim2d.new_HydroPair(*args)
        try: self.this.append(this)
        except: self.this = this
    def energy(self, *args) -> "flt" :
        """energy(HydroPair self, Box box) -> flt"""
        return _sim2d.HydroPair_energy(self, *args)

    def forces(self, *args) -> "Vec" :
        """forces(HydroPair self, Box box) -> Vec"""
        return _sim2d.HydroPair_forces(self, *args)

    __swig_destroy__ = _sim2d.delete_HydroPair
    __del__ = lambda self : None;
HydroPair_swigregister = _sim2d.HydroPair_swigregister
HydroPair_swigregister(HydroPair)

class LJAtomIndexed(atomid):
    """Proxy of C++ LJAtomIndexed class"""
    __swig_setmethods__ = {}
    for _s in [atomid]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJAtomIndexed, name, value)
    __swig_getmethods__ = {}
    for _s in [atomid]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LJAtomIndexed, name)
    __repr__ = _swig_repr
    __swig_setmethods__["epsilons"] = _sim2d.LJAtomIndexed_epsilons_set
    __swig_getmethods__["epsilons"] = _sim2d.LJAtomIndexed_epsilons_get
    if _newclass:epsilons = _swig_property(_sim2d.LJAtomIndexed_epsilons_get, _sim2d.LJAtomIndexed_epsilons_set)
    __swig_setmethods__["sigmas"] = _sim2d.LJAtomIndexed_sigmas_set
    __swig_getmethods__["sigmas"] = _sim2d.LJAtomIndexed_sigmas_get
    if _newclass:sigmas = _swig_property(_sim2d.LJAtomIndexed_sigmas_get, _sim2d.LJAtomIndexed_sigmas_set)
    __swig_setmethods__["indx"] = _sim2d.LJAtomIndexed_indx_set
    __swig_getmethods__["indx"] = _sim2d.LJAtomIndexed_indx_get
    if _newclass:indx = _swig_property(_sim2d.LJAtomIndexed_indx_get, _sim2d.LJAtomIndexed_indx_set)
    __swig_setmethods__["sigcut"] = _sim2d.LJAtomIndexed_sigcut_set
    __swig_getmethods__["sigcut"] = _sim2d.LJAtomIndexed_sigcut_get
    if _newclass:sigcut = _swig_property(_sim2d.LJAtomIndexed_sigcut_get, _sim2d.LJAtomIndexed_sigcut_set)
    def __init__(self, *args): 
        """
        __init__(LJAtomIndexed self, fvector epsilons, fvector sigmas, uint indx, atom a, flt cut) -> LJAtomIndexed
        __init__(LJAtomIndexed self, atomid a, LJAtomIndexed other) -> LJAtomIndexed
        """
        this = _sim2d.new_LJAtomIndexed(*args)
        try: self.this.append(this)
        except: self.this = this
    def getEpsilon(self, *args) -> "flt" :
        """getEpsilon(LJAtomIndexed self, LJAtomIndexed other) -> flt"""
        return _sim2d.LJAtomIndexed_getEpsilon(self, *args)

    def getSigma(self, *args) -> "flt" :
        """getSigma(LJAtomIndexed self, LJAtomIndexed other) -> flt"""
        return _sim2d.LJAtomIndexed_getSigma(self, *args)

    __swig_destroy__ = _sim2d.delete_LJAtomIndexed
    __del__ = lambda self : None;
LJAtomIndexed_swigregister = _sim2d.LJAtomIndexed_swigregister
LJAtomIndexed_swigregister(LJAtomIndexed)

class LJFullPair(_object):
    """Proxy of C++ LJFullPair class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJFullPair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LJFullPair, name)
    __repr__ = _swig_repr
    __swig_setmethods__["inter"] = _sim2d.LJFullPair_inter_set
    __swig_getmethods__["inter"] = _sim2d.LJFullPair_inter_get
    if _newclass:inter = _swig_property(_sim2d.LJFullPair_inter_get, _sim2d.LJFullPair_inter_set)
    __swig_setmethods__["atom1"] = _sim2d.LJFullPair_atom1_set
    __swig_getmethods__["atom1"] = _sim2d.LJFullPair_atom1_get
    if _newclass:atom1 = _swig_property(_sim2d.LJFullPair_atom1_get, _sim2d.LJFullPair_atom1_set)
    __swig_setmethods__["atom2"] = _sim2d.LJFullPair_atom2_set
    __swig_getmethods__["atom2"] = _sim2d.LJFullPair_atom2_get
    if _newclass:atom2 = _swig_property(_sim2d.LJFullPair_atom2_get, _sim2d.LJFullPair_atom2_set)
    def __init__(self, *args): 
        """__init__(LJFullPair self, LJAtomIndexed a1, LJAtomIndexed a2) -> LJFullPair"""
        this = _sim2d.new_LJFullPair(*args)
        try: self.this.append(this)
        except: self.this = this
    def energy(self, *args) -> "flt" :
        """energy(LJFullPair self, Box box) -> flt"""
        return _sim2d.LJFullPair_energy(self, *args)

    def forces(self, *args) -> "Vec" :
        """forces(LJFullPair self, Box box) -> Vec"""
        return _sim2d.LJFullPair_forces(self, *args)

    __swig_destroy__ = _sim2d.delete_LJFullPair
    __del__ = lambda self : None;
LJFullPair_swigregister = _sim2d.LJFullPair_swigregister
LJFullPair_swigregister(LJFullPair)

class LJishAtom(atomid):
    """Proxy of C++ LJishAtom class"""
    __swig_setmethods__ = {}
    for _s in [atomid]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJishAtom, name, value)
    __swig_getmethods__ = {}
    for _s in [atomid]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LJishAtom, name)
    __repr__ = _swig_repr
    __swig_setmethods__["epsilons"] = _sim2d.LJishAtom_epsilons_set
    __swig_getmethods__["epsilons"] = _sim2d.LJishAtom_epsilons_get
    if _newclass:epsilons = _swig_property(_sim2d.LJishAtom_epsilons_get, _sim2d.LJishAtom_epsilons_set)
    __swig_setmethods__["repeps"] = _sim2d.LJishAtom_repeps_set
    __swig_getmethods__["repeps"] = _sim2d.LJishAtom_repeps_get
    if _newclass:repeps = _swig_property(_sim2d.LJishAtom_repeps_get, _sim2d.LJishAtom_repeps_set)
    __swig_setmethods__["sigma"] = _sim2d.LJishAtom_sigma_set
    __swig_getmethods__["sigma"] = _sim2d.LJishAtom_sigma_get
    if _newclass:sigma = _swig_property(_sim2d.LJishAtom_sigma_get, _sim2d.LJishAtom_sigma_set)
    __swig_setmethods__["exponent"] = _sim2d.LJishAtom_exponent_set
    __swig_getmethods__["exponent"] = _sim2d.LJishAtom_exponent_get
    if _newclass:exponent = _swig_property(_sim2d.LJishAtom_exponent_get, _sim2d.LJishAtom_exponent_set)
    __swig_setmethods__["indx"] = _sim2d.LJishAtom_indx_set
    __swig_getmethods__["indx"] = _sim2d.LJishAtom_indx_get
    if _newclass:indx = _swig_property(_sim2d.LJishAtom_indx_get, _sim2d.LJishAtom_indx_set)
    __swig_setmethods__["sigcut"] = _sim2d.LJishAtom_sigcut_set
    __swig_getmethods__["sigcut"] = _sim2d.LJishAtom_sigcut_get
    if _newclass:sigcut = _swig_property(_sim2d.LJishAtom_sigcut_get, _sim2d.LJishAtom_sigcut_set)
    def __init__(self, *args): 
        """
        __init__(LJishAtom self, atom a, fvector epsilons, flt repeps, flt sigma, flt n, uint indx, flt cut) -> LJishAtom
        __init__(LJishAtom self, atomid a, LJishAtom other) -> LJishAtom
        """
        this = _sim2d.new_LJishAtom(*args)
        try: self.this.append(this)
        except: self.this = this
    def getEpsilon(self, *args) -> "flt" :
        """getEpsilon(LJishAtom self, LJishAtom other) -> flt"""
        return _sim2d.LJishAtom_getEpsilon(self, *args)

    def getSigma(self, *args) -> "flt" :
        """getSigma(LJishAtom self, LJishAtom other) -> flt"""
        return _sim2d.LJishAtom_getSigma(self, *args)

    __swig_destroy__ = _sim2d.delete_LJishAtom
    __del__ = lambda self : None;
LJishAtom_swigregister = _sim2d.LJishAtom_swigregister
LJishAtom_swigregister(LJishAtom)

class LJishPair(_object):
    """Proxy of C++ LJishPair class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJishPair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LJishPair, name)
    __repr__ = _swig_repr
    __swig_setmethods__["epsilon"] = _sim2d.LJishPair_epsilon_set
    __swig_getmethods__["epsilon"] = _sim2d.LJishPair_epsilon_get
    if _newclass:epsilon = _swig_property(_sim2d.LJishPair_epsilon_get, _sim2d.LJishPair_epsilon_set)
    __swig_setmethods__["repeps"] = _sim2d.LJishPair_repeps_set
    __swig_getmethods__["repeps"] = _sim2d.LJishPair_repeps_get
    if _newclass:repeps = _swig_property(_sim2d.LJishPair_repeps_get, _sim2d.LJishPair_repeps_set)
    __swig_setmethods__["sigma"] = _sim2d.LJishPair_sigma_set
    __swig_getmethods__["sigma"] = _sim2d.LJishPair_sigma_get
    if _newclass:sigma = _swig_property(_sim2d.LJishPair_sigma_get, _sim2d.LJishPair_sigma_set)
    __swig_setmethods__["n"] = _sim2d.LJishPair_n_set
    __swig_getmethods__["n"] = _sim2d.LJishPair_n_get
    if _newclass:n = _swig_property(_sim2d.LJishPair_n_get, _sim2d.LJishPair_n_set)
    __swig_setmethods__["cutR"] = _sim2d.LJishPair_cutR_set
    __swig_getmethods__["cutR"] = _sim2d.LJishPair_cutR_get
    if _newclass:cutR = _swig_property(_sim2d.LJishPair_cutR_get, _sim2d.LJishPair_cutR_set)
    __swig_setmethods__["cutE"] = _sim2d.LJishPair_cutE_set
    __swig_getmethods__["cutE"] = _sim2d.LJishPair_cutE_get
    if _newclass:cutE = _swig_property(_sim2d.LJishPair_cutE_get, _sim2d.LJishPair_cutE_set)
    __swig_setmethods__["atom1"] = _sim2d.LJishPair_atom1_set
    __swig_getmethods__["atom1"] = _sim2d.LJishPair_atom1_get
    if _newclass:atom1 = _swig_property(_sim2d.LJishPair_atom1_get, _sim2d.LJishPair_atom1_set)
    __swig_setmethods__["atom2"] = _sim2d.LJishPair_atom2_set
    __swig_getmethods__["atom2"] = _sim2d.LJishPair_atom2_get
    if _newclass:atom2 = _swig_property(_sim2d.LJishPair_atom2_get, _sim2d.LJishPair_atom2_set)
    def __init__(self, *args): 
        """__init__(LJishPair self, LJishAtom LJ1, LJishAtom LJ2) -> LJishPair"""
        this = _sim2d.new_LJishPair(*args)
        try: self.this.append(this)
        except: self.this = this
    def energy(self, *args) -> "flt" :
        """energy(LJishPair self, Box box) -> flt"""
        return _sim2d.LJishPair_energy(self, *args)

    def forces(self, *args) -> "Vec" :
        """forces(LJishPair self, Box box) -> Vec"""
        return _sim2d.LJishPair_forces(self, *args)

    __swig_destroy__ = _sim2d.delete_LJishPair
    __del__ = lambda self : None;
LJishPair_swigregister = _sim2d.LJishPair_swigregister
LJishPair_swigregister(LJishPair)

class LJAttractRepulseAtom(atomid):
    """Proxy of C++ LJAttractRepulseAtom class"""
    __swig_setmethods__ = {}
    for _s in [atomid]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJAttractRepulseAtom, name, value)
    __swig_getmethods__ = {}
    for _s in [atomid]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LJAttractRepulseAtom, name)
    __repr__ = _swig_repr
    __swig_setmethods__["epsilons"] = _sim2d.LJAttractRepulseAtom_epsilons_set
    __swig_getmethods__["epsilons"] = _sim2d.LJAttractRepulseAtom_epsilons_get
    if _newclass:epsilons = _swig_property(_sim2d.LJAttractRepulseAtom_epsilons_get, _sim2d.LJAttractRepulseAtom_epsilons_set)
    __swig_setmethods__["sig"] = _sim2d.LJAttractRepulseAtom_sig_set
    __swig_getmethods__["sig"] = _sim2d.LJAttractRepulseAtom_sig_get
    if _newclass:sig = _swig_property(_sim2d.LJAttractRepulseAtom_sig_get, _sim2d.LJAttractRepulseAtom_sig_set)
    __swig_setmethods__["indx"] = _sim2d.LJAttractRepulseAtom_indx_set
    __swig_getmethods__["indx"] = _sim2d.LJAttractRepulseAtom_indx_get
    if _newclass:indx = _swig_property(_sim2d.LJAttractRepulseAtom_indx_get, _sim2d.LJAttractRepulseAtom_indx_set)
    __swig_setmethods__["sigcut"] = _sim2d.LJAttractRepulseAtom_sigcut_set
    __swig_getmethods__["sigcut"] = _sim2d.LJAttractRepulseAtom_sigcut_get
    if _newclass:sigcut = _swig_property(_sim2d.LJAttractRepulseAtom_sigcut_get, _sim2d.LJAttractRepulseAtom_sigcut_set)
    def __init__(self, *args): 
        """
        __init__(LJAttractRepulseAtom self, atom a, fvector epsilons, flt sigma, uint indx, flt cut) -> LJAttractRepulseAtom
        __init__(LJAttractRepulseAtom self, atomid a, LJAttractRepulseAtom other) -> LJAttractRepulseAtom
        """
        this = _sim2d.new_LJAttractRepulseAtom(*args)
        try: self.this.append(this)
        except: self.this = this
    def getEpsilon(self, *args) -> "flt" :
        """getEpsilon(LJAttractRepulseAtom self, LJAttractRepulseAtom other) -> flt"""
        return _sim2d.LJAttractRepulseAtom_getEpsilon(self, *args)

    __swig_destroy__ = _sim2d.delete_LJAttractRepulseAtom
    __del__ = lambda self : None;
LJAttractRepulseAtom_swigregister = _sim2d.LJAttractRepulseAtom_swigregister
LJAttractRepulseAtom_swigregister(LJAttractRepulseAtom)

class LJAttractRepulsePair(_object):
    """Proxy of C++ LJAttractRepulsePair class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJAttractRepulsePair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LJAttractRepulsePair, name)
    __repr__ = _swig_repr
    __swig_setmethods__["eps"] = _sim2d.LJAttractRepulsePair_eps_set
    __swig_getmethods__["eps"] = _sim2d.LJAttractRepulsePair_eps_get
    if _newclass:eps = _swig_property(_sim2d.LJAttractRepulsePair_eps_get, _sim2d.LJAttractRepulsePair_eps_set)
    __swig_setmethods__["sig"] = _sim2d.LJAttractRepulsePair_sig_set
    __swig_getmethods__["sig"] = _sim2d.LJAttractRepulsePair_sig_get
    if _newclass:sig = _swig_property(_sim2d.LJAttractRepulsePair_sig_get, _sim2d.LJAttractRepulsePair_sig_set)
    __swig_setmethods__["cutR"] = _sim2d.LJAttractRepulsePair_cutR_set
    __swig_getmethods__["cutR"] = _sim2d.LJAttractRepulsePair_cutR_get
    if _newclass:cutR = _swig_property(_sim2d.LJAttractRepulsePair_cutR_get, _sim2d.LJAttractRepulsePair_cutR_set)
    __swig_setmethods__["cutE"] = _sim2d.LJAttractRepulsePair_cutE_set
    __swig_getmethods__["cutE"] = _sim2d.LJAttractRepulsePair_cutE_get
    if _newclass:cutE = _swig_property(_sim2d.LJAttractRepulsePair_cutE_get, _sim2d.LJAttractRepulsePair_cutE_set)
    __swig_setmethods__["atom1"] = _sim2d.LJAttractRepulsePair_atom1_set
    __swig_getmethods__["atom1"] = _sim2d.LJAttractRepulsePair_atom1_get
    if _newclass:atom1 = _swig_property(_sim2d.LJAttractRepulsePair_atom1_get, _sim2d.LJAttractRepulsePair_atom1_set)
    __swig_setmethods__["atom2"] = _sim2d.LJAttractRepulsePair_atom2_set
    __swig_getmethods__["atom2"] = _sim2d.LJAttractRepulsePair_atom2_get
    if _newclass:atom2 = _swig_property(_sim2d.LJAttractRepulsePair_atom2_get, _sim2d.LJAttractRepulsePair_atom2_set)
    def __init__(self, *args): 
        """__init__(LJAttractRepulsePair self, LJAttractRepulseAtom a1, LJAttractRepulseAtom a2) -> LJAttractRepulsePair"""
        this = _sim2d.new_LJAttractRepulsePair(*args)
        try: self.this.append(this)
        except: self.this = this
    def energy(self, *args) -> "flt" :
        """energy(LJAttractRepulsePair self, Box box) -> flt"""
        return _sim2d.LJAttractRepulsePair_energy(self, *args)

    def forces(self, *args) -> "Vec" :
        """forces(LJAttractRepulsePair self, Box box) -> Vec"""
        return _sim2d.LJAttractRepulsePair_forces(self, *args)

    __swig_destroy__ = _sim2d.delete_LJAttractRepulsePair
    __del__ = lambda self : None;
LJAttractRepulsePair_swigregister = _sim2d.LJAttractRepulsePair_swigregister
LJAttractRepulsePair_swigregister(LJAttractRepulsePair)

class LJAttractFixedRepulseAtom(atomid):
    """Proxy of C++ LJAttractFixedRepulseAtom class"""
    __swig_setmethods__ = {}
    for _s in [atomid]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJAttractFixedRepulseAtom, name, value)
    __swig_getmethods__ = {}
    for _s in [atomid]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LJAttractFixedRepulseAtom, name)
    __repr__ = _swig_repr
    __swig_setmethods__["epsilons"] = _sim2d.LJAttractFixedRepulseAtom_epsilons_set
    __swig_getmethods__["epsilons"] = _sim2d.LJAttractFixedRepulseAtom_epsilons_get
    if _newclass:epsilons = _swig_property(_sim2d.LJAttractFixedRepulseAtom_epsilons_get, _sim2d.LJAttractFixedRepulseAtom_epsilons_set)
    __swig_setmethods__["repeps"] = _sim2d.LJAttractFixedRepulseAtom_repeps_set
    __swig_getmethods__["repeps"] = _sim2d.LJAttractFixedRepulseAtom_repeps_get
    if _newclass:repeps = _swig_property(_sim2d.LJAttractFixedRepulseAtom_repeps_get, _sim2d.LJAttractFixedRepulseAtom_repeps_set)
    __swig_setmethods__["sig"] = _sim2d.LJAttractFixedRepulseAtom_sig_set
    __swig_getmethods__["sig"] = _sim2d.LJAttractFixedRepulseAtom_sig_get
    if _newclass:sig = _swig_property(_sim2d.LJAttractFixedRepulseAtom_sig_get, _sim2d.LJAttractFixedRepulseAtom_sig_set)
    __swig_setmethods__["indx"] = _sim2d.LJAttractFixedRepulseAtom_indx_set
    __swig_getmethods__["indx"] = _sim2d.LJAttractFixedRepulseAtom_indx_get
    if _newclass:indx = _swig_property(_sim2d.LJAttractFixedRepulseAtom_indx_get, _sim2d.LJAttractFixedRepulseAtom_indx_set)
    __swig_setmethods__["sigcut"] = _sim2d.LJAttractFixedRepulseAtom_sigcut_set
    __swig_getmethods__["sigcut"] = _sim2d.LJAttractFixedRepulseAtom_sigcut_get
    if _newclass:sigcut = _swig_property(_sim2d.LJAttractFixedRepulseAtom_sigcut_get, _sim2d.LJAttractFixedRepulseAtom_sigcut_set)
    def __init__(self, *args): 
        """
        __init__(LJAttractFixedRepulseAtom self, atom a, fvector epsilons, flt repeps, flt sigma, uint indx, flt cut) -> LJAttractFixedRepulseAtom
        __init__(LJAttractFixedRepulseAtom self, atomid a, LJAttractFixedRepulseAtom other) -> LJAttractFixedRepulseAtom
        """
        this = _sim2d.new_LJAttractFixedRepulseAtom(*args)
        try: self.this.append(this)
        except: self.this = this
    def getEpsilon(self, *args) -> "flt" :
        """getEpsilon(LJAttractFixedRepulseAtom self, LJAttractFixedRepulseAtom other) -> flt"""
        return _sim2d.LJAttractFixedRepulseAtom_getEpsilon(self, *args)

    __swig_destroy__ = _sim2d.delete_LJAttractFixedRepulseAtom
    __del__ = lambda self : None;
LJAttractFixedRepulseAtom_swigregister = _sim2d.LJAttractFixedRepulseAtom_swigregister
LJAttractFixedRepulseAtom_swigregister(LJAttractFixedRepulseAtom)

class LJAttractFixedRepulsePair(_object):
    """Proxy of C++ LJAttractFixedRepulsePair class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJAttractFixedRepulsePair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LJAttractFixedRepulsePair, name)
    __repr__ = _swig_repr
    __swig_setmethods__["eps"] = _sim2d.LJAttractFixedRepulsePair_eps_set
    __swig_getmethods__["eps"] = _sim2d.LJAttractFixedRepulsePair_eps_get
    if _newclass:eps = _swig_property(_sim2d.LJAttractFixedRepulsePair_eps_get, _sim2d.LJAttractFixedRepulsePair_eps_set)
    __swig_setmethods__["repeps"] = _sim2d.LJAttractFixedRepulsePair_repeps_set
    __swig_getmethods__["repeps"] = _sim2d.LJAttractFixedRepulsePair_repeps_get
    if _newclass:repeps = _swig_property(_sim2d.LJAttractFixedRepulsePair_repeps_get, _sim2d.LJAttractFixedRepulsePair_repeps_set)
    __swig_setmethods__["sig"] = _sim2d.LJAttractFixedRepulsePair_sig_set
    __swig_getmethods__["sig"] = _sim2d.LJAttractFixedRepulsePair_sig_get
    if _newclass:sig = _swig_property(_sim2d.LJAttractFixedRepulsePair_sig_get, _sim2d.LJAttractFixedRepulsePair_sig_set)
    __swig_setmethods__["cutR"] = _sim2d.LJAttractFixedRepulsePair_cutR_set
    __swig_getmethods__["cutR"] = _sim2d.LJAttractFixedRepulsePair_cutR_get
    if _newclass:cutR = _swig_property(_sim2d.LJAttractFixedRepulsePair_cutR_get, _sim2d.LJAttractFixedRepulsePair_cutR_set)
    __swig_setmethods__["cutE"] = _sim2d.LJAttractFixedRepulsePair_cutE_set
    __swig_getmethods__["cutE"] = _sim2d.LJAttractFixedRepulsePair_cutE_get
    if _newclass:cutE = _swig_property(_sim2d.LJAttractFixedRepulsePair_cutE_get, _sim2d.LJAttractFixedRepulsePair_cutE_set)
    __swig_setmethods__["attract"] = _sim2d.LJAttractFixedRepulsePair_attract_set
    __swig_getmethods__["attract"] = _sim2d.LJAttractFixedRepulsePair_attract_get
    if _newclass:attract = _swig_property(_sim2d.LJAttractFixedRepulsePair_attract_get, _sim2d.LJAttractFixedRepulsePair_attract_set)
    __swig_setmethods__["atom1"] = _sim2d.LJAttractFixedRepulsePair_atom1_set
    __swig_getmethods__["atom1"] = _sim2d.LJAttractFixedRepulsePair_atom1_get
    if _newclass:atom1 = _swig_property(_sim2d.LJAttractFixedRepulsePair_atom1_get, _sim2d.LJAttractFixedRepulsePair_atom1_set)
    __swig_setmethods__["atom2"] = _sim2d.LJAttractFixedRepulsePair_atom2_set
    __swig_getmethods__["atom2"] = _sim2d.LJAttractFixedRepulsePair_atom2_get
    if _newclass:atom2 = _swig_property(_sim2d.LJAttractFixedRepulsePair_atom2_get, _sim2d.LJAttractFixedRepulsePair_atom2_set)
    def __init__(self, *args): 
        """
        __init__(LJAttractFixedRepulsePair self) -> LJAttractFixedRepulsePair
        __init__(LJAttractFixedRepulsePair self, LJAttractFixedRepulseAtom a1, LJAttractFixedRepulseAtom a2) -> LJAttractFixedRepulsePair
        """
        this = _sim2d.new_LJAttractFixedRepulsePair(*args)
        try: self.this.append(this)
        except: self.this = this
    def energy(self, *args) -> "flt" :
        """energy(LJAttractFixedRepulsePair self, Box box) -> flt"""
        return _sim2d.LJAttractFixedRepulsePair_energy(self, *args)

    def forces(self, *args) -> "Vec" :
        """forces(LJAttractFixedRepulsePair self, Box box) -> Vec"""
        return _sim2d.LJAttractFixedRepulsePair_forces(self, *args)

    __swig_destroy__ = _sim2d.delete_LJAttractFixedRepulsePair
    __del__ = lambda self : None;
LJAttractFixedRepulsePair_swigregister = _sim2d.LJAttractFixedRepulsePair_swigregister
LJAttractFixedRepulsePair_swigregister(LJAttractFixedRepulsePair)

class LJDoubleAtom(LJatom):
    """Proxy of C++ LJDoubleAtom class"""
    __swig_setmethods__ = {}
    for _s in [LJatom]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJDoubleAtom, name, value)
    __swig_getmethods__ = {}
    for _s in [LJatom]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LJDoubleAtom, name)
    __repr__ = _swig_repr
    __swig_setmethods__["epsrep"] = _sim2d.LJDoubleAtom_epsrep_set
    __swig_getmethods__["epsrep"] = _sim2d.LJDoubleAtom_epsrep_get
    if _newclass:epsrep = _swig_property(_sim2d.LJDoubleAtom_epsrep_get, _sim2d.LJDoubleAtom_epsrep_set)
    __swig_setmethods__["sigcut"] = _sim2d.LJDoubleAtom_sigcut_set
    __swig_getmethods__["sigcut"] = _sim2d.LJDoubleAtom_sigcut_get
    if _newclass:sigcut = _swig_property(_sim2d.LJDoubleAtom_sigcut_get, _sim2d.LJDoubleAtom_sigcut_set)
    def __init__(self, *args): 
        """
        __init__(LJDoubleAtom self, flt epsilon, flt epsrep, flt sigma, atom a, flt cut) -> LJDoubleAtom
        __init__(LJDoubleAtom self, atomid a, LJDoubleAtom other) -> LJDoubleAtom
        """
        this = _sim2d.new_LJDoubleAtom(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _sim2d.delete_LJDoubleAtom
    __del__ = lambda self : None;
LJDoubleAtom_swigregister = _sim2d.LJDoubleAtom_swigregister
LJDoubleAtom_swigregister(LJDoubleAtom)

class LJDoublePair(LJAttractFixedRepulsePair):
    """Proxy of C++ LJDoublePair class"""
    __swig_setmethods__ = {}
    for _s in [LJAttractFixedRepulsePair]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJDoublePair, name, value)
    __swig_getmethods__ = {}
    for _s in [LJAttractFixedRepulsePair]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LJDoublePair, name)
    __repr__ = _swig_repr
    __swig_setmethods__["eps"] = _sim2d.LJDoublePair_eps_set
    __swig_getmethods__["eps"] = _sim2d.LJDoublePair_eps_get
    if _newclass:eps = _swig_property(_sim2d.LJDoublePair_eps_get, _sim2d.LJDoublePair_eps_set)
    __swig_setmethods__["repeps"] = _sim2d.LJDoublePair_repeps_set
    __swig_getmethods__["repeps"] = _sim2d.LJDoublePair_repeps_get
    if _newclass:repeps = _swig_property(_sim2d.LJDoublePair_repeps_get, _sim2d.LJDoublePair_repeps_set)
    __swig_setmethods__["sig"] = _sim2d.LJDoublePair_sig_set
    __swig_getmethods__["sig"] = _sim2d.LJDoublePair_sig_get
    if _newclass:sig = _swig_property(_sim2d.LJDoublePair_sig_get, _sim2d.LJDoublePair_sig_set)
    __swig_setmethods__["cutR"] = _sim2d.LJDoublePair_cutR_set
    __swig_getmethods__["cutR"] = _sim2d.LJDoublePair_cutR_get
    if _newclass:cutR = _swig_property(_sim2d.LJDoublePair_cutR_get, _sim2d.LJDoublePair_cutR_set)
    __swig_setmethods__["cutE"] = _sim2d.LJDoublePair_cutE_set
    __swig_getmethods__["cutE"] = _sim2d.LJDoublePair_cutE_get
    if _newclass:cutE = _swig_property(_sim2d.LJDoublePair_cutE_get, _sim2d.LJDoublePair_cutE_set)
    __swig_setmethods__["attract"] = _sim2d.LJDoublePair_attract_set
    __swig_getmethods__["attract"] = _sim2d.LJDoublePair_attract_get
    if _newclass:attract = _swig_property(_sim2d.LJDoublePair_attract_get, _sim2d.LJDoublePair_attract_set)
    __swig_setmethods__["atom1"] = _sim2d.LJDoublePair_atom1_set
    __swig_getmethods__["atom1"] = _sim2d.LJDoublePair_atom1_get
    if _newclass:atom1 = _swig_property(_sim2d.LJDoublePair_atom1_get, _sim2d.LJDoublePair_atom1_set)
    __swig_setmethods__["atom2"] = _sim2d.LJDoublePair_atom2_set
    __swig_getmethods__["atom2"] = _sim2d.LJDoublePair_atom2_get
    if _newclass:atom2 = _swig_property(_sim2d.LJDoublePair_atom2_get, _sim2d.LJDoublePair_atom2_set)
    def __init__(self, *args): 
        """__init__(LJDoublePair self, LJDoubleAtom a1, LJDoubleAtom a2) -> LJDoublePair"""
        this = _sim2d.new_LJDoublePair(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _sim2d.delete_LJDoublePair
    __del__ = lambda self : None;
LJDoublePair_swigregister = _sim2d.LJDoublePair_swigregister
LJDoublePair_swigregister(LJDoublePair)

class EisMclachlanAtom(atomid):
    """Proxy of C++ EisMclachlanAtom class"""
    __swig_setmethods__ = {}
    for _s in [atomid]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, EisMclachlanAtom, name, value)
    __swig_getmethods__ = {}
    for _s in [atomid]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, EisMclachlanAtom, name)
    __repr__ = _swig_repr
    __swig_setmethods__["dist"] = _sim2d.EisMclachlanAtom_dist_set
    __swig_getmethods__["dist"] = _sim2d.EisMclachlanAtom_dist_get
    if _newclass:dist = _swig_property(_sim2d.EisMclachlanAtom_dist_get, _sim2d.EisMclachlanAtom_dist_set)
    __swig_setmethods__["sigmai"] = _sim2d.EisMclachlanAtom_sigmai_set
    __swig_getmethods__["sigmai"] = _sim2d.EisMclachlanAtom_sigmai_get
    if _newclass:sigmai = _swig_property(_sim2d.EisMclachlanAtom_sigmai_get, _sim2d.EisMclachlanAtom_sigmai_set)
    def __init__(self, *args): 
        """
        __init__(EisMclachlanAtom self, flt dist, flt sigmai, atom a) -> EisMclachlanAtom
        __init__(EisMclachlanAtom self, atomid a, EisMclachlanAtom other) -> EisMclachlanAtom
        """
        this = _sim2d.new_EisMclachlanAtom(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _sim2d.delete_EisMclachlanAtom
    __del__ = lambda self : None;
EisMclachlanAtom_swigregister = _sim2d.EisMclachlanAtom_swigregister
EisMclachlanAtom_swigregister(EisMclachlanAtom)

class EisMclachlanPair(_object):
    """Proxy of C++ EisMclachlanPair class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, EisMclachlanPair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, EisMclachlanPair, name)
    __repr__ = _swig_repr
    __swig_setmethods__["c0"] = _sim2d.EisMclachlanPair_c0_set
    __swig_getmethods__["c0"] = _sim2d.EisMclachlanPair_c0_get
    if _newclass:c0 = _swig_property(_sim2d.EisMclachlanPair_c0_get, _sim2d.EisMclachlanPair_c0_set)
    __swig_setmethods__["c1"] = _sim2d.EisMclachlanPair_c1_set
    __swig_getmethods__["c1"] = _sim2d.EisMclachlanPair_c1_get
    if _newclass:c1 = _swig_property(_sim2d.EisMclachlanPair_c1_get, _sim2d.EisMclachlanPair_c1_set)
    __swig_setmethods__["c2"] = _sim2d.EisMclachlanPair_c2_set
    __swig_getmethods__["c2"] = _sim2d.EisMclachlanPair_c2_get
    if _newclass:c2 = _swig_property(_sim2d.EisMclachlanPair_c2_get, _sim2d.EisMclachlanPair_c2_set)
    __swig_setmethods__["cutoff"] = _sim2d.EisMclachlanPair_cutoff_set
    __swig_getmethods__["cutoff"] = _sim2d.EisMclachlanPair_cutoff_get
    if _newclass:cutoff = _swig_property(_sim2d.EisMclachlanPair_cutoff_get, _sim2d.EisMclachlanPair_cutoff_set)
    __swig_setmethods__["atom1"] = _sim2d.EisMclachlanPair_atom1_set
    __swig_getmethods__["atom1"] = _sim2d.EisMclachlanPair_atom1_get
    if _newclass:atom1 = _swig_property(_sim2d.EisMclachlanPair_atom1_get, _sim2d.EisMclachlanPair_atom1_set)
    __swig_setmethods__["atom2"] = _sim2d.EisMclachlanPair_atom2_set
    __swig_getmethods__["atom2"] = _sim2d.EisMclachlanPair_atom2_get
    if _newclass:atom2 = _swig_property(_sim2d.EisMclachlanPair_atom2_get, _sim2d.EisMclachlanPair_atom2_set)
    def __init__(self, *args): 
        """__init__(EisMclachlanPair self, EisMclachlanAtom a1, EisMclachlanAtom a2) -> EisMclachlanPair"""
        this = _sim2d.new_EisMclachlanPair(*args)
        try: self.this.append(this)
        except: self.this = this
    def energy(self, *args) -> "flt" :
        """energy(EisMclachlanPair self, Box box) -> flt"""
        return _sim2d.EisMclachlanPair_energy(self, *args)

    def forces(self, *args) -> "Vec" :
        """forces(EisMclachlanPair self, Box box) -> Vec"""
        return _sim2d.EisMclachlanPair_forces(self, *args)

    __swig_destroy__ = _sim2d.delete_EisMclachlanPair
    __del__ = lambda self : None;
EisMclachlanPair_swigregister = _sim2d.EisMclachlanPair_swigregister
EisMclachlanPair_swigregister(EisMclachlanPair)

class HertzianAtom(atomid):
    """Proxy of C++ HertzianAtom class"""
    __swig_setmethods__ = {}
    for _s in [atomid]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HertzianAtom, name, value)
    __swig_getmethods__ = {}
    for _s in [atomid]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, HertzianAtom, name)
    __repr__ = _swig_repr
    __swig_setmethods__["eps"] = _sim2d.HertzianAtom_eps_set
    __swig_getmethods__["eps"] = _sim2d.HertzianAtom_eps_get
    if _newclass:eps = _swig_property(_sim2d.HertzianAtom_eps_get, _sim2d.HertzianAtom_eps_set)
    __swig_setmethods__["sigma"] = _sim2d.HertzianAtom_sigma_set
    __swig_getmethods__["sigma"] = _sim2d.HertzianAtom_sigma_get
    if _newclass:sigma = _swig_property(_sim2d.HertzianAtom_sigma_get, _sim2d.HertzianAtom_sigma_set)
    __swig_setmethods__["exponent"] = _sim2d.HertzianAtom_exponent_set
    __swig_getmethods__["exponent"] = _sim2d.HertzianAtom_exponent_get
    if _newclass:exponent = _swig_property(_sim2d.HertzianAtom_exponent_get, _sim2d.HertzianAtom_exponent_set)
    def __init__(self, *args): 
        """
        __init__(HertzianAtom self, atom a, flt eps, flt sigma, flt exponent=2.5) -> HertzianAtom
        __init__(HertzianAtom self, atom a, flt eps, flt sigma) -> HertzianAtom
        __init__(HertzianAtom self, atomid a, HertzianAtom other) -> HertzianAtom
        """
        this = _sim2d.new_HertzianAtom(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _sim2d.delete_HertzianAtom
    __del__ = lambda self : None;
HertzianAtom_swigregister = _sim2d.HertzianAtom_swigregister
HertzianAtom_swigregister(HertzianAtom)

class HertzianPair(_object):
    """Proxy of C++ HertzianPair class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, HertzianPair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, HertzianPair, name)
    __repr__ = _swig_repr
    __swig_setmethods__["eps"] = _sim2d.HertzianPair_eps_set
    __swig_getmethods__["eps"] = _sim2d.HertzianPair_eps_get
    if _newclass:eps = _swig_property(_sim2d.HertzianPair_eps_get, _sim2d.HertzianPair_eps_set)
    __swig_setmethods__["sig"] = _sim2d.HertzianPair_sig_set
    __swig_getmethods__["sig"] = _sim2d.HertzianPair_sig_get
    if _newclass:sig = _swig_property(_sim2d.HertzianPair_sig_get, _sim2d.HertzianPair_sig_set)
    __swig_setmethods__["exponent"] = _sim2d.HertzianPair_exponent_set
    __swig_getmethods__["exponent"] = _sim2d.HertzianPair_exponent_get
    if _newclass:exponent = _swig_property(_sim2d.HertzianPair_exponent_get, _sim2d.HertzianPair_exponent_set)
    __swig_setmethods__["atom1"] = _sim2d.HertzianPair_atom1_set
    __swig_getmethods__["atom1"] = _sim2d.HertzianPair_atom1_get
    if _newclass:atom1 = _swig_property(_sim2d.HertzianPair_atom1_get, _sim2d.HertzianPair_atom1_set)
    __swig_setmethods__["atom2"] = _sim2d.HertzianPair_atom2_set
    __swig_getmethods__["atom2"] = _sim2d.HertzianPair_atom2_get
    if _newclass:atom2 = _swig_property(_sim2d.HertzianPair_atom2_get, _sim2d.HertzianPair_atom2_set)
    def __init__(self, *args): 
        """__init__(HertzianPair self, HertzianAtom a1, HertzianAtom a2) -> HertzianPair"""
        this = _sim2d.new_HertzianPair(*args)
        try: self.this.append(this)
        except: self.this = this
    def energy(self, *args) -> "flt" :
        """energy(HertzianPair self, Box box) -> flt"""
        return _sim2d.HertzianPair_energy(self, *args)

    def forces(self, *args) -> "Vec" :
        """forces(HertzianPair self, Box box) -> Vec"""
        return _sim2d.HertzianPair_forces(self, *args)

    def fill(self, *args) -> "void" :
        """fill(HertzianPair self, Box box, forcepairx fpair)"""
        return _sim2d.HertzianPair_fill(self, *args)

    __swig_destroy__ = _sim2d.delete_HertzianPair
    __del__ = lambda self : None;
HertzianPair_swigregister = _sim2d.HertzianPair_swigregister
HertzianPair_swigregister(HertzianPair)

class LJsimple(interaction):
    """Proxy of C++ LJsimple class"""
    __swig_setmethods__ = {}
    for _s in [interaction]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJsimple, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LJsimple, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(LJsimple self, flt cutoffdist, std::vector< LJatom > atms=std::vector< LJatom >()) -> LJsimple
        __init__(LJsimple self, flt cutoffdist) -> LJsimple
        """
        this = _sim2d.new_LJsimple(*args)
        try: self.this.append(this)
        except: self.this = this
    def add(self, *args) -> "void" :
        """
        add(LJsimple self, LJatom a)
        add(LJsimple self, atom a, flt epsilon, flt sigma)
        """
        return _sim2d.LJsimple_add(self, *args)

    def ignore(self, *args) -> "void" :
        """
        ignore(LJsimple self, atomid a, atomid b)
        ignore(LJsimple self, atom a, atom b)
        """
        return _sim2d.LJsimple_ignore(self, *args)

    def ignore_size(self) -> "uint" :
        """ignore_size(LJsimple self) -> uint"""
        return _sim2d.LJsimple_ignore_size(self)

    def atoms_size(self) -> "uint" :
        """atoms_size(LJsimple self) -> uint"""
        return _sim2d.LJsimple_atoms_size(self)

    def energy(self, *args) -> "flt" :
        """energy(LJsimple self, Box box) -> flt"""
        return _sim2d.LJsimple_energy(self, *args)

    def pressure(self, *args) -> "flt" :
        """pressure(LJsimple self, Box box) -> flt"""
        return _sim2d.LJsimple_pressure(self, *args)

    def setForces(self, *args) -> "void" :
        """setForces(LJsimple self, Box box)"""
        return _sim2d.LJsimple_setForces(self, *args)

    __swig_destroy__ = _sim2d.delete_LJsimple
    __del__ = lambda self : None;
LJsimple_swigregister = _sim2d.LJsimple_swigregister
LJsimple_swigregister(LJsimple)

class Charges(interaction):
    """Proxy of C++ Charges class"""
    __swig_setmethods__ = {}
    for _s in [interaction]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Charges, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Charges, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(Charges self, flt screenlength, flt k=1, std::vector< Charged > atms=std::vector< Charged >()) -> Charges
        __init__(Charges self, flt screenlength, flt k=1) -> Charges
        __init__(Charges self, flt screenlength) -> Charges
        """
        this = _sim2d.new_Charges(*args)
        try: self.this.append(this)
        except: self.this = this
    def add(self, *args) -> "void" :
        """
        add(Charges self, Charged a)
        add(Charges self, atom a, flt q)
        """
        return _sim2d.Charges_add(self, *args)

    def ignore(self, *args) -> "void" :
        """
        ignore(Charges self, atomid a, atomid b)
        ignore(Charges self, atom a, atom b)
        """
        return _sim2d.Charges_ignore(self, *args)

    def ignore_size(self) -> "uint" :
        """ignore_size(Charges self) -> uint"""
        return _sim2d.Charges_ignore_size(self)

    def size(self) -> "uint" :
        """size(Charges self) -> uint"""
        return _sim2d.Charges_size(self)

    def energy(self, *args) -> "flt" :
        """energy(Charges self, Box box) -> flt"""
        return _sim2d.Charges_energy(self, *args)

    def pressure(self, *args) -> "flt" :
        """pressure(Charges self, Box box) -> flt"""
        return _sim2d.Charges_pressure(self, *args)

    def setForces(self, *args) -> "void" :
        """setForces(Charges self, Box box)"""
        return _sim2d.Charges_setForces(self, *args)

    __swig_destroy__ = _sim2d.delete_Charges
    __del__ = lambda self : None;
Charges_swigregister = _sim2d.Charges_swigregister
Charges_swigregister(Charges)


def toBuffer(*args) -> "bool" :
  """toBuffer(std::vector< Vec *,std::allocator< Vec * > > arr, double * buffer) -> bool"""
  return _sim2d.toBuffer(*args)
class jamminglist(_object):
    """Proxy of C++ jamminglist class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, jamminglist, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, jamminglist, name)
    __repr__ = _swig_repr
    __swig_setmethods__["assigned"] = _sim2d.jamminglist_assigned_set
    __swig_getmethods__["assigned"] = _sim2d.jamminglist_assigned_get
    if _newclass:assigned = _swig_property(_sim2d.jamminglist_assigned_get, _sim2d.jamminglist_assigned_set)
    __swig_setmethods__["distsq"] = _sim2d.jamminglist_distsq_set
    __swig_getmethods__["distsq"] = _sim2d.jamminglist_distsq_get
    if _newclass:distsq = _swig_property(_sim2d.jamminglist_distsq_get, _sim2d.jamminglist_distsq_set)
    def __init__(self, *args): 
        """
        __init__(jamminglist self) -> jamminglist
        __init__(jamminglist self, jamminglist other) -> jamminglist
        __init__(jamminglist self, jamminglist other, uint expand, flt addeddist) -> jamminglist
        """
        this = _sim2d.new_jamminglist(*args)
        try: self.this.append(this)
        except: self.this = this
    def size(self) -> "uint" :
        """size(jamminglist self) -> uint"""
        return _sim2d.jamminglist_size(self)

    def __lt__(self, *args) -> "bool" :
        """__lt__(jamminglist self, jamminglist other) -> bool"""
        return _sim2d.jamminglist___lt__(self, *args)

    __swig_destroy__ = _sim2d.delete_jamminglist
    __del__ = lambda self : None;
jamminglist_swigregister = _sim2d.jamminglist_swigregister
jamminglist_swigregister(jamminglist)

class jammingtree(_object):
    """Proxy of C++ jammingtree class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, jammingtree, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, jammingtree, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(jammingtree self, Box box, vecvector A, vecvector B) -> jammingtree"""
        this = _sim2d.new_jammingtree(*args)
        try: self.this.append(this)
        except: self.this = this
    def expand(self, *args) -> "bool" :
        """
        expand(jammingtree self) -> bool
        expand(jammingtree self, uint n) -> bool
        """
        return _sim2d.jammingtree_expand(self, *args)

    def mylist(self) -> "std::list< jamminglist > &" :
        """mylist(jammingtree self) -> _jamminglist"""
        return _sim2d.jammingtree_mylist(self)

    def copylist(self) -> "std::list< jamminglist >" :
        """copylist(jammingtree self) -> _jamminglist"""
        return _sim2d.jammingtree_copylist(self)

    def curbest(self) -> "jamminglist" :
        """curbest(jammingtree self) -> jamminglist"""
        return _sim2d.jammingtree_curbest(self)

    def size(self) -> "uint" :
        """size(jammingtree self) -> uint"""
        return _sim2d.jammingtree_size(self)

    __swig_destroy__ = _sim2d.delete_jammingtree
    __del__ = lambda self : None;
jammingtree_swigregister = _sim2d.jammingtree_swigregister
jammingtree_swigregister(jammingtree)

class jamminglistrot(jamminglist):
    """Proxy of C++ jamminglistrot class"""
    __swig_setmethods__ = {}
    for _s in [jamminglist]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, jamminglistrot, name, value)
    __swig_getmethods__ = {}
    for _s in [jamminglist]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, jamminglistrot, name)
    __repr__ = _swig_repr
    __swig_setmethods__["rotation"] = _sim2d.jamminglistrot_rotation_set
    __swig_getmethods__["rotation"] = _sim2d.jamminglistrot_rotation_get
    if _newclass:rotation = _swig_property(_sim2d.jamminglistrot_rotation_get, _sim2d.jamminglistrot_rotation_set)
    def __init__(self, *args): 
        """
        __init__(jamminglistrot self) -> jamminglistrot
        __init__(jamminglistrot self, uint rot) -> jamminglistrot
        __init__(jamminglistrot self, jamminglistrot other) -> jamminglistrot
        __init__(jamminglistrot self, jamminglistrot other, uint expand, flt addeddist) -> jamminglistrot
        """
        this = _sim2d.new_jamminglistrot(*args)
        try: self.this.append(this)
        except: self.this = this
    def __lt__(self, *args) -> "bool" :
        """__lt__(jamminglistrot self, jamminglistrot other) -> bool"""
        return _sim2d.jamminglistrot___lt__(self, *args)

    __swig_destroy__ = _sim2d.delete_jamminglistrot
    __del__ = lambda self : None;
jamminglistrot_swigregister = _sim2d.jamminglistrot_swigregister
jamminglistrot_swigregister(jamminglistrot)

class jammingtree2(_object):
    """Proxy of C++ jammingtree2 class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, jammingtree2, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, jammingtree2, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(jammingtree2 self, Box box, vecvector A, vecvector B) -> jammingtree2"""
        this = _sim2d.new_jammingtree2(*args)
        try: self.this.append(this)
        except: self.this = this
    def distance(self, *args) -> "flt" :
        """distance(jammingtree2 self, jamminglistrot jlist) -> flt"""
        return _sim2d.jammingtree2_distance(self, *args)

    def expand(self, *args) -> "bool" :
        """
        expand(jammingtree2 self, jamminglistrot curjlist) -> _jamminglistrot
        expand(jammingtree2 self) -> bool
        expand(jammingtree2 self, uint n) -> bool
        """
        return _sim2d.jammingtree2_expand(self, *args)

    def expandto(self, *args) -> "bool" :
        """expandto(jammingtree2 self, flt maxdistsq) -> bool"""
        return _sim2d.jammingtree2_expandto(self, *args)

    def mylist(self) -> "std::list< jamminglistrot > &" :
        """mylist(jammingtree2 self) -> _jamminglistrot"""
        return _sim2d.jammingtree2_mylist(self)

    def copylist(self, *args) -> "std::list< jamminglistrot >" :
        """
        copylist(jammingtree2 self) -> _jamminglistrot
        copylist(jammingtree2 self, uint n) -> _jamminglistrot
        """
        return _sim2d.jammingtree2_copylist(self, *args)

    def curbest(self) -> "jamminglistrot" :
        """curbest(jammingtree2 self) -> jamminglistrot"""
        return _sim2d.jammingtree2_curbest(self)

    def size(self) -> "uint" :
        """size(jammingtree2 self) -> uint"""
        return _sim2d.jammingtree2_size(self)

    def locationsB(self, *args) -> "std::vector< Vec >" :
        """
        locationsB(jammingtree2 self, jamminglistrot jlist) -> vecvector
        locationsB(jammingtree2 self) -> vecvector
        """
        return _sim2d.jammingtree2_locationsB(self, *args)

    def locationsA(self, *args) -> "std::vector< Vec >" :
        """
        locationsA(jammingtree2 self, jamminglistrot jlist) -> vecvector
        locationsA(jammingtree2 self) -> vecvector
        """
        return _sim2d.jammingtree2_locationsA(self, *args)

    __swig_destroy__ = _sim2d.delete_jammingtree2
    __del__ = lambda self : None;
jammingtree2_swigregister = _sim2d.jammingtree2_swigregister
jammingtree2_swigregister(jammingtree2)

class jammingtreeBD(jammingtree2):
    """Proxy of C++ jammingtreeBD class"""
    __swig_setmethods__ = {}
    for _s in [jammingtree2]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, jammingtreeBD, name, value)
    __swig_getmethods__ = {}
    for _s in [jammingtree2]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, jammingtreeBD, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(jammingtreeBD self, Box box, vecvector A, vecvector B, uint cutoff) -> jammingtreeBD
        __init__(jammingtreeBD self, Box box, vecvector A, vecvector B, uint cutoffA, uint cutoffB) -> jammingtreeBD
        """
        this = _sim2d.new_jammingtreeBD(*args)
        try: self.this.append(this)
        except: self.this = this
    def expand(self, *args) -> "bool" :
        """
        expand(jammingtreeBD self, jamminglistrot curjlist) -> _jamminglistrot
        expand(jammingtreeBD self) -> bool
        expand(jammingtreeBD self, uint n) -> bool
        """
        return _sim2d.jammingtreeBD_expand(self, *args)

    __swig_destroy__ = _sim2d.delete_jammingtreeBD
    __del__ = lambda self : None;
jammingtreeBD_swigregister = _sim2d.jammingtreeBD_swigregister
jammingtreeBD_swigregister(jammingtreeBD)

class constraint(_object):
    """Proxy of C++ constraint class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, constraint, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, constraint, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def apply(self, *args) -> "void" :
        """apply(constraint self, Box box)"""
        return _sim2d.constraint_apply(self, *args)

    def ndof(self) -> "int" :
        """ndof(constraint self) -> int"""
        return _sim2d.constraint_ndof(self)

    __swig_destroy__ = _sim2d.delete_constraint
    __del__ = lambda self : None;
constraint_swigregister = _sim2d.constraint_swigregister
constraint_swigregister(constraint)

class coordConstraint(constraint):
    """Proxy of C++ coordConstraint class"""
    __swig_setmethods__ = {}
    for _s in [constraint]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, coordConstraint, name, value)
    __swig_getmethods__ = {}
    for _s in [constraint]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, coordConstraint, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(coordConstraint self, atom atm, bool fixx, bool fixy, bool fixz, Vec loc) -> coordConstraint
        __init__(coordConstraint self, atom atm, bool fixx, bool fixy, bool fixz) -> coordConstraint
        __init__(coordConstraint self, atom atm) -> coordConstraint
        """
        this = _sim2d.new_coordConstraint(*args)
        try: self.this.append(this)
        except: self.this = this
    def ndof(self) -> "int" :
        """ndof(coordConstraint self) -> int"""
        return _sim2d.coordConstraint_ndof(self)

    def apply(self, *args) -> "void" :
        """apply(coordConstraint self, Box box)"""
        return _sim2d.coordConstraint_apply(self, *args)

    __swig_destroy__ = _sim2d.delete_coordConstraint
    __del__ = lambda self : None;
coordConstraint_swigregister = _sim2d.coordConstraint_swigregister
coordConstraint_swigregister(coordConstraint)

class coordCOMConstraint(constraint):
    """Proxy of C++ coordCOMConstraint class"""
    __swig_setmethods__ = {}
    for _s in [constraint]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, coordCOMConstraint, name, value)
    __swig_getmethods__ = {}
    for _s in [constraint]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, coordCOMConstraint, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(coordCOMConstraint self, atomgroup atm, bool fixx, bool fixy, bool fixz, Vec loc) -> coordCOMConstraint
        __init__(coordCOMConstraint self, atomgroup atm, bool fixx, bool fixy, bool fixz) -> coordCOMConstraint
        __init__(coordCOMConstraint self, atomgroup atm) -> coordCOMConstraint
        """
        this = _sim2d.new_coordCOMConstraint(*args)
        try: self.this.append(this)
        except: self.this = this
    def ndof(self) -> "int" :
        """ndof(coordCOMConstraint self) -> int"""
        return _sim2d.coordCOMConstraint_ndof(self)

    def apply(self, *args) -> "void" :
        """apply(coordCOMConstraint self, Box box)"""
        return _sim2d.coordCOMConstraint_apply(self, *args)

    __swig_destroy__ = _sim2d.delete_coordCOMConstraint
    __del__ = lambda self : None;
coordCOMConstraint_swigregister = _sim2d.coordCOMConstraint_swigregister
coordCOMConstraint_swigregister(coordCOMConstraint)

class relativeConstraint(constraint):
    """Proxy of C++ relativeConstraint class"""
    __swig_setmethods__ = {}
    for _s in [constraint]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, relativeConstraint, name, value)
    __swig_getmethods__ = {}
    for _s in [constraint]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, relativeConstraint, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(relativeConstraint self, atom atm1, atom atm2, bool fixx, bool fixy, bool fixz, Vec loc) -> relativeConstraint
        __init__(relativeConstraint self, atom atm1, atom atm2, bool fixx, bool fixy, bool fixz) -> relativeConstraint
        __init__(relativeConstraint self, atom atm1, atom atm2) -> relativeConstraint
        """
        this = _sim2d.new_relativeConstraint(*args)
        try: self.this.append(this)
        except: self.this = this
    def ndof(self) -> "int" :
        """ndof(relativeConstraint self) -> int"""
        return _sim2d.relativeConstraint_ndof(self)

    def apply(self, *args) -> "void" :
        """apply(relativeConstraint self, Box box)"""
        return _sim2d.relativeConstraint_apply(self, *args)

    __swig_destroy__ = _sim2d.delete_relativeConstraint
    __del__ = lambda self : None;
relativeConstraint_swigregister = _sim2d.relativeConstraint_swigregister
relativeConstraint_swigregister(relativeConstraint)

class NPHGaussianConstraint(constraint):
    """Proxy of C++ NPHGaussianConstraint class"""
    __swig_setmethods__ = {}
    for _s in [constraint]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, NPHGaussianConstraint, name, value)
    __swig_getmethods__ = {}
    for _s in [constraint]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, NPHGaussianConstraint, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(NPHGaussianConstraint self, OriginBox box, avector groups) -> NPHGaussianConstraint"""
        this = _sim2d.new_NPHGaussianConstraint(*args)
        try: self.this.append(this)
        except: self.this = this
    def ndof(self) -> "int" :
        """ndof(NPHGaussianConstraint self) -> int"""
        return _sim2d.NPHGaussianConstraint_ndof(self)

    def apply(self, *args) -> "void" :
        """apply(NPHGaussianConstraint self, Box box2)"""
        return _sim2d.NPHGaussianConstraint_apply(self, *args)

    __swig_destroy__ = _sim2d.delete_NPHGaussianConstraint
    __del__ = lambda self : None;
NPHGaussianConstraint_swigregister = _sim2d.NPHGaussianConstraint_swigregister
NPHGaussianConstraint_swigregister(NPHGaussianConstraint)

class LJgroup(interaction):
    """Proxy of C++ NListed<(LJatom,LJpair)> class"""
    __swig_setmethods__ = {}
    for _s in [interaction]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJgroup, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LJgroup, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(NListed<(LJatom,LJpair)> self, neighborlist neighbors) -> LJgroup"""
        this = _sim2d.new_LJgroup(*args)
        try: self.this.append(this)
        except: self.this = this
    def add(self, *args) -> "void" :
        """add(LJgroup self, LJatom atm)"""
        return _sim2d.LJgroup_add(self, *args)

    def update_pairs(self) -> "void" :
        """update_pairs(LJgroup self)"""
        return _sim2d.LJgroup_update_pairs(self)

    def getpair(self, *args) -> "LJpair" :
        """getpair(LJgroup self, idpair pair) -> LJpair"""
        return _sim2d.LJgroup_getpair(self, *args)

    def energy(self, *args) -> "flt" :
        """
        energy(LJgroup self, Box box, idpair pair) -> flt
        energy(LJgroup self, Box box) -> flt
        """
        return _sim2d.LJgroup_energy(self, *args)

    def pressure(self, *args) -> "flt" :
        """pressure(LJgroup self, Box box) -> flt"""
        return _sim2d.LJgroup_pressure(self, *args)

    def size(self) -> "uint" :
        """size(LJgroup self) -> uint"""
        return _sim2d.LJgroup_size(self)

    def energy_pair(self, *args) -> "flt" :
        """energy_pair(LJgroup self, LJpair pair, Box box) -> flt"""
        return _sim2d.LJgroup_energy_pair(self, *args)

    def setForces(self, *args) -> "void" :
        """setForces(LJgroup self, Box box)"""
        return _sim2d.LJgroup_setForces(self, *args)

    def setForcesGetPressure(self, *args) -> "flt" :
        """setForcesGetPressure(LJgroup self, Box box) -> flt"""
        return _sim2d.LJgroup_setForcesGetPressure(self, *args)

    def forces_pair(self, *args) -> "Vec" :
        """forces_pair(LJgroup self, LJpair pair, Box box) -> Vec"""
        return _sim2d.LJgroup_forces_pair(self, *args)

    def atom_list(self) -> "std::vector< LJatom > &" :
        """atom_list(LJgroup self) -> std::vector< LJatom > &"""
        return _sim2d.LJgroup_atom_list(self)

    def nlist(self) -> "neighborlist *" :
        """nlist(LJgroup self) -> neighborlist"""
        return _sim2d.LJgroup_nlist(self)

    __swig_destroy__ = _sim2d.delete_LJgroup
    __del__ = lambda self : None;
    def add_atom(self, epsilon, sigma, a):
        self.add(LJatom(epsilon, sigma, a))

LJgroup_swigregister = _sim2d.LJgroup_swigregister
LJgroup_swigregister(LJgroup)

class LJfull(interaction):
    """Proxy of C++ NListed<(LJatomcut,LJAttractPair)> class"""
    __swig_setmethods__ = {}
    for _s in [interaction]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJfull, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LJfull, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(NListed<(LJatomcut,LJAttractPair)> self, neighborlist neighbors) -> LJfull"""
        this = _sim2d.new_LJfull(*args)
        try: self.this.append(this)
        except: self.this = this
    def add(self, *args) -> "void" :
        """add(LJfull self, LJatomcut atm)"""
        return _sim2d.LJfull_add(self, *args)

    def update_pairs(self) -> "void" :
        """update_pairs(LJfull self)"""
        return _sim2d.LJfull_update_pairs(self)

    def getpair(self, *args) -> "LJAttractPair" :
        """getpair(LJfull self, idpair pair) -> LJAttractPair"""
        return _sim2d.LJfull_getpair(self, *args)

    def energy(self, *args) -> "flt" :
        """
        energy(LJfull self, Box box, idpair pair) -> flt
        energy(LJfull self, Box box) -> flt
        """
        return _sim2d.LJfull_energy(self, *args)

    def pressure(self, *args) -> "flt" :
        """pressure(LJfull self, Box box) -> flt"""
        return _sim2d.LJfull_pressure(self, *args)

    def size(self) -> "uint" :
        """size(LJfull self) -> uint"""
        return _sim2d.LJfull_size(self)

    def energy_pair(self, *args) -> "flt" :
        """energy_pair(LJfull self, LJAttractPair pair, Box box) -> flt"""
        return _sim2d.LJfull_energy_pair(self, *args)

    def setForces(self, *args) -> "void" :
        """setForces(LJfull self, Box box)"""
        return _sim2d.LJfull_setForces(self, *args)

    def setForcesGetPressure(self, *args) -> "flt" :
        """setForcesGetPressure(LJfull self, Box box) -> flt"""
        return _sim2d.LJfull_setForcesGetPressure(self, *args)

    def forces_pair(self, *args) -> "Vec" :
        """forces_pair(LJfull self, LJAttractPair pair, Box box) -> Vec"""
        return _sim2d.LJfull_forces_pair(self, *args)

    def atom_list(self) -> "std::vector< LJatomcut > &" :
        """atom_list(LJfull self) -> std::vector< LJatomcut > &"""
        return _sim2d.LJfull_atom_list(self)

    def nlist(self) -> "neighborlist *" :
        """nlist(LJfull self) -> neighborlist"""
        return _sim2d.LJfull_nlist(self)

    __swig_destroy__ = _sim2d.delete_LJfull
    __del__ = lambda self : None;
    def add_atom(self, epsilon, sigma, a, cut):
        self.add(LJatomcut(epsilon, sigma, a, cut))

LJfull_swigregister = _sim2d.LJfull_swigregister
LJfull_swigregister(LJfull)

class Hydrophobicity(interaction):
    """Proxy of C++ NListed<(HydroAtom,HydroPair)> class"""
    __swig_setmethods__ = {}
    for _s in [interaction]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Hydrophobicity, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Hydrophobicity, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(NListed<(HydroAtom,HydroPair)> self, neighborlist neighbors) -> Hydrophobicity"""
        this = _sim2d.new_Hydrophobicity(*args)
        try: self.this.append(this)
        except: self.this = this
    def add(self, *args) -> "void" :
        """add(Hydrophobicity self, HydroAtom atm)"""
        return _sim2d.Hydrophobicity_add(self, *args)

    def update_pairs(self) -> "void" :
        """update_pairs(Hydrophobicity self)"""
        return _sim2d.Hydrophobicity_update_pairs(self)

    def getpair(self, *args) -> "HydroPair" :
        """getpair(Hydrophobicity self, idpair pair) -> HydroPair"""
        return _sim2d.Hydrophobicity_getpair(self, *args)

    def energy(self, *args) -> "flt" :
        """
        energy(Hydrophobicity self, Box box, idpair pair) -> flt
        energy(Hydrophobicity self, Box box) -> flt
        """
        return _sim2d.Hydrophobicity_energy(self, *args)

    def pressure(self, *args) -> "flt" :
        """pressure(Hydrophobicity self, Box box) -> flt"""
        return _sim2d.Hydrophobicity_pressure(self, *args)

    def size(self) -> "uint" :
        """size(Hydrophobicity self) -> uint"""
        return _sim2d.Hydrophobicity_size(self)

    def energy_pair(self, *args) -> "flt" :
        """energy_pair(Hydrophobicity self, HydroPair pair, Box box) -> flt"""
        return _sim2d.Hydrophobicity_energy_pair(self, *args)

    def setForces(self, *args) -> "void" :
        """setForces(Hydrophobicity self, Box box)"""
        return _sim2d.Hydrophobicity_setForces(self, *args)

    def setForcesGetPressure(self, *args) -> "flt" :
        """setForcesGetPressure(Hydrophobicity self, Box box) -> flt"""
        return _sim2d.Hydrophobicity_setForcesGetPressure(self, *args)

    def forces_pair(self, *args) -> "Vec" :
        """forces_pair(Hydrophobicity self, HydroPair pair, Box box) -> Vec"""
        return _sim2d.Hydrophobicity_forces_pair(self, *args)

    def atom_list(self) -> "std::vector< HydroAtom > &" :
        """atom_list(Hydrophobicity self) -> std::vector< HydroAtom > &"""
        return _sim2d.Hydrophobicity_atom_list(self)

    def nlist(self) -> "neighborlist *" :
        """nlist(Hydrophobicity self) -> neighborlist"""
        return _sim2d.Hydrophobicity_nlist(self)

    __swig_destroy__ = _sim2d.delete_Hydrophobicity
    __del__ = lambda self : None;
Hydrophobicity_swigregister = _sim2d.Hydrophobicity_swigregister
Hydrophobicity_swigregister(Hydrophobicity)

class LJdetailed(interaction):
    """Proxy of C++ NListed<(LJAtomIndexed,LJFullPair)> class"""
    __swig_setmethods__ = {}
    for _s in [interaction]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJdetailed, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LJdetailed, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(NListed<(LJAtomIndexed,LJFullPair)> self, neighborlist neighbors) -> LJdetailed"""
        this = _sim2d.new_LJdetailed(*args)
        try: self.this.append(this)
        except: self.this = this
    def add(self, *args) -> "void" :
        """add(LJdetailed self, LJAtomIndexed atm)"""
        return _sim2d.LJdetailed_add(self, *args)

    def update_pairs(self) -> "void" :
        """update_pairs(LJdetailed self)"""
        return _sim2d.LJdetailed_update_pairs(self)

    def getpair(self, *args) -> "LJFullPair" :
        """getpair(LJdetailed self, idpair pair) -> LJFullPair"""
        return _sim2d.LJdetailed_getpair(self, *args)

    def energy(self, *args) -> "flt" :
        """
        energy(LJdetailed self, Box box, idpair pair) -> flt
        energy(LJdetailed self, Box box) -> flt
        """
        return _sim2d.LJdetailed_energy(self, *args)

    def pressure(self, *args) -> "flt" :
        """pressure(LJdetailed self, Box box) -> flt"""
        return _sim2d.LJdetailed_pressure(self, *args)

    def size(self) -> "uint" :
        """size(LJdetailed self) -> uint"""
        return _sim2d.LJdetailed_size(self)

    def energy_pair(self, *args) -> "flt" :
        """energy_pair(LJdetailed self, LJFullPair pair, Box box) -> flt"""
        return _sim2d.LJdetailed_energy_pair(self, *args)

    def setForces(self, *args) -> "void" :
        """setForces(LJdetailed self, Box box)"""
        return _sim2d.LJdetailed_setForces(self, *args)

    def setForcesGetPressure(self, *args) -> "flt" :
        """setForcesGetPressure(LJdetailed self, Box box) -> flt"""
        return _sim2d.LJdetailed_setForcesGetPressure(self, *args)

    def forces_pair(self, *args) -> "Vec" :
        """forces_pair(LJdetailed self, LJFullPair pair, Box box) -> Vec"""
        return _sim2d.LJdetailed_forces_pair(self, *args)

    def atom_list(self) -> "std::vector< LJAtomIndexed > &" :
        """atom_list(LJdetailed self) -> std::vector< LJAtomIndexed > &"""
        return _sim2d.LJdetailed_atom_list(self)

    def nlist(self) -> "neighborlist *" :
        """nlist(LJdetailed self) -> neighborlist"""
        return _sim2d.LJdetailed_nlist(self)

    __swig_destroy__ = _sim2d.delete_LJdetailed
    __del__ = lambda self : None;
LJdetailed_swigregister = _sim2d.LJdetailed_swigregister
LJdetailed_swigregister(LJdetailed)

class LJAttractRepulse(interaction):
    """Proxy of C++ NListed<(LJAttractRepulseAtom,LJAttractRepulsePair)> class"""
    __swig_setmethods__ = {}
    for _s in [interaction]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJAttractRepulse, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LJAttractRepulse, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(NListed<(LJAttractRepulseAtom,LJAttractRepulsePair)> self, neighborlist neighbors) -> LJAttractRepulse"""
        this = _sim2d.new_LJAttractRepulse(*args)
        try: self.this.append(this)
        except: self.this = this
    def add(self, *args) -> "void" :
        """add(LJAttractRepulse self, LJAttractRepulseAtom atm)"""
        return _sim2d.LJAttractRepulse_add(self, *args)

    def update_pairs(self) -> "void" :
        """update_pairs(LJAttractRepulse self)"""
        return _sim2d.LJAttractRepulse_update_pairs(self)

    def getpair(self, *args) -> "LJAttractRepulsePair" :
        """getpair(LJAttractRepulse self, idpair pair) -> LJAttractRepulsePair"""
        return _sim2d.LJAttractRepulse_getpair(self, *args)

    def energy(self, *args) -> "flt" :
        """
        energy(LJAttractRepulse self, Box box, idpair pair) -> flt
        energy(LJAttractRepulse self, Box box) -> flt
        """
        return _sim2d.LJAttractRepulse_energy(self, *args)

    def pressure(self, *args) -> "flt" :
        """pressure(LJAttractRepulse self, Box box) -> flt"""
        return _sim2d.LJAttractRepulse_pressure(self, *args)

    def size(self) -> "uint" :
        """size(LJAttractRepulse self) -> uint"""
        return _sim2d.LJAttractRepulse_size(self)

    def energy_pair(self, *args) -> "flt" :
        """energy_pair(LJAttractRepulse self, LJAttractRepulsePair pair, Box box) -> flt"""
        return _sim2d.LJAttractRepulse_energy_pair(self, *args)

    def setForces(self, *args) -> "void" :
        """setForces(LJAttractRepulse self, Box box)"""
        return _sim2d.LJAttractRepulse_setForces(self, *args)

    def setForcesGetPressure(self, *args) -> "flt" :
        """setForcesGetPressure(LJAttractRepulse self, Box box) -> flt"""
        return _sim2d.LJAttractRepulse_setForcesGetPressure(self, *args)

    def forces_pair(self, *args) -> "Vec" :
        """forces_pair(LJAttractRepulse self, LJAttractRepulsePair pair, Box box) -> Vec"""
        return _sim2d.LJAttractRepulse_forces_pair(self, *args)

    def atom_list(self) -> "std::vector< LJAttractRepulseAtom > &" :
        """atom_list(LJAttractRepulse self) -> std::vector< LJAttractRepulseAtom > &"""
        return _sim2d.LJAttractRepulse_atom_list(self)

    def nlist(self) -> "neighborlist *" :
        """nlist(LJAttractRepulse self) -> neighborlist"""
        return _sim2d.LJAttractRepulse_nlist(self)

    __swig_destroy__ = _sim2d.delete_LJAttractRepulse
    __del__ = lambda self : None;
LJAttractRepulse_swigregister = _sim2d.LJAttractRepulse_swigregister
LJAttractRepulse_swigregister(LJAttractRepulse)

class LJAttractFixedRepulse(interaction):
    """Proxy of C++ NListed<(LJAttractFixedRepulseAtom,LJAttractFixedRepulsePair)> class"""
    __swig_setmethods__ = {}
    for _s in [interaction]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJAttractFixedRepulse, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LJAttractFixedRepulse, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(NListed<(LJAttractFixedRepulseAtom,LJAttractFixedRepulsePair)> self, neighborlist neighbors) -> LJAttractFixedRepulse"""
        this = _sim2d.new_LJAttractFixedRepulse(*args)
        try: self.this.append(this)
        except: self.this = this
    def add(self, *args) -> "void" :
        """add(LJAttractFixedRepulse self, LJAttractFixedRepulseAtom atm)"""
        return _sim2d.LJAttractFixedRepulse_add(self, *args)

    def update_pairs(self) -> "void" :
        """update_pairs(LJAttractFixedRepulse self)"""
        return _sim2d.LJAttractFixedRepulse_update_pairs(self)

    def getpair(self, *args) -> "LJAttractFixedRepulsePair" :
        """getpair(LJAttractFixedRepulse self, idpair pair) -> LJAttractFixedRepulsePair"""
        return _sim2d.LJAttractFixedRepulse_getpair(self, *args)

    def energy(self, *args) -> "flt" :
        """
        energy(LJAttractFixedRepulse self, Box box, idpair pair) -> flt
        energy(LJAttractFixedRepulse self, Box box) -> flt
        """
        return _sim2d.LJAttractFixedRepulse_energy(self, *args)

    def pressure(self, *args) -> "flt" :
        """pressure(LJAttractFixedRepulse self, Box box) -> flt"""
        return _sim2d.LJAttractFixedRepulse_pressure(self, *args)

    def size(self) -> "uint" :
        """size(LJAttractFixedRepulse self) -> uint"""
        return _sim2d.LJAttractFixedRepulse_size(self)

    def energy_pair(self, *args) -> "flt" :
        """energy_pair(LJAttractFixedRepulse self, LJAttractFixedRepulsePair pair, Box box) -> flt"""
        return _sim2d.LJAttractFixedRepulse_energy_pair(self, *args)

    def setForces(self, *args) -> "void" :
        """setForces(LJAttractFixedRepulse self, Box box)"""
        return _sim2d.LJAttractFixedRepulse_setForces(self, *args)

    def setForcesGetPressure(self, *args) -> "flt" :
        """setForcesGetPressure(LJAttractFixedRepulse self, Box box) -> flt"""
        return _sim2d.LJAttractFixedRepulse_setForcesGetPressure(self, *args)

    def forces_pair(self, *args) -> "Vec" :
        """forces_pair(LJAttractFixedRepulse self, LJAttractFixedRepulsePair pair, Box box) -> Vec"""
        return _sim2d.LJAttractFixedRepulse_forces_pair(self, *args)

    def atom_list(self) -> "std::vector< LJAttractFixedRepulseAtom > &" :
        """atom_list(LJAttractFixedRepulse self) -> std::vector< LJAttractFixedRepulseAtom > &"""
        return _sim2d.LJAttractFixedRepulse_atom_list(self)

    def nlist(self) -> "neighborlist *" :
        """nlist(LJAttractFixedRepulse self) -> neighborlist"""
        return _sim2d.LJAttractFixedRepulse_nlist(self)

    __swig_destroy__ = _sim2d.delete_LJAttractFixedRepulse
    __del__ = lambda self : None;
LJAttractFixedRepulse_swigregister = _sim2d.LJAttractFixedRepulse_swigregister
LJAttractFixedRepulse_swigregister(LJAttractFixedRepulse)

class LJDouble(interaction):
    """Proxy of C++ NListed<(LJDoubleAtom,LJDoublePair)> class"""
    __swig_setmethods__ = {}
    for _s in [interaction]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJDouble, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LJDouble, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(NListed<(LJDoubleAtom,LJDoublePair)> self, neighborlist neighbors) -> LJDouble"""
        this = _sim2d.new_LJDouble(*args)
        try: self.this.append(this)
        except: self.this = this
    def add(self, *args) -> "void" :
        """add(LJDouble self, LJDoubleAtom atm)"""
        return _sim2d.LJDouble_add(self, *args)

    def update_pairs(self) -> "void" :
        """update_pairs(LJDouble self)"""
        return _sim2d.LJDouble_update_pairs(self)

    def getpair(self, *args) -> "LJDoublePair" :
        """getpair(LJDouble self, idpair pair) -> LJDoublePair"""
        return _sim2d.LJDouble_getpair(self, *args)

    def energy(self, *args) -> "flt" :
        """
        energy(LJDouble self, Box box, idpair pair) -> flt
        energy(LJDouble self, Box box) -> flt
        """
        return _sim2d.LJDouble_energy(self, *args)

    def pressure(self, *args) -> "flt" :
        """pressure(LJDouble self, Box box) -> flt"""
        return _sim2d.LJDouble_pressure(self, *args)

    def size(self) -> "uint" :
        """size(LJDouble self) -> uint"""
        return _sim2d.LJDouble_size(self)

    def energy_pair(self, *args) -> "flt" :
        """energy_pair(LJDouble self, LJDoublePair pair, Box box) -> flt"""
        return _sim2d.LJDouble_energy_pair(self, *args)

    def setForces(self, *args) -> "void" :
        """setForces(LJDouble self, Box box)"""
        return _sim2d.LJDouble_setForces(self, *args)

    def setForcesGetPressure(self, *args) -> "flt" :
        """setForcesGetPressure(LJDouble self, Box box) -> flt"""
        return _sim2d.LJDouble_setForcesGetPressure(self, *args)

    def forces_pair(self, *args) -> "Vec" :
        """forces_pair(LJDouble self, LJDoublePair pair, Box box) -> Vec"""
        return _sim2d.LJDouble_forces_pair(self, *args)

    def atom_list(self) -> "std::vector< LJDoubleAtom > &" :
        """atom_list(LJDouble self) -> std::vector< LJDoubleAtom > &"""
        return _sim2d.LJDouble_atom_list(self)

    def nlist(self) -> "neighborlist *" :
        """nlist(LJDouble self) -> neighborlist"""
        return _sim2d.LJDouble_nlist(self)

    __swig_destroy__ = _sim2d.delete_LJDouble
    __del__ = lambda self : None;
LJDouble_swigregister = _sim2d.LJDouble_swigregister
LJDouble_swigregister(LJDouble)

class EisMclachlan(interaction):
    """Proxy of C++ NListed<(EisMclachlanAtom,EisMclachlanPair)> class"""
    __swig_setmethods__ = {}
    for _s in [interaction]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, EisMclachlan, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, EisMclachlan, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(NListed<(EisMclachlanAtom,EisMclachlanPair)> self, neighborlist neighbors) -> EisMclachlan"""
        this = _sim2d.new_EisMclachlan(*args)
        try: self.this.append(this)
        except: self.this = this
    def add(self, *args) -> "void" :
        """add(EisMclachlan self, EisMclachlanAtom atm)"""
        return _sim2d.EisMclachlan_add(self, *args)

    def update_pairs(self) -> "void" :
        """update_pairs(EisMclachlan self)"""
        return _sim2d.EisMclachlan_update_pairs(self)

    def getpair(self, *args) -> "EisMclachlanPair" :
        """getpair(EisMclachlan self, idpair pair) -> EisMclachlanPair"""
        return _sim2d.EisMclachlan_getpair(self, *args)

    def energy(self, *args) -> "flt" :
        """
        energy(EisMclachlan self, Box box, idpair pair) -> flt
        energy(EisMclachlan self, Box box) -> flt
        """
        return _sim2d.EisMclachlan_energy(self, *args)

    def pressure(self, *args) -> "flt" :
        """pressure(EisMclachlan self, Box box) -> flt"""
        return _sim2d.EisMclachlan_pressure(self, *args)

    def size(self) -> "uint" :
        """size(EisMclachlan self) -> uint"""
        return _sim2d.EisMclachlan_size(self)

    def energy_pair(self, *args) -> "flt" :
        """energy_pair(EisMclachlan self, EisMclachlanPair pair, Box box) -> flt"""
        return _sim2d.EisMclachlan_energy_pair(self, *args)

    def setForces(self, *args) -> "void" :
        """setForces(EisMclachlan self, Box box)"""
        return _sim2d.EisMclachlan_setForces(self, *args)

    def setForcesGetPressure(self, *args) -> "flt" :
        """setForcesGetPressure(EisMclachlan self, Box box) -> flt"""
        return _sim2d.EisMclachlan_setForcesGetPressure(self, *args)

    def forces_pair(self, *args) -> "Vec" :
        """forces_pair(EisMclachlan self, EisMclachlanPair pair, Box box) -> Vec"""
        return _sim2d.EisMclachlan_forces_pair(self, *args)

    def atom_list(self) -> "std::vector< EisMclachlanAtom > &" :
        """atom_list(EisMclachlan self) -> std::vector< EisMclachlanAtom > &"""
        return _sim2d.EisMclachlan_atom_list(self)

    def nlist(self) -> "neighborlist *" :
        """nlist(EisMclachlan self) -> neighborlist"""
        return _sim2d.EisMclachlan_nlist(self)

    __swig_destroy__ = _sim2d.delete_EisMclachlan
    __del__ = lambda self : None;
EisMclachlan_swigregister = _sim2d.EisMclachlan_swigregister
EisMclachlan_swigregister(EisMclachlan)

class LJish(interaction):
    """Proxy of C++ NListed<(LJishAtom,LJishPair)> class"""
    __swig_setmethods__ = {}
    for _s in [interaction]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LJish, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LJish, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(NListed<(LJishAtom,LJishPair)> self, neighborlist neighbors) -> LJish"""
        this = _sim2d.new_LJish(*args)
        try: self.this.append(this)
        except: self.this = this
    def add(self, *args) -> "void" :
        """add(LJish self, LJishAtom atm)"""
        return _sim2d.LJish_add(self, *args)

    def update_pairs(self) -> "void" :
        """update_pairs(LJish self)"""
        return _sim2d.LJish_update_pairs(self)

    def getpair(self, *args) -> "LJishPair" :
        """getpair(LJish self, idpair pair) -> LJishPair"""
        return _sim2d.LJish_getpair(self, *args)

    def energy(self, *args) -> "flt" :
        """
        energy(LJish self, Box box, idpair pair) -> flt
        energy(LJish self, Box box) -> flt
        """
        return _sim2d.LJish_energy(self, *args)

    def pressure(self, *args) -> "flt" :
        """pressure(LJish self, Box box) -> flt"""
        return _sim2d.LJish_pressure(self, *args)

    def size(self) -> "uint" :
        """size(LJish self) -> uint"""
        return _sim2d.LJish_size(self)

    def energy_pair(self, *args) -> "flt" :
        """energy_pair(LJish self, LJishPair pair, Box box) -> flt"""
        return _sim2d.LJish_energy_pair(self, *args)

    def setForces(self, *args) -> "void" :
        """setForces(LJish self, Box box)"""
        return _sim2d.LJish_setForces(self, *args)

    def setForcesGetPressure(self, *args) -> "flt" :
        """setForcesGetPressure(LJish self, Box box) -> flt"""
        return _sim2d.LJish_setForcesGetPressure(self, *args)

    def forces_pair(self, *args) -> "Vec" :
        """forces_pair(LJish self, LJishPair pair, Box box) -> Vec"""
        return _sim2d.LJish_forces_pair(self, *args)

    def atom_list(self) -> "std::vector< LJishAtom > &" :
        """atom_list(LJish self) -> std::vector< LJishAtom > &"""
        return _sim2d.LJish_atom_list(self)

    def nlist(self) -> "neighborlist *" :
        """nlist(LJish self) -> neighborlist"""
        return _sim2d.LJish_nlist(self)

    __swig_destroy__ = _sim2d.delete_LJish
    __del__ = lambda self : None;
LJish_swigregister = _sim2d.LJish_swigregister
LJish_swigregister(LJish)

class HertzianSimple(interaction):
    """Proxy of C++ SimpleListed<(HertzianAtom,HertzianPair)> class"""
    __swig_setmethods__ = {}
    for _s in [interaction]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HertzianSimple, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, HertzianSimple, name)
    __repr__ = _swig_repr
    def __init__(self): 
        """__init__(SimpleListed<(HertzianAtom,HertzianPair)> self) -> HertzianSimple"""
        this = _sim2d.new_HertzianSimple()
        try: self.this.append(this)
        except: self.this = this
    def add(self, *args) -> "void" :
        """add(HertzianSimple self, HertzianAtom atm)"""
        return _sim2d.HertzianSimple_add(self, *args)

    def energy(self, *args) -> "flt" :
        """energy(HertzianSimple self, Box box) -> flt"""
        return _sim2d.HertzianSimple_energy(self, *args)

    def pressure(self, *args) -> "flt" :
        """pressure(HertzianSimple self, Box box) -> flt"""
        return _sim2d.HertzianSimple_pressure(self, *args)

    def size(self) -> "uint" :
        """size(HertzianSimple self) -> uint"""
        return _sim2d.HertzianSimple_size(self)

    def setForces(self, *args) -> "void" :
        """setForces(HertzianSimple self, Box box)"""
        return _sim2d.HertzianSimple_setForces(self, *args)

    def setForcesGetPressure(self, *args) -> "flt" :
        """setForcesGetPressure(HertzianSimple self, Box box) -> flt"""
        return _sim2d.HertzianSimple_setForcesGetPressure(self, *args)

    def atom_list(self) -> "std::vector< HertzianAtom > &" :
        """atom_list(HertzianSimple self) -> std::vector< HertzianAtom > &"""
        return _sim2d.HertzianSimple_atom_list(self)

    __swig_destroy__ = _sim2d.delete_HertzianSimple
    __del__ = lambda self : None;
HertzianSimple_swigregister = _sim2d.HertzianSimple_swigregister
HertzianSimple_swigregister(HertzianSimple)

class HertzianPlain(interaction):
    """Proxy of C++ NListed<(HertzianAtom,HertzianPair)> class"""
    __swig_setmethods__ = {}
    for _s in [interaction]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HertzianPlain, name, value)
    __swig_getmethods__ = {}
    for _s in [interaction]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, HertzianPlain, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(NListed<(HertzianAtom,HertzianPair)> self, neighborlist neighbors) -> HertzianPlain"""
        this = _sim2d.new_HertzianPlain(*args)
        try: self.this.append(this)
        except: self.this = this
    def add(self, *args) -> "void" :
        """add(HertzianPlain self, HertzianAtom atm)"""
        return _sim2d.HertzianPlain_add(self, *args)

    def update_pairs(self) -> "void" :
        """update_pairs(HertzianPlain self)"""
        return _sim2d.HertzianPlain_update_pairs(self)

    def getpair(self, *args) -> "HertzianPair" :
        """getpair(HertzianPlain self, idpair pair) -> HertzianPair"""
        return _sim2d.HertzianPlain_getpair(self, *args)

    def energy(self, *args) -> "flt" :
        """
        energy(HertzianPlain self, Box box, idpair pair) -> flt
        energy(HertzianPlain self, Box box) -> flt
        """
        return _sim2d.HertzianPlain_energy(self, *args)

    def pressure(self, *args) -> "flt" :
        """pressure(HertzianPlain self, Box box) -> flt"""
        return _sim2d.HertzianPlain_pressure(self, *args)

    def size(self) -> "uint" :
        """size(HertzianPlain self) -> uint"""
        return _sim2d.HertzianPlain_size(self)

    def energy_pair(self, *args) -> "flt" :
        """energy_pair(HertzianPlain self, HertzianPair pair, Box box) -> flt"""
        return _sim2d.HertzianPlain_energy_pair(self, *args)

    def setForces(self, *args) -> "void" :
        """setForces(HertzianPlain self, Box box)"""
        return _sim2d.HertzianPlain_setForces(self, *args)

    def setForcesGetPressure(self, *args) -> "flt" :
        """setForcesGetPressure(HertzianPlain self, Box box) -> flt"""
        return _sim2d.HertzianPlain_setForcesGetPressure(self, *args)

    def forces_pair(self, *args) -> "Vec" :
        """forces_pair(HertzianPlain self, HertzianPair pair, Box box) -> Vec"""
        return _sim2d.HertzianPlain_forces_pair(self, *args)

    def atom_list(self) -> "std::vector< HertzianAtom > &" :
        """atom_list(HertzianPlain self) -> std::vector< HertzianAtom > &"""
        return _sim2d.HertzianPlain_atom_list(self)

    def nlist(self) -> "neighborlist *" :
        """nlist(HertzianPlain self) -> neighborlist"""
        return _sim2d.HertzianPlain_nlist(self)

    __swig_destroy__ = _sim2d.delete_HertzianPlain
    __del__ = lambda self : None;
HertzianPlain_swigregister = _sim2d.HertzianPlain_swigregister
HertzianPlain_swigregister(HertzianPlain)

class Hertzian(interactionpairsx,HertzianPlain):
    """Proxy of C++ NListedVirial<(HertzianAtom,HertzianPair)> class"""
    __swig_setmethods__ = {}
    for _s in [interactionpairsx,HertzianPlain]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Hertzian, name, value)
    __swig_getmethods__ = {}
    for _s in [interactionpairsx,HertzianPlain]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Hertzian, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(NListedVirial<(HertzianAtom,HertzianPair)> self, neighborlist neighbors) -> Hertzian"""
        this = _sim2d.new_Hertzian(*args)
        try: self.this.append(this)
        except: self.this = this
    def setForces(self, *args) -> "void" :
        """
        setForces(Hertzian self, Box box)
        setForces(Hertzian self, Box box, fpairxFunct arg3)
        """
        return _sim2d.Hertzian_setForces(self, *args)

    def setForcesGetPressure(self, *args) -> "flt" :
        """setForcesGetPressure(Hertzian self, Box box) -> flt"""
        return _sim2d.Hertzian_setForcesGetPressure(self, *args)

    def energy(self, *args) -> "flt" :
        """energy(Hertzian self, Box box) -> flt"""
        return _sim2d.Hertzian_energy(self, *args)

    def pressure(self, *args) -> "flt" :
        """pressure(Hertzian self, Box box) -> flt"""
        return _sim2d.Hertzian_pressure(self, *args)

    __swig_destroy__ = _sim2d.delete_Hertzian
    __del__ = lambda self : None;
Hertzian_swigregister = _sim2d.Hertzian_swigregister
Hertzian_swigregister(Hertzian)

class collection(_object):
    """Proxy of C++ collection class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, collection, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, collection, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def setForces(self, seta : 'bool'=True) -> "void" :
        """
        setForces(collection self, bool seta=True)
        setForces(collection self)
        """
        return _sim2d.collection_setForces(self, seta)

    def timestep(self) -> "void" :
        """timestep(collection self)"""
        return _sim2d.collection_timestep(self)

    def dof(self) -> "flt" :
        """dof(collection self) -> flt"""
        return _sim2d.collection_dof(self)

    def potentialenergy(self) -> "flt" :
        """potentialenergy(collection self) -> flt"""
        return _sim2d.collection_potentialenergy(self)

    def energy(self) -> "flt" :
        """energy(collection self) -> flt"""
        return _sim2d.collection_energy(self)

    def temp(self, minuscomv : 'bool'=True) -> "flt" :
        """
        temp(collection self, bool minuscomv=True) -> flt
        temp(collection self) -> flt
        """
        return _sim2d.collection_temp(self, minuscomv)

    def kinetic(self) -> "flt" :
        """kinetic(collection self) -> flt"""
        return _sim2d.collection_kinetic(self)

    def virial(self) -> "flt" :
        """virial(collection self) -> flt"""
        return _sim2d.collection_virial(self)

    def pressure(self) -> "flt" :
        """pressure(collection self) -> flt"""
        return _sim2d.collection_pressure(self)

    def getbox(self) -> "Box *" :
        """getbox(collection self) -> Box"""
        return _sim2d.collection_getbox(self)

    def com(self) -> "Vec" :
        """com(collection self) -> Vec"""
        return _sim2d.collection_com(self)

    def comv(self) -> "Vec" :
        """comv(collection self) -> Vec"""
        return _sim2d.collection_comv(self)

    def angmomentum(self, *args) -> "flt" :
        """
        angmomentum(collection self, Vec loc) -> flt
        angmomentum(collection self) -> flt
        """
        return _sim2d.collection_angmomentum(self, *args)

    def gyradius(self) -> "flt" :
        """gyradius(collection self) -> flt"""
        return _sim2d.collection_gyradius(self)

    __swig_destroy__ = _sim2d.delete_collection
    __del__ = lambda self : None;
    def resetcomv(self) -> "void" :
        """resetcomv(collection self)"""
        return _sim2d.collection_resetcomv(self)

    def resetL(self) -> "void" :
        """resetL(collection self)"""
        return _sim2d.collection_resetL(self)

    def scaleVs(self, *args) -> "void" :
        """scaleVs(collection self, flt scaleby)"""
        return _sim2d.collection_scaleVs(self, *args)

    def scaleVelocitiesT(self, *args) -> "void" :
        """scaleVelocitiesT(collection self, flt T)"""
        return _sim2d.collection_scaleVelocitiesT(self, *args)

    def scaleVelocitiesE(self, *args) -> "void" :
        """scaleVelocitiesE(collection self, flt E)"""
        return _sim2d.collection_scaleVelocitiesE(self, *args)

    def addInteraction(self, *args) -> "void" :
        """addInteraction(collection self, interaction inter)"""
        return _sim2d.collection_addInteraction(self, *args)

    def addTracker(self, *args) -> "void" :
        """addTracker(collection self, statetracker track)"""
        return _sim2d.collection_addTracker(self, *args)

    def getInteractions(self) -> "std::vector< interaction * >" :
        """getInteractions(collection self) -> ivector"""
        return _sim2d.collection_getInteractions(self)

    def numInteraction(self) -> "uint" :
        """numInteraction(collection self) -> uint"""
        return _sim2d.collection_numInteraction(self)

collection_swigregister = _sim2d.collection_swigregister
collection_swigregister(collection)

class StaticCollec(collection):
    """Proxy of C++ StaticCollec class"""
    __swig_setmethods__ = {}
    for _s in [collection]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, StaticCollec, name, value)
    __swig_getmethods__ = {}
    for _s in [collection]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, StaticCollec, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(StaticCollec self, Box box, avector groups, ivector interactions=vector< interaction * >(), tvector trackers=vector< statetracker * >(), 
            constraintvector constraints=vector< constraint * >()) -> StaticCollec
        __init__(StaticCollec self, Box box, avector groups, ivector interactions=vector< interaction * >(), tvector trackers=vector< statetracker * >()) -> StaticCollec
        __init__(StaticCollec self, Box box, avector groups, ivector interactions=vector< interaction * >()) -> StaticCollec
        __init__(StaticCollec self, Box box, avector groups) -> StaticCollec
        """
        this = _sim2d.new_StaticCollec(*args)
        try: self.this.append(this)
        except: self.this = this
    def timestep(self) -> "void" :
        """timestep(StaticCollec self)"""
        return _sim2d.StaticCollec_timestep(self)

    def update(self) -> "void" :
        """update(StaticCollec self)"""
        return _sim2d.StaticCollec_update(self)

    __swig_destroy__ = _sim2d.delete_StaticCollec
    __del__ = lambda self : None;
StaticCollec_swigregister = _sim2d.StaticCollec_swigregister
StaticCollec_swigregister(StaticCollec)

class collectionSol(collection):
    """Proxy of C++ collectionSol class"""
    __swig_setmethods__ = {}
    for _s in [collection]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, collectionSol, name, value)
    __swig_getmethods__ = {}
    for _s in [collection]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, collectionSol, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(collectionSol self, Box box, flt const dt, flt const damping, flt const desiredT, avector groups=vector< atomgroup * >(), 
            ivector interactions=vector< interaction * >(), tvector trackers=vector< statetracker * >(), 
            constraintvector constraints=vector< constraint * >()) -> collectionSol
        __init__(collectionSol self, Box box, flt const dt, flt const damping, flt const desiredT, avector groups=vector< atomgroup * >(), 
            ivector interactions=vector< interaction * >(), tvector trackers=vector< statetracker * >()) -> collectionSol
        __init__(collectionSol self, Box box, flt const dt, flt const damping, flt const desiredT, avector groups=vector< atomgroup * >(), 
            ivector interactions=vector< interaction * >()) -> collectionSol
        __init__(collectionSol self, Box box, flt const dt, flt const damping, flt const desiredT, avector groups=vector< atomgroup * >()) -> collectionSol
        __init__(collectionSol self, Box box, flt const dt, flt const damping, flt const desiredT) -> collectionSol
        """
        this = _sim2d.new_collectionSol(*args)
        try: self.this.append(this)
        except: self.this = this
    def changeT(self, *args) -> "void" :
        """changeT(collectionSol self, flt const newdt, flt const damp, flt const desiredT)"""
        return _sim2d.collectionSol_changeT(self, *args)

    def timestep(self) -> "void" :
        """timestep(collectionSol self)"""
        return _sim2d.collectionSol_timestep(self)

    __swig_destroy__ = _sim2d.delete_collectionSol
    __del__ = lambda self : None;
collectionSol_swigregister = _sim2d.collectionSol_swigregister
collectionSol_swigregister(collectionSol)

class collectionSolHT(collection):
    """Proxy of C++ collectionSolHT class"""
    __swig_setmethods__ = {}
    for _s in [collection]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, collectionSolHT, name, value)
    __swig_getmethods__ = {}
    for _s in [collection]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, collectionSolHT, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(collectionSolHT self, Box box, flt const dt, flt const damping, flt const desiredT, avector groups=vector< atomgroup * >(), 
            ivector interactions=vector< interaction * >(), tvector trackers=vector< statetracker * >(), 
            constraintvector constraints=vector< constraint * >()) -> collectionSolHT
        __init__(collectionSolHT self, Box box, flt const dt, flt const damping, flt const desiredT, avector groups=vector< atomgroup * >(), 
            ivector interactions=vector< interaction * >(), tvector trackers=vector< statetracker * >()) -> collectionSolHT
        __init__(collectionSolHT self, Box box, flt const dt, flt const damping, flt const desiredT, avector groups=vector< atomgroup * >(), 
            ivector interactions=vector< interaction * >()) -> collectionSolHT
        __init__(collectionSolHT self, Box box, flt const dt, flt const damping, flt const desiredT, avector groups=vector< atomgroup * >()) -> collectionSolHT
        __init__(collectionSolHT self, Box box, flt const dt, flt const damping, flt const desiredT) -> collectionSolHT
        """
        this = _sim2d.new_collectionSolHT(*args)
        try: self.this.append(this)
        except: self.this = this
    def changeT(self, *args) -> "void" :
        """changeT(collectionSolHT self, flt const newdt, flt const damp, flt const desiredT)"""
        return _sim2d.collectionSolHT_changeT(self, *args)

    def timestep(self) -> "void" :
        """timestep(collectionSolHT self)"""
        return _sim2d.collectionSolHT_timestep(self)

    __swig_destroy__ = _sim2d.delete_collectionSolHT
    __del__ = lambda self : None;
collectionSolHT_swigregister = _sim2d.collectionSolHT_swigregister
collectionSolHT_swigregister(collectionSolHT)

class collectionVerlet(collection):
    """Proxy of C++ collectionVerlet class"""
    __swig_setmethods__ = {}
    for _s in [collection]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, collectionVerlet, name, value)
    __swig_getmethods__ = {}
    for _s in [collection]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, collectionVerlet, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(collectionVerlet self, Box box, flt const dt, avector groups=vector< atomgroup * >(), ivector interactions=vector< interaction * >(), 
            tvector trackers=vector< statetracker * >(), 
            constraintvector constraints=vector< constraint * >()) -> collectionVerlet
        __init__(collectionVerlet self, Box box, flt const dt, avector groups=vector< atomgroup * >(), ivector interactions=vector< interaction * >(), 
            tvector trackers=vector< statetracker * >()) -> collectionVerlet
        __init__(collectionVerlet self, Box box, flt const dt, avector groups=vector< atomgroup * >(), ivector interactions=vector< interaction * >()) -> collectionVerlet
        __init__(collectionVerlet self, Box box, flt const dt, avector groups=vector< atomgroup * >()) -> collectionVerlet
        __init__(collectionVerlet self, Box box, flt const dt) -> collectionVerlet
        """
        this = _sim2d.new_collectionVerlet(*args)
        try: self.this.append(this)
        except: self.this = this
    def timestep(self) -> "void" :
        """timestep(collectionVerlet self)"""
        return _sim2d.collectionVerlet_timestep(self)

    def setdt(self, *args) -> "void" :
        """setdt(collectionVerlet self, flt newdt)"""
        return _sim2d.collectionVerlet_setdt(self, *args)

    __swig_destroy__ = _sim2d.delete_collectionVerlet
    __del__ = lambda self : None;
collectionVerlet_swigregister = _sim2d.collectionVerlet_swigregister
collectionVerlet_swigregister(collectionVerlet)

class collectionOverdamped(collection):
    """Proxy of C++ collectionOverdamped class"""
    __swig_setmethods__ = {}
    for _s in [collection]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, collectionOverdamped, name, value)
    __swig_getmethods__ = {}
    for _s in [collection]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, collectionOverdamped, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(collectionOverdamped self, Box box, flt const dt, float const gamma, avector groups=vector< atomgroup * >(), 
            ivector interactions=vector< interaction * >(), tvector trackers=vector< statetracker * >(), 
            constraintvector constraints=vector< constraint * >()) -> collectionOverdamped
        __init__(collectionOverdamped self, Box box, flt const dt, float const gamma, avector groups=vector< atomgroup * >(), 
            ivector interactions=vector< interaction * >(), tvector trackers=vector< statetracker * >()) -> collectionOverdamped
        __init__(collectionOverdamped self, Box box, flt const dt, float const gamma, avector groups=vector< atomgroup * >(), 
            ivector interactions=vector< interaction * >()) -> collectionOverdamped
        __init__(collectionOverdamped self, Box box, flt const dt, float const gamma, avector groups=vector< atomgroup * >()) -> collectionOverdamped
        __init__(collectionOverdamped self, Box box, flt const dt, float const gamma) -> collectionOverdamped
        """
        this = _sim2d.new_collectionOverdamped(*args)
        try: self.this.append(this)
        except: self.this = this
    def timestep(self) -> "void" :
        """timestep(collectionOverdamped self)"""
        return _sim2d.collectionOverdamped_timestep(self)

    def setdt(self, *args) -> "void" :
        """setdt(collectionOverdamped self, flt newdt)"""
        return _sim2d.collectionOverdamped_setdt(self, *args)

    __swig_destroy__ = _sim2d.delete_collectionOverdamped
    __del__ = lambda self : None;
collectionOverdamped_swigregister = _sim2d.collectionOverdamped_swigregister
collectionOverdamped_swigregister(collectionOverdamped)

class collectionConjGradient(collection):
    """Proxy of C++ collectionConjGradient class"""
    __swig_setmethods__ = {}
    for _s in [collection]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, collectionConjGradient, name, value)
    __swig_getmethods__ = {}
    for _s in [collection]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, collectionConjGradient, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(collectionConjGradient self, Box box, flt const dt, avector groups=vector< atomgroup * >(), ivector interactions=vector< interaction * >(), 
            tvector trackers=vector< statetracker * >(), 
            constraintvector constraints=vector< constraint * >()) -> collectionConjGradient
        __init__(collectionConjGradient self, Box box, flt const dt, avector groups=vector< atomgroup * >(), ivector interactions=vector< interaction * >(), 
            tvector trackers=vector< statetracker * >()) -> collectionConjGradient
        __init__(collectionConjGradient self, Box box, flt const dt, avector groups=vector< atomgroup * >(), ivector interactions=vector< interaction * >()) -> collectionConjGradient
        __init__(collectionConjGradient self, Box box, flt const dt, avector groups=vector< atomgroup * >()) -> collectionConjGradient
        __init__(collectionConjGradient self, Box box, flt const dt) -> collectionConjGradient
        """
        this = _sim2d.new_collectionConjGradient(*args)
        try: self.this.append(this)
        except: self.this = this
    def timestep(self) -> "void" :
        """timestep(collectionConjGradient self)"""
        return _sim2d.collectionConjGradient_timestep(self)

    def setdt(self, *args) -> "void" :
        """setdt(collectionConjGradient self, flt newdt)"""
        return _sim2d.collectionConjGradient_setdt(self, *args)

    __swig_destroy__ = _sim2d.delete_collectionConjGradient
    __del__ = lambda self : None;
collectionConjGradient_swigregister = _sim2d.collectionConjGradient_swigregister
collectionConjGradient_swigregister(collectionConjGradient)

class collectionConjGradientBox(collection):
    """Proxy of C++ collectionConjGradientBox class"""
    __swig_setmethods__ = {}
    for _s in [collection]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, collectionConjGradientBox, name, value)
    __swig_getmethods__ = {}
    for _s in [collection]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, collectionConjGradientBox, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(collectionConjGradientBox self, OriginBox box, flt const dt, flt const P0, flt const kappaV=1, avector groups=vector< atomgroup * >(), 
            ivector interactions=vector< interaction * >(), tvector trackers=vector< statetracker * >(), 
            constraintvector constraints=vector< constraint * >()) -> collectionConjGradientBox
        __init__(collectionConjGradientBox self, OriginBox box, flt const dt, flt const P0, flt const kappaV=1, avector groups=vector< atomgroup * >(), 
            ivector interactions=vector< interaction * >(), tvector trackers=vector< statetracker * >()) -> collectionConjGradientBox
        __init__(collectionConjGradientBox self, OriginBox box, flt const dt, flt const P0, flt const kappaV=1, avector groups=vector< atomgroup * >(), 
            ivector interactions=vector< interaction * >()) -> collectionConjGradientBox
        __init__(collectionConjGradientBox self, OriginBox box, flt const dt, flt const P0, flt const kappaV=1, avector groups=vector< atomgroup * >()) -> collectionConjGradientBox
        __init__(collectionConjGradientBox self, OriginBox box, flt const dt, flt const P0, flt const kappaV=1) -> collectionConjGradientBox
        __init__(collectionConjGradientBox self, OriginBox box, flt const dt, flt const P0) -> collectionConjGradientBox
        """
        this = _sim2d.new_collectionConjGradientBox(*args)
        try: self.this.append(this)
        except: self.this = this
    def timestep(self) -> "void" :
        """timestep(collectionConjGradientBox self)"""
        return _sim2d.collectionConjGradientBox_timestep(self)

    def setdt(self, *args) -> "void" :
        """setdt(collectionConjGradientBox self, flt newdt)"""
        return _sim2d.collectionConjGradientBox_setdt(self, *args)

    __swig_destroy__ = _sim2d.delete_collectionConjGradientBox
    __del__ = lambda self : None;
collectionConjGradientBox_swigregister = _sim2d.collectionConjGradientBox_swigregister
collectionConjGradientBox_swigregister(collectionConjGradientBox)


def solveCubic1(*args) -> "flt" :
  """solveCubic1(flt b, flt c, flt d) -> flt"""
  return _sim2d.solveCubic1(*args)

def solveCubic(*args) -> "flt" :
  """
    solveCubic(flt a1, flt a2, flt a3, flt closeto=0) -> flt
    solveCubic(flt a1, flt a2, flt a3) -> flt
    """
  return _sim2d.solveCubic(*args)
class collectionNoseHoover(collection):
    """Proxy of C++ collectionNoseHoover class"""
    __swig_setmethods__ = {}
    for _s in [collection]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, collectionNoseHoover, name, value)
    __swig_getmethods__ = {}
    for _s in [collection]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, collectionNoseHoover, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(collectionNoseHoover self, Box box, flt const dt, flt const Q, flt const T, avector groups=vector< atomgroup * >(), 
            ivector interactions=vector< interaction * >(), tvector trackers=vector< statetracker * >(), 
            constraintvector constraints=vector< constraint * >()) -> collectionNoseHoover
        __init__(collectionNoseHoover self, Box box, flt const dt, flt const Q, flt const T, avector groups=vector< atomgroup * >(), 
            ivector interactions=vector< interaction * >(), tvector trackers=vector< statetracker * >()) -> collectionNoseHoover
        __init__(collectionNoseHoover self, Box box, flt const dt, flt const Q, flt const T, avector groups=vector< atomgroup * >(), 
            ivector interactions=vector< interaction * >()) -> collectionNoseHoover
        __init__(collectionNoseHoover self, Box box, flt const dt, flt const Q, flt const T, avector groups=vector< atomgroup * >()) -> collectionNoseHoover
        __init__(collectionNoseHoover self, Box box, flt const dt, flt const Q, flt const T) -> collectionNoseHoover
        """
        this = _sim2d.new_collectionNoseHoover(*args)
        try: self.this.append(this)
        except: self.this = this
    def setdt(self, *args) -> "void" :
        """setdt(collectionNoseHoover self, flt newdt)"""
        return _sim2d.collectionNoseHoover_setdt(self, *args)

    def setQ(self, *args) -> "void" :
        """setQ(collectionNoseHoover self, flt newQ)"""
        return _sim2d.collectionNoseHoover_setQ(self, *args)

    def resetBath(self) -> "void" :
        """resetBath(collectionNoseHoover self)"""
        return _sim2d.collectionNoseHoover_resetBath(self)

    def timestep(self) -> "void" :
        """timestep(collectionNoseHoover self)"""
        return _sim2d.collectionNoseHoover_timestep(self)

    def Hamiltonian(self) -> "flt" :
        """Hamiltonian(collectionNoseHoover self) -> flt"""
        return _sim2d.collectionNoseHoover_Hamiltonian(self)

    def getxi(self) -> "flt" :
        """getxi(collectionNoseHoover self) -> flt"""
        return _sim2d.collectionNoseHoover_getxi(self)

    def getlns(self) -> "flt" :
        """getlns(collectionNoseHoover self) -> flt"""
        return _sim2d.collectionNoseHoover_getlns(self)

    __swig_destroy__ = _sim2d.delete_collectionNoseHoover
    __del__ = lambda self : None;
collectionNoseHoover_swigregister = _sim2d.collectionNoseHoover_swigregister
collectionNoseHoover_swigregister(collectionNoseHoover)

class collectionGaussianT(collection):
    """Proxy of C++ collectionGaussianT class"""
    __swig_setmethods__ = {}
    for _s in [collection]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, collectionGaussianT, name, value)
    __swig_getmethods__ = {}
    for _s in [collection]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, collectionGaussianT, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(collectionGaussianT self, Box box, flt const dt, flt const Q, avector groups=vector< atomgroup * >(), ivector interactions=vector< interaction * >(), 
            tvector trackers=vector< statetracker * >(), 
            constraintvector constraints=vector< constraint * >()) -> collectionGaussianT
        __init__(collectionGaussianT self, Box box, flt const dt, flt const Q, avector groups=vector< atomgroup * >(), ivector interactions=vector< interaction * >(), 
            tvector trackers=vector< statetracker * >()) -> collectionGaussianT
        __init__(collectionGaussianT self, Box box, flt const dt, flt const Q, avector groups=vector< atomgroup * >(), ivector interactions=vector< interaction * >()) -> collectionGaussianT
        __init__(collectionGaussianT self, Box box, flt const dt, flt const Q, avector groups=vector< atomgroup * >()) -> collectionGaussianT
        __init__(collectionGaussianT self, Box box, flt const dt, flt const Q) -> collectionGaussianT
        """
        this = _sim2d.new_collectionGaussianT(*args)
        try: self.this.append(this)
        except: self.this = this
    def setdt(self, *args) -> "void" :
        """setdt(collectionGaussianT self, flt newdt)"""
        return _sim2d.collectionGaussianT_setdt(self, *args)

    def setQ(self, *args) -> "void" :
        """setQ(collectionGaussianT self, flt newQ)"""
        return _sim2d.collectionGaussianT_setQ(self, *args)

    def setForces(self, *args) -> "void" :
        """
        setForces(collectionGaussianT self, bool seta=True)
        setForces(collectionGaussianT self)
        setForces(collectionGaussianT self, bool seta, bool setxi)
        """
        return _sim2d.collectionGaussianT_setForces(self, *args)

    def timestep(self) -> "void" :
        """timestep(collectionGaussianT self)"""
        return _sim2d.collectionGaussianT_timestep(self)

    __swig_destroy__ = _sim2d.delete_collectionGaussianT
    __del__ = lambda self : None;
collectionGaussianT_swigregister = _sim2d.collectionGaussianT_swigregister
collectionGaussianT_swigregister(collectionGaussianT)

class collectionGear3A(collection):
    """Proxy of C++ collectionGear3A class"""
    __swig_setmethods__ = {}
    for _s in [collection]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, collectionGear3A, name, value)
    __swig_getmethods__ = {}
    for _s in [collection]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, collectionGear3A, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(collectionGear3A self, Box box, flt const dt, avector groups=vector< atomgroup * >(), ivector interactions=vector< interaction * >(), 
            tvector trackers=vector< statetracker * >(), 
            constraintvector constraints=vector< constraint * >()) -> collectionGear3A
        __init__(collectionGear3A self, Box box, flt const dt, avector groups=vector< atomgroup * >(), ivector interactions=vector< interaction * >(), 
            tvector trackers=vector< statetracker * >()) -> collectionGear3A
        __init__(collectionGear3A self, Box box, flt const dt, avector groups=vector< atomgroup * >(), ivector interactions=vector< interaction * >()) -> collectionGear3A
        __init__(collectionGear3A self, Box box, flt const dt, avector groups=vector< atomgroup * >()) -> collectionGear3A
        __init__(collectionGear3A self, Box box, flt const dt) -> collectionGear3A
        """
        this = _sim2d.new_collectionGear3A(*args)
        try: self.this.append(this)
        except: self.this = this
    def timestep(self) -> "void" :
        """timestep(collectionGear3A self)"""
        return _sim2d.collectionGear3A_timestep(self)

    def setdt(self, *args) -> "void" :
        """setdt(collectionGear3A self, flt newdt)"""
        return _sim2d.collectionGear3A_setdt(self, *args)

    __swig_destroy__ = _sim2d.delete_collectionGear3A
    __del__ = lambda self : None;
collectionGear3A_swigregister = _sim2d.collectionGear3A_swigregister
collectionGear3A_swigregister(collectionGear3A)

class collectionGear4A(collection):
    """Proxy of C++ collectionGear4A class"""
    __swig_setmethods__ = {}
    for _s in [collection]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, collectionGear4A, name, value)
    __swig_getmethods__ = {}
    for _s in [collection]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, collectionGear4A, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(collectionGear4A self, Box box, flt const dt, uint ncorrectionsteps, avector groups=vector< atomgroup * >(), 
            ivector interactions=vector< interaction * >(), tvector trackers=vector< statetracker * >(), 
            constraintvector constraints=vector< constraint * >()) -> collectionGear4A
        __init__(collectionGear4A self, Box box, flt const dt, uint ncorrectionsteps, avector groups=vector< atomgroup * >(), 
            ivector interactions=vector< interaction * >(), tvector trackers=vector< statetracker * >()) -> collectionGear4A
        __init__(collectionGear4A self, Box box, flt const dt, uint ncorrectionsteps, avector groups=vector< atomgroup * >(), 
            ivector interactions=vector< interaction * >()) -> collectionGear4A
        __init__(collectionGear4A self, Box box, flt const dt, uint ncorrectionsteps, avector groups=vector< atomgroup * >()) -> collectionGear4A
        __init__(collectionGear4A self, Box box, flt const dt, uint ncorrectionsteps) -> collectionGear4A
        __init__(collectionGear4A self, Box box, flt const dt, avector groups=vector< atomgroup * >(), ivector interactions=vector< interaction * >(), 
            tvector trackers=vector< statetracker * >(), 
            constraintvector constraints=vector< constraint * >()) -> collectionGear4A
        __init__(collectionGear4A self, Box box, flt const dt, avector groups=vector< atomgroup * >(), ivector interactions=vector< interaction * >(), 
            tvector trackers=vector< statetracker * >()) -> collectionGear4A
        __init__(collectionGear4A self, Box box, flt const dt, avector groups=vector< atomgroup * >(), ivector interactions=vector< interaction * >()) -> collectionGear4A
        __init__(collectionGear4A self, Box box, flt const dt, avector groups=vector< atomgroup * >()) -> collectionGear4A
        __init__(collectionGear4A self, Box box, flt const dt) -> collectionGear4A
        """
        this = _sim2d.new_collectionGear4A(*args)
        try: self.this.append(this)
        except: self.this = this
    def timestep(self) -> "void" :
        """timestep(collectionGear4A self)"""
        return _sim2d.collectionGear4A_timestep(self)

    def setdt(self, *args) -> "void" :
        """setdt(collectionGear4A self, flt newdt)"""
        return _sim2d.collectionGear4A_setdt(self, *args)

    __swig_destroy__ = _sim2d.delete_collectionGear4A
    __del__ = lambda self : None;
collectionGear4A_swigregister = _sim2d.collectionGear4A_swigregister
collectionGear4A_swigregister(collectionGear4A)

class collectionGear5A(collection):
    """Proxy of C++ collectionGear5A class"""
    __swig_setmethods__ = {}
    for _s in [collection]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, collectionGear5A, name, value)
    __swig_getmethods__ = {}
    for _s in [collection]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, collectionGear5A, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(collectionGear5A self, Box box, flt const dt, uint ncorrectionsteps, avector groups=vector< atomgroup * >(), 
            ivector interactions=vector< interaction * >(), tvector trackers=vector< statetracker * >(), 
            constraintvector constraints=vector< constraint * >()) -> collectionGear5A
        __init__(collectionGear5A self, Box box, flt const dt, uint ncorrectionsteps, avector groups=vector< atomgroup * >(), 
            ivector interactions=vector< interaction * >(), tvector trackers=vector< statetracker * >()) -> collectionGear5A
        __init__(collectionGear5A self, Box box, flt const dt, uint ncorrectionsteps, avector groups=vector< atomgroup * >(), 
            ivector interactions=vector< interaction * >()) -> collectionGear5A
        __init__(collectionGear5A self, Box box, flt const dt, uint ncorrectionsteps, avector groups=vector< atomgroup * >()) -> collectionGear5A
        __init__(collectionGear5A self, Box box, flt const dt, uint ncorrectionsteps) -> collectionGear5A
        __init__(collectionGear5A self, Box box, flt const dt, avector groups=vector< atomgroup * >(), ivector interactions=vector< interaction * >(), 
            tvector trackers=vector< statetracker * >(), 
            constraintvector constraints=vector< constraint * >()) -> collectionGear5A
        __init__(collectionGear5A self, Box box, flt const dt, avector groups=vector< atomgroup * >(), ivector interactions=vector< interaction * >(), 
            tvector trackers=vector< statetracker * >()) -> collectionGear5A
        __init__(collectionGear5A self, Box box, flt const dt, avector groups=vector< atomgroup * >(), ivector interactions=vector< interaction * >()) -> collectionGear5A
        __init__(collectionGear5A self, Box box, flt const dt, avector groups=vector< atomgroup * >()) -> collectionGear5A
        __init__(collectionGear5A self, Box box, flt const dt) -> collectionGear5A
        """
        this = _sim2d.new_collectionGear5A(*args)
        try: self.this.append(this)
        except: self.this = this
    def timestep(self) -> "void" :
        """timestep(collectionGear5A self)"""
        return _sim2d.collectionGear5A_timestep(self)

    def setdt(self, *args) -> "void" :
        """setdt(collectionGear5A self, flt newdt)"""
        return _sim2d.collectionGear5A_setdt(self, *args)

    __swig_destroy__ = _sim2d.delete_collectionGear5A
    __del__ = lambda self : None;
collectionGear5A_swigregister = _sim2d.collectionGear5A_swigregister
collectionGear5A_swigregister(collectionGear5A)

class collectionGear6A(collection):
    """Proxy of C++ collectionGear6A class"""
    __swig_setmethods__ = {}
    for _s in [collection]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, collectionGear6A, name, value)
    __swig_getmethods__ = {}
    for _s in [collection]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, collectionGear6A, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(collectionGear6A self, Box box, flt const dt, uint ncorrectionsteps, avector groups=vector< atomgroup * >(), 
            ivector interactions=vector< interaction * >(), tvector trackers=vector< statetracker * >(), 
            constraintvector constraints=vector< constraint * >()) -> collectionGear6A
        __init__(collectionGear6A self, Box box, flt const dt, uint ncorrectionsteps, avector groups=vector< atomgroup * >(), 
            ivector interactions=vector< interaction * >(), tvector trackers=vector< statetracker * >()) -> collectionGear6A
        __init__(collectionGear6A self, Box box, flt const dt, uint ncorrectionsteps, avector groups=vector< atomgroup * >(), 
            ivector interactions=vector< interaction * >()) -> collectionGear6A
        __init__(collectionGear6A self, Box box, flt const dt, uint ncorrectionsteps, avector groups=vector< atomgroup * >()) -> collectionGear6A
        __init__(collectionGear6A self, Box box, flt const dt, uint ncorrectionsteps) -> collectionGear6A
        __init__(collectionGear6A self, Box box, flt const dt, avector groups=vector< atomgroup * >(), ivector interactions=vector< interaction * >(), 
            tvector trackers=vector< statetracker * >(), 
            constraintvector constraints=vector< constraint * >()) -> collectionGear6A
        __init__(collectionGear6A self, Box box, flt const dt, avector groups=vector< atomgroup * >(), ivector interactions=vector< interaction * >(), 
            tvector trackers=vector< statetracker * >()) -> collectionGear6A
        __init__(collectionGear6A self, Box box, flt const dt, avector groups=vector< atomgroup * >(), ivector interactions=vector< interaction * >()) -> collectionGear6A
        __init__(collectionGear6A self, Box box, flt const dt, avector groups=vector< atomgroup * >()) -> collectionGear6A
        __init__(collectionGear6A self, Box box, flt const dt) -> collectionGear6A
        """
        this = _sim2d.new_collectionGear6A(*args)
        try: self.this.append(this)
        except: self.this = this
    def timestep(self) -> "void" :
        """timestep(collectionGear6A self)"""
        return _sim2d.collectionGear6A_timestep(self)

    def setdt(self, *args) -> "void" :
        """setdt(collectionGear6A self, flt newdt)"""
        return _sim2d.collectionGear6A_setdt(self, *args)

    __swig_destroy__ = _sim2d.delete_collectionGear6A
    __del__ = lambda self : None;
collectionGear6A_swigregister = _sim2d.collectionGear6A_swigregister
collectionGear6A_swigregister(collectionGear6A)

class atomRK4(atom):
    """Proxy of C++ atomRK4 class"""
    __swig_setmethods__ = {}
    for _s in [atom]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, atomRK4, name, value)
    __swig_getmethods__ = {}
    for _s in [atom]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, atomRK4, name)
    __repr__ = _swig_repr
    __swig_setmethods__["Kxa"] = _sim2d.atomRK4_Kxa_set
    __swig_getmethods__["Kxa"] = _sim2d.atomRK4_Kxa_get
    if _newclass:Kxa = _swig_property(_sim2d.atomRK4_Kxa_get, _sim2d.atomRK4_Kxa_set)
    __swig_setmethods__["Kxb"] = _sim2d.atomRK4_Kxb_set
    __swig_getmethods__["Kxb"] = _sim2d.atomRK4_Kxb_get
    if _newclass:Kxb = _swig_property(_sim2d.atomRK4_Kxb_get, _sim2d.atomRK4_Kxb_set)
    __swig_setmethods__["Kxc"] = _sim2d.atomRK4_Kxc_set
    __swig_getmethods__["Kxc"] = _sim2d.atomRK4_Kxc_get
    if _newclass:Kxc = _swig_property(_sim2d.atomRK4_Kxc_get, _sim2d.atomRK4_Kxc_set)
    __swig_setmethods__["Kxd"] = _sim2d.atomRK4_Kxd_set
    __swig_getmethods__["Kxd"] = _sim2d.atomRK4_Kxd_get
    if _newclass:Kxd = _swig_property(_sim2d.atomRK4_Kxd_get, _sim2d.atomRK4_Kxd_set)
    __swig_setmethods__["Kva"] = _sim2d.atomRK4_Kva_set
    __swig_getmethods__["Kva"] = _sim2d.atomRK4_Kva_get
    if _newclass:Kva = _swig_property(_sim2d.atomRK4_Kva_get, _sim2d.atomRK4_Kva_set)
    __swig_setmethods__["Kvb"] = _sim2d.atomRK4_Kvb_set
    __swig_getmethods__["Kvb"] = _sim2d.atomRK4_Kvb_get
    if _newclass:Kvb = _swig_property(_sim2d.atomRK4_Kvb_get, _sim2d.atomRK4_Kvb_set)
    __swig_setmethods__["Kvc"] = _sim2d.atomRK4_Kvc_set
    __swig_getmethods__["Kvc"] = _sim2d.atomRK4_Kvc_get
    if _newclass:Kvc = _swig_property(_sim2d.atomRK4_Kvc_get, _sim2d.atomRK4_Kvc_set)
    __swig_setmethods__["Kvd"] = _sim2d.atomRK4_Kvd_set
    __swig_getmethods__["Kvd"] = _sim2d.atomRK4_Kvd_get
    if _newclass:Kvd = _swig_property(_sim2d.atomRK4_Kvd_get, _sim2d.atomRK4_Kvd_set)
    def __init__(self): 
        """__init__(atomRK4 self) -> atomRK4"""
        this = _sim2d.new_atomRK4()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _sim2d.delete_atomRK4
    __del__ = lambda self : None;
atomRK4_swigregister = _sim2d.atomRK4_swigregister
atomRK4_swigregister(atomRK4)

class atomvecRK4(atomgroup):
    """Proxy of C++ atomvecRK4 class"""
    __swig_setmethods__ = {}
    for _s in [atomgroup]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, atomvecRK4, name, value)
    __swig_getmethods__ = {}
    for _s in [atomgroup]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, atomvecRK4, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(atomvecRK4 self, fvector masses) -> atomvecRK4
        __init__(atomvecRK4 self, atomgroup g) -> atomvecRK4
        """
        this = _sim2d.new_atomvecRK4(*args)
        try: self.this.append(this)
        except: self.this = this
    def get(self, *args) -> "atom *" :
        """get(atomvecRK4 self, cuint n) -> atom"""
        return _sim2d.atomvecRK4_get(self, *args)

    def getRK4(self, *args) -> "atomRK4 *" :
        """getRK4(atomvecRK4 self, cuint n) -> atomRK4"""
        return _sim2d.atomvecRK4_getRK4(self, *args)

    def get_id(self, *args) -> "atomid" :
        """
        get_id(atomvecRK4 self, atom a) -> atomid
        get_id(atomvecRK4 self, uint n) -> atomid
        """
        return _sim2d.atomvecRK4_get_id(self, *args)

    def size(self) -> "uint" :
        """size(atomvecRK4 self) -> uint"""
        return _sim2d.atomvecRK4_size(self)

    __swig_destroy__ = _sim2d.delete_atomvecRK4
    __del__ = lambda self : None;
atomvecRK4_swigregister = _sim2d.atomvecRK4_swigregister
atomvecRK4_swigregister(atomvecRK4)

class collectionRK4(collection):
    """Proxy of C++ collectionRK4 class"""
    __swig_setmethods__ = {}
    for _s in [collection]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, collectionRK4, name, value)
    __swig_getmethods__ = {}
    for _s in [collection]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, collectionRK4, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(collectionRK4 self, Box box, flt const dt, aRK4vector rgroups=vector< atomvecRK4 * >(), ivector interactions=vector< interaction * >(), 
            tvector trackers=vector< statetracker * >(), 
            constraintvector constraints=vector< constraint * >()) -> collectionRK4
        __init__(collectionRK4 self, Box box, flt const dt, aRK4vector rgroups=vector< atomvecRK4 * >(), ivector interactions=vector< interaction * >(), 
            tvector trackers=vector< statetracker * >()) -> collectionRK4
        __init__(collectionRK4 self, Box box, flt const dt, aRK4vector rgroups=vector< atomvecRK4 * >(), ivector interactions=vector< interaction * >()) -> collectionRK4
        __init__(collectionRK4 self, Box box, flt const dt, aRK4vector rgroups=vector< atomvecRK4 * >()) -> collectionRK4
        __init__(collectionRK4 self, Box box, flt const dt) -> collectionRK4
        """
        this = _sim2d.new_collectionRK4(*args)
        try: self.this.append(this)
        except: self.this = this
    def timestep(self) -> "void" :
        """timestep(collectionRK4 self)"""
        return _sim2d.collectionRK4_timestep(self)

    def setdt(self, *args) -> "void" :
        """setdt(collectionRK4 self, flt newdt)"""
        return _sim2d.collectionRK4_setdt(self, *args)

    __swig_destroy__ = _sim2d.delete_collectionRK4
    __del__ = lambda self : None;
collectionRK4_swigregister = _sim2d.collectionRK4_swigregister
collectionRK4_swigregister(collectionRK4)

class collectionGear4NPH(collection):
    """Proxy of C++ collectionGear4NPH class"""
    __swig_setmethods__ = {}
    for _s in [collection]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, collectionGear4NPH, name, value)
    __swig_getmethods__ = {}
    for _s in [collection]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, collectionGear4NPH, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(collectionGear4NPH self, OriginBox box, flt const dt, flt const P, flt const Q, uint ncorrectionsteps, avector groups=vector< atomgroup * >(), 
            ivector interactions=vector< interaction * >(), 
            tvector trackers=vector< statetracker * >(), constraintvector constraints=vector< constraint * >()) -> collectionGear4NPH
        __init__(collectionGear4NPH self, OriginBox box, flt const dt, flt const P, flt const Q, uint ncorrectionsteps, avector groups=vector< atomgroup * >(), 
            ivector interactions=vector< interaction * >(), 
            tvector trackers=vector< statetracker * >()) -> collectionGear4NPH
        __init__(collectionGear4NPH self, OriginBox box, flt const dt, flt const P, flt const Q, uint ncorrectionsteps, avector groups=vector< atomgroup * >(), 
            ivector interactions=vector< interaction * >()) -> collectionGear4NPH
        __init__(collectionGear4NPH self, OriginBox box, flt const dt, flt const P, flt const Q, uint ncorrectionsteps, avector groups=vector< atomgroup * >()) -> collectionGear4NPH
        __init__(collectionGear4NPH self, OriginBox box, flt const dt, flt const P, flt const Q, uint ncorrectionsteps) -> collectionGear4NPH
        __init__(collectionGear4NPH self, OriginBox box, flt const dt, flt const P, flt const Q, avector groups=vector< atomgroup * >(), 
            ivector interactions=vector< interaction * >(), tvector trackers=vector< statetracker * >(), 
            constraintvector constraints=vector< constraint * >()) -> collectionGear4NPH
        __init__(collectionGear4NPH self, OriginBox box, flt const dt, flt const P, flt const Q, avector groups=vector< atomgroup * >(), 
            ivector interactions=vector< interaction * >(), tvector trackers=vector< statetracker * >()) -> collectionGear4NPH
        __init__(collectionGear4NPH self, OriginBox box, flt const dt, flt const P, flt const Q, avector groups=vector< atomgroup * >(), 
            ivector interactions=vector< interaction * >()) -> collectionGear4NPH
        __init__(collectionGear4NPH self, OriginBox box, flt const dt, flt const P, flt const Q, avector groups=vector< atomgroup * >()) -> collectionGear4NPH
        __init__(collectionGear4NPH self, OriginBox box, flt const dt, flt const P, flt const Q) -> collectionGear4NPH
        """
        this = _sim2d.new_collectionGear4NPH(*args)
        try: self.this.append(this)
        except: self.this = this
    def timestep(self) -> "void" :
        """timestep(collectionGear4NPH self)"""
        return _sim2d.collectionGear4NPH_timestep(self)

    def kinetic(self) -> "flt" :
        """kinetic(collectionGear4NPH self) -> flt"""
        return _sim2d.collectionGear4NPH_kinetic(self)

    def temp(self, minuscomv : 'bool'=True) -> "flt" :
        """
        temp(collectionGear4NPH self, bool minuscomv=True) -> flt
        temp(collectionGear4NPH self) -> flt
        """
        return _sim2d.collectionGear4NPH_temp(self, minuscomv)

    def Hamiltonian(self) -> "flt" :
        """Hamiltonian(collectionGear4NPH self) -> flt"""
        return _sim2d.collectionGear4NPH_Hamiltonian(self)

    def getdV(self) -> "flt" :
        """getdV(collectionGear4NPH self) -> flt"""
        return _sim2d.collectionGear4NPH_getdV(self)

    def getddV(self) -> "flt" :
        """getddV(collectionGear4NPH self) -> flt"""
        return _sim2d.collectionGear4NPH_getddV(self)

    def setdt(self, *args) -> "void" :
        """setdt(collectionGear4NPH self, flt newdt)"""
        return _sim2d.collectionGear4NPH_setdt(self, *args)

    __swig_destroy__ = _sim2d.delete_collectionGear4NPH
    __del__ = lambda self : None;
collectionGear4NPH_swigregister = _sim2d.collectionGear4NPH_swigregister
collectionGear4NPH_swigregister(collectionGear4NPH)

class xrpsummer(fpairxFunct):
    """Proxy of C++ xrpsummer class"""
    __swig_setmethods__ = {}
    for _s in [fpairxFunct]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, xrpsummer, name, value)
    __swig_getmethods__ = {}
    for _s in [fpairxFunct]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, xrpsummer, name)
    __repr__ = _swig_repr
    __swig_setmethods__["xsum"] = _sim2d.xrpsummer_xsum_set
    __swig_getmethods__["xsum"] = _sim2d.xrpsummer_xsum_get
    if _newclass:xsum = _swig_property(_sim2d.xrpsummer_xsum_get, _sim2d.xrpsummer_xsum_set)
    __swig_setmethods__["rpxsum"] = _sim2d.xrpsummer_rpxsum_set
    __swig_getmethods__["rpxsum"] = _sim2d.xrpsummer_rpxsum_get
    if _newclass:rpxsum = _swig_property(_sim2d.xrpsummer_rpxsum_get, _sim2d.xrpsummer_rpxsum_set)
    __swig_setmethods__["vfsum"] = _sim2d.xrpsummer_vfsum_set
    __swig_getmethods__["vfsum"] = _sim2d.xrpsummer_vfsum_get
    if _newclass:vfsum = _swig_property(_sim2d.xrpsummer_vfsum_get, _sim2d.xrpsummer_vfsum_set)
    __swig_setmethods__["rfsum"] = _sim2d.xrpsummer_rfsum_set
    __swig_getmethods__["rfsum"] = _sim2d.xrpsummer_rfsum_get
    if _newclass:rfsum = _swig_property(_sim2d.xrpsummer_rfsum_get, _sim2d.xrpsummer_rfsum_set)
    def __init__(self, *args): 
        """__init__(xrpsummer self, Box box) -> xrpsummer"""
        this = _sim2d.new_xrpsummer(*args)
        try: self.this.append(this)
        except: self.this = this
    def run(self, *args) -> "void" :
        """run(xrpsummer self, forcepairx arg2)"""
        return _sim2d.xrpsummer_run(self, *args)

    def reset(self) -> "void" :
        """reset(xrpsummer self)"""
        return _sim2d.xrpsummer_reset(self)

    __swig_destroy__ = _sim2d.delete_xrpsummer
    __del__ = lambda self : None;
xrpsummer_swigregister = _sim2d.xrpsummer_swigregister
xrpsummer_swigregister(xrpsummer)

class collectionGear4NPT(collection):
    """Proxy of C++ collectionGear4NPT class"""
    __swig_setmethods__ = {}
    for _s in [collection]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, collectionGear4NPT, name, value)
    __swig_getmethods__ = {}
    for _s in [collection]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, collectionGear4NPT, name)
    __repr__ = _swig_repr
    __swig_setmethods__["dt"] = _sim2d.collectionGear4NPT_dt_set
    __swig_getmethods__["dt"] = _sim2d.collectionGear4NPT_dt_get
    if _newclass:dt = _swig_property(_sim2d.collectionGear4NPT_dt_get, _sim2d.collectionGear4NPT_dt_set)
    __swig_setmethods__["xrpsums"] = _sim2d.collectionGear4NPT_xrpsums_set
    __swig_getmethods__["xrpsums"] = _sim2d.collectionGear4NPT_xrpsums_get
    if _newclass:xrpsums = _swig_property(_sim2d.collectionGear4NPT_xrpsums_get, _sim2d.collectionGear4NPT_xrpsums_set)
    __swig_setmethods__["ncorrec"] = _sim2d.collectionGear4NPT_ncorrec_set
    __swig_getmethods__["ncorrec"] = _sim2d.collectionGear4NPT_ncorrec_get
    if _newclass:ncorrec = _swig_property(_sim2d.collectionGear4NPT_ncorrec_get, _sim2d.collectionGear4NPT_ncorrec_set)
    __swig_setmethods__["V1"] = _sim2d.collectionGear4NPT_V1_set
    __swig_getmethods__["V1"] = _sim2d.collectionGear4NPT_V1_get
    if _newclass:V1 = _swig_property(_sim2d.collectionGear4NPT_V1_get, _sim2d.collectionGear4NPT_V1_set)
    __swig_setmethods__["V2"] = _sim2d.collectionGear4NPT_V2_set
    __swig_getmethods__["V2"] = _sim2d.collectionGear4NPT_V2_get
    if _newclass:V2 = _swig_property(_sim2d.collectionGear4NPT_V2_get, _sim2d.collectionGear4NPT_V2_set)
    __swig_setmethods__["V3"] = _sim2d.collectionGear4NPT_V3_set
    __swig_getmethods__["V3"] = _sim2d.collectionGear4NPT_V3_get
    if _newclass:V3 = _swig_property(_sim2d.collectionGear4NPT_V3_get, _sim2d.collectionGear4NPT_V3_set)
    __swig_setmethods__["chi"] = _sim2d.collectionGear4NPT_chi_set
    __swig_getmethods__["chi"] = _sim2d.collectionGear4NPT_chi_get
    if _newclass:chi = _swig_property(_sim2d.collectionGear4NPT_chi_get, _sim2d.collectionGear4NPT_chi_set)
    __swig_setmethods__["chixi"] = _sim2d.collectionGear4NPT_chixi_set
    __swig_getmethods__["chixi"] = _sim2d.collectionGear4NPT_chixi_get
    if _newclass:chixi = _swig_property(_sim2d.collectionGear4NPT_chixi_get, _sim2d.collectionGear4NPT_chixi_set)
    __swig_setmethods__["xs1"] = _sim2d.collectionGear4NPT_xs1_set
    __swig_getmethods__["xs1"] = _sim2d.collectionGear4NPT_xs1_get
    if _newclass:xs1 = _swig_property(_sim2d.collectionGear4NPT_xs1_get, _sim2d.collectionGear4NPT_xs1_set)
    __swig_setmethods__["xs2"] = _sim2d.collectionGear4NPT_xs2_set
    __swig_getmethods__["xs2"] = _sim2d.collectionGear4NPT_xs2_get
    if _newclass:xs2 = _swig_property(_sim2d.collectionGear4NPT_xs2_get, _sim2d.collectionGear4NPT_xs2_set)
    __swig_setmethods__["xs3"] = _sim2d.collectionGear4NPT_xs3_set
    __swig_getmethods__["xs3"] = _sim2d.collectionGear4NPT_xs3_get
    if _newclass:xs3 = _swig_property(_sim2d.collectionGear4NPT_xs3_get, _sim2d.collectionGear4NPT_xs3_set)
    __swig_setmethods__["vs2"] = _sim2d.collectionGear4NPT_vs2_set
    __swig_getmethods__["vs2"] = _sim2d.collectionGear4NPT_vs2_get
    if _newclass:vs2 = _swig_property(_sim2d.collectionGear4NPT_vs2_get, _sim2d.collectionGear4NPT_vs2_set)
    __swig_setmethods__["vs3"] = _sim2d.collectionGear4NPT_vs3_set
    __swig_getmethods__["vs3"] = _sim2d.collectionGear4NPT_vs3_get
    if _newclass:vs3 = _swig_property(_sim2d.collectionGear4NPT_vs3_get, _sim2d.collectionGear4NPT_vs3_set)
    def resetbs(self) -> "void" :
        """resetbs(collectionGear4NPT self)"""
        return _sim2d.collectionGear4NPT_resetbs(self)

    def tointerpair(*args) -> "std::vector< interaction * >" :
        """tointerpair(ifxvector arg1) -> ivector"""
        return _sim2d.collectionGear4NPT_tointerpair(*args)

    if _newclass:tointerpair = staticmethod(tointerpair)
    __swig_getmethods__["tointerpair"] = lambda x: tointerpair
    def __init__(self, *args): 
        """
        __init__(collectionGear4NPT self, OriginBox box, flt const dt, uint ncorrectionsteps, avector groups=vector< atomgroup * >(), 
            ifxvector interactions=vector< interactionpairsx * >(), tvector trackers=vector< statetracker * >(), 
            constraintvector constraints=vector< constraint * >()) -> collectionGear4NPT
        __init__(collectionGear4NPT self, OriginBox box, flt const dt, uint ncorrectionsteps, avector groups=vector< atomgroup * >(), 
            ifxvector interactions=vector< interactionpairsx * >(), tvector trackers=vector< statetracker * >()) -> collectionGear4NPT
        __init__(collectionGear4NPT self, OriginBox box, flt const dt, uint ncorrectionsteps, avector groups=vector< atomgroup * >(), 
            ifxvector interactions=vector< interactionpairsx * >()) -> collectionGear4NPT
        __init__(collectionGear4NPT self, OriginBox box, flt const dt, uint ncorrectionsteps, avector groups=vector< atomgroup * >()) -> collectionGear4NPT
        __init__(collectionGear4NPT self, OriginBox box, flt const dt, uint ncorrectionsteps) -> collectionGear4NPT
        __init__(collectionGear4NPT self, OriginBox box, flt const dt, avector groups=vector< atomgroup * >(), ifxvector interactions=vector< interactionpairsx * >(), 
            tvector trackers=vector< statetracker * >(), 
            constraintvector constraints=vector< constraint * >()) -> collectionGear4NPT
        __init__(collectionGear4NPT self, OriginBox box, flt const dt, avector groups=vector< atomgroup * >(), ifxvector interactions=vector< interactionpairsx * >(), 
            tvector trackers=vector< statetracker * >()) -> collectionGear4NPT
        __init__(collectionGear4NPT self, OriginBox box, flt const dt, avector groups=vector< atomgroup * >(), ifxvector interactions=vector< interactionpairsx * >()) -> collectionGear4NPT
        __init__(collectionGear4NPT self, OriginBox box, flt const dt, avector groups=vector< atomgroup * >()) -> collectionGear4NPT
        __init__(collectionGear4NPT self, OriginBox box, flt const dt) -> collectionGear4NPT
        """
        this = _sim2d.new_collectionGear4NPT(*args)
        try: self.this.append(this)
        except: self.this = this
    def setForces(self, seta : 'bool'=True) -> "void" :
        """
        setForces(collectionGear4NPT self, bool seta=True)
        setForces(collectionGear4NPT self)
        """
        return _sim2d.collectionGear4NPT_setForces(self, seta)

    def timestep(self) -> "void" :
        """timestep(collectionGear4NPT self)"""
        return _sim2d.collectionGear4NPT_timestep(self)

    __swig_destroy__ = _sim2d.delete_collectionGear4NPT
    __del__ = lambda self : None;
collectionGear4NPT_swigregister = _sim2d.collectionGear4NPT_swigregister
collectionGear4NPT_swigregister(collectionGear4NPT)

def collectionGear4NPT_tointerpair(*args) -> "std::vector< interaction * >" :
  """collectionGear4NPT_tointerpair(ifxvector arg1) -> ivector"""
  return _sim2d.collectionGear4NPT_tointerpair(*args)

class collectionVerletNPT(collection):
    """Proxy of C++ collectionVerletNPT class"""
    __swig_setmethods__ = {}
    for _s in [collection]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, collectionVerletNPT, name, value)
    __swig_getmethods__ = {}
    for _s in [collection]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, collectionVerletNPT, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(collectionVerletNPT self, OriginBox box, flt const dt, flt const P, flt const QP, flt const T, flt const QT, 
            avector groups=vector< atomgroup * >(), ivector interactions=vector< interaction * >(), 
            tvector trackers=vector< statetracker * >(), constraintvector constraints=vector< constraint * >()) -> collectionVerletNPT
        __init__(collectionVerletNPT self, OriginBox box, flt const dt, flt const P, flt const QP, flt const T, flt const QT, 
            avector groups=vector< atomgroup * >(), ivector interactions=vector< interaction * >(), 
            tvector trackers=vector< statetracker * >()) -> collectionVerletNPT
        __init__(collectionVerletNPT self, OriginBox box, flt const dt, flt const P, flt const QP, flt const T, flt const QT, 
            avector groups=vector< atomgroup * >(), ivector interactions=vector< interaction * >()) -> collectionVerletNPT
        __init__(collectionVerletNPT self, OriginBox box, flt const dt, flt const P, flt const QP, flt const T, flt const QT, 
            avector groups=vector< atomgroup * >()) -> collectionVerletNPT
        __init__(collectionVerletNPT self, OriginBox box, flt const dt, flt const P, flt const QP, flt const T, flt const QT) -> collectionVerletNPT
        """
        this = _sim2d.new_collectionVerletNPT(*args)
        try: self.this.append(this)
        except: self.this = this
    def timestep(self) -> "void" :
        """timestep(collectionVerletNPT self)"""
        return _sim2d.collectionVerletNPT_timestep(self)

    def setdt(self, *args) -> "void" :
        """setdt(collectionVerletNPT self, flt newdt)"""
        return _sim2d.collectionVerletNPT_setdt(self, *args)

    def resetcomv(self) -> "void" :
        """resetcomv(collectionVerletNPT self)"""
        return _sim2d.collectionVerletNPT_resetcomv(self)

    def resetL(self) -> "void" :
        """resetL(collectionVerletNPT self)"""
        return _sim2d.collectionVerletNPT_resetL(self)

    def scaleVs(self, *args) -> "void" :
        """scaleVs(collectionVerletNPT self, flt scaleby)"""
        return _sim2d.collectionVerletNPT_scaleVs(self, *args)

    def scaleVelocitiesT(self, *args) -> "void" :
        """scaleVelocitiesT(collectionVerletNPT self, flt T)"""
        return _sim2d.collectionVerletNPT_scaleVelocitiesT(self, *args)

    def scaleVelocitiesE(self, *args) -> "void" :
        """scaleVelocitiesE(collectionVerletNPT self, flt E)"""
        return _sim2d.collectionVerletNPT_scaleVelocitiesE(self, *args)

    def geteta(self) -> "flt" :
        """geteta(collectionVerletNPT self) -> flt"""
        return _sim2d.collectionVerletNPT_geteta(self)

    def getxidot(self) -> "flt" :
        """getxidot(collectionVerletNPT self) -> flt"""
        return _sim2d.collectionVerletNPT_getxidot(self)

    def getP(self) -> "flt" :
        """getP(collectionVerletNPT self) -> flt"""
        return _sim2d.collectionVerletNPT_getP(self)

    def getvhalf(self, *args) -> "Vec" :
        """getvhalf(collectionVerletNPT self, uint n) -> Vec"""
        return _sim2d.collectionVerletNPT_getvhalf(self, *args)

    __swig_destroy__ = _sim2d.delete_collectionVerletNPT
    __del__ = lambda self : None;
collectionVerletNPT_swigregister = _sim2d.collectionVerletNPT_swigregister
collectionVerletNPT_swigregister(collectionVerletNPT)

# This file is compatible with both classic and new-style classes.


